var p2 = Object.defineProperty;
var sp = Object.getOwnPropertySymbols;
var m2 = Object.prototype.hasOwnProperty,
    y2 = Object.prototype.propertyIsEnumerable;
var op = (t, e, r) => e in t ? p2(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    mo = (t, e) => {
        for (var r in e || (e = {})) m2.call(e, r) && op(t, r, e[r]);
        if (sp)
            for (var r of sp(e)) y2.call(e, r) && op(t, r, e[r]);
        return t
    };

function h0(t, e) {
    const r = Object.create(null),
        n = t.split(",");
    for (let i = 0; i < n.length; i++) r[n[i]] = !0;
    return e ? i => !!r[i.toLowerCase()] : i => !!r[i]
}
const g2 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    x2 = h0(g2);

function ap(t) {
    return !!t || t === ""
}

function d0(t) {
    if (qe(t)) {
        const e = {};
        for (let r = 0; r < t.length; r++) {
            const n = t[r],
                i = ur(n) ? w2(n) : d0(n);
            if (i)
                for (const s in i) e[s] = i[s]
        }
        return e
    } else {
        if (ur(t)) return t;
        if (Vt(t)) return t
    }
}
const b2 = /;(?![^(]*\))/g,
    v2 = /:(.+)/;

function w2(t) {
    const e = {};
    return t.split(b2).forEach(r => {
        if (r) {
            const n = r.split(v2);
            n.length > 1 && (e[n[0].trim()] = n[1].trim())
        }
    }), e
}

function p0(t) {
    let e = "";
    if (ur(t)) e = t;
    else if (qe(t))
        for (let r = 0; r < t.length; r++) {
            const n = p0(t[r]);
            n && (e += n + " ")
        } else if (Vt(t))
            for (const r in t) t[r] && (e += r + " ");
    return e.trim()
}
const fp = t => t == null ? "" : qe(t) || Vt(t) && (t.toString === hp || !Qe(t.toString)) ? JSON.stringify(t, up, 2) : String(t),
    up = (t, e) => e && e.__v_isRef ? up(t, e.value) : go(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((r, [n, i]) => (r[`${n} =>`] = i, r), {})
    } : lp(e) ? {
        [`Set(${e.size})`]: [...e.values()]
    } : Vt(e) && !qe(e) && !dp(e) ? String(e) : e,
    Pt = {},
    yo = [],
    Un = () => {},
    E2 = () => !1,
    A2 = /^on[^a-z]/,
    Gf = t => A2.test(t),
    m0 = t => t.startsWith("onUpdate:"),
    fr = Object.assign,
    y0 = (t, e) => {
        const r = t.indexOf(e);
        r > -1 && t.splice(r, 1)
    },
    _2 = Object.prototype.hasOwnProperty,
    yt = (t, e) => _2.call(t, e),
    qe = Array.isArray,
    go = t => zf(t) === "[object Map]",
    lp = t => zf(t) === "[object Set]",
    Qe = t => typeof t == "function",
    ur = t => typeof t == "string",
    g0 = t => typeof t == "symbol",
    Vt = t => t !== null && typeof t == "object",
    cp = t => Vt(t) && Qe(t.then) && Qe(t.catch),
    hp = Object.prototype.toString,
    zf = t => hp.call(t),
    T2 = t => zf(t).slice(8, -1),
    dp = t => zf(t) === "[object Object]",
    x0 = t => ur(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    Hf = h0(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    qf = t => {
        const e = Object.create(null);
        return r => e[r] || (e[r] = t(r))
    },
    M2 = /-(\w)/g,
    ai = qf(t => t.replace(M2, (e, r) => r ? r.toUpperCase() : "")),
    N2 = /\B([A-Z])/g,
    xo = qf(t => t.replace(N2, "-$1").toLowerCase()),
    jf = qf(t => t.charAt(0).toUpperCase() + t.slice(1)),
    b0 = qf(t => t ? `on${jf(t)}` : ""),
    va = (t, e) => !Object.is(t, e),
    Wf = (t, e) => {
        for (let r = 0; r < t.length; r++) t[r](e)
    },
    Vf = (t, e, r) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: r
        })
    },
    Kf = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    };
let pp;
const S2 = () => pp || (pp = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : {});
let Os;
const Xf = [];
class P2 {
    constructor(e = !1) {
        this.active = !0, this.effects = [], this.cleanups = [], !e && Os && (this.parent = Os, this.index = (Os.scopes || (Os.scopes = [])).push(this) - 1)
    }
    run(e) {
        if (this.active) try {
            return this.on(), e()
        } finally {
            this.off()
        }
    }
    on() {
        this.active && (Xf.push(this), Os = this)
    }
    off() {
        this.active && (Xf.pop(), Os = Xf[Xf.length - 1])
    }
    stop(e) {
        if (this.active) {
            if (this.effects.forEach(r => r.stop()), this.cleanups.forEach(r => r()), this.scopes && this.scopes.forEach(r => r.stop(!0)), this.parent && !e) {
                const r = this.parent.scopes.pop();
                r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index)
            }
            this.active = !1
        }
    }
}

function I2(t, e) {
    e = e || Os, e && e.active && e.effects.push(t)
}
const v0 = t => {
        const e = new Set(t);
        return e.w = 0, e.n = 0, e
    },
    mp = t => (t.w & os) > 0,
    yp = t => (t.n & os) > 0,
    R2 = ({
        deps: t
    }) => {
        if (t.length)
            for (let e = 0; e < t.length; e++) t[e].w |= os
    },
    k2 = t => {
        const {
            deps: e
        } = t;
        if (e.length) {
            let r = 0;
            for (let n = 0; n < e.length; n++) {
                const i = e[n];
                mp(i) && !yp(i) ? i.delete(t) : e[r++] = i, i.w &= ~os, i.n &= ~os
            }
            e.length = r
        }
    },
    w0 = new WeakMap;
let wa = 0,
    os = 1;
const E0 = 30,
    Ea = [];
let Cs;
const Fs = Symbol(""),
    A0 = Symbol("");
class _0 {
    constructor(e, r = null, n) {
        this.fn = e, this.scheduler = r, this.active = !0, this.deps = [], I2(this, n)
    }
    run() {
        if (!this.active) return this.fn();
        if (!Ea.includes(this)) try {
            return Ea.push(Cs = this), O2(), os = 1 << ++wa, wa <= E0 ? R2(this) : gp(this), this.fn()
        } finally {
            wa <= E0 && k2(this), os = 1 << --wa, Ds(), Ea.pop();
            const e = Ea.length;
            Cs = e > 0 ? Ea[e - 1] : void 0
        }
    }
    stop() {
        this.active && (gp(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function gp(t) {
    const {
        deps: e
    } = t;
    if (e.length) {
        for (let r = 0; r < e.length; r++) e[r].delete(t);
        e.length = 0
    }
}
let bo = !0;
const T0 = [];

function vo() {
    T0.push(bo), bo = !1
}

function O2() {
    T0.push(bo), bo = !0
}

function Ds() {
    const t = T0.pop();
    bo = t === void 0 ? !0 : t
}

function qr(t, e, r) {
    if (!xp()) return;
    let n = w0.get(t);
    n || w0.set(t, n = new Map);
    let i = n.get(r);
    i || n.set(r, i = v0()), bp(i)
}

function xp() {
    return bo && Cs !== void 0
}

function bp(t, e) {
    let r = !1;
    wa <= E0 ? yp(t) || (t.n |= os, r = !mp(t)) : r = !t.has(Cs), r && (t.add(Cs), Cs.deps.push(t))
}

function Gi(t, e, r, n, i, s) {
    const o = w0.get(t);
    if (!o) return;
    let f = [];
    if (e === "clear") f = [...o.values()];
    else if (r === "length" && qe(t)) o.forEach((l, d) => {
        (d === "length" || d >= n) && f.push(l)
    });
    else switch (r !== void 0 && f.push(o.get(r)), e) {
        case "add":
            qe(t) ? x0(r) && f.push(o.get("length")) : (f.push(o.get(Fs)), go(t) && f.push(o.get(A0)));
            break;
        case "delete":
            qe(t) || (f.push(o.get(Fs)), go(t) && f.push(o.get(A0)));
            break;
        case "set":
            go(t) && f.push(o.get(Fs));
            break
    }
    if (f.length === 1) f[0] && M0(f[0]);
    else {
        const l = [];
        for (const d of f) d && l.push(...d);
        M0(v0(l))
    }
}

function M0(t, e) {
    for (const r of qe(t) ? t : [...t])(r !== Cs || r.allowRecurse) && (r.scheduler ? r.scheduler() : r.run())
}
const C2 = h0("__proto__,__v_isRef,__isVue"),
    vp = new Set(Object.getOwnPropertyNames(Symbol).map(t => Symbol[t]).filter(g0)),
    F2 = N0(),
    D2 = N0(!1, !0),
    U2 = N0(!0),
    wp = L2();

function L2() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function(...r) {
            const n = At(this);
            for (let s = 0, o = this.length; s < o; s++) qr(n, "get", s + "");
            const i = n[e](...r);
            return i === -1 || i === !1 ? n[e](...r.map(At)) : i
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        t[e] = function(...r) {
            vo();
            const n = At(this)[e].apply(this, r);
            return Ds(), n
        }
    }), t
}

function N0(t = !1, e = !1) {
    return function(n, i, s) {
        if (i === "__v_isReactive") return !t;
        if (i === "__v_isReadonly") return t;
        if (i === "__v_raw" && s === (t ? e ? ew : Ip : e ? Pp : Sp).get(n)) return n;
        const o = qe(n);
        if (!t && o && yt(wp, i)) return Reflect.get(wp, i, s);
        const f = Reflect.get(n, i, s);
        return (g0(i) ? vp.has(i) : C2(i)) || (t || qr(n, "get", i), e) ? f : Ut(f) ? !o || !x0(i) ? f.value : f : Vt(f) ? t ? Rp(f) : wo(f) : f
    }
}
const B2 = Ep(),
    $2 = Ep(!0);

function Ep(t = !1) {
    return function(r, n, i, s) {
        let o = r[n];
        if (!t && !R0(i) && (i = At(i), o = At(o), !qe(r) && Ut(o) && !Ut(i))) return o.value = i, !0;
        const f = qe(r) && x0(n) ? Number(n) < r.length : yt(r, n),
            l = Reflect.set(r, n, i, s);
        return r === At(s) && (f ? va(i, o) && Gi(r, "set", n, i) : Gi(r, "add", n, i)), l
    }
}

function G2(t, e) {
    const r = yt(t, e);
    t[e];
    const n = Reflect.deleteProperty(t, e);
    return n && r && Gi(t, "delete", e, void 0), n
}

function z2(t, e) {
    const r = Reflect.has(t, e);
    return (!g0(e) || !vp.has(e)) && qr(t, "has", e), r
}

function H2(t) {
    return qr(t, "iterate", qe(t) ? "length" : Fs), Reflect.ownKeys(t)
}
const Ap = {
        get: F2,
        set: B2,
        deleteProperty: G2,
        has: z2,
        ownKeys: H2
    },
    q2 = {
        get: U2,
        set(t, e) {
            return !0
        },
        deleteProperty(t, e) {
            return !0
        }
    },
    j2 = fr({}, Ap, {
        get: D2,
        set: $2
    }),
    S0 = t => t,
    Jf = t => Reflect.getPrototypeOf(t);

function Zf(t, e, r = !1, n = !1) {
    t = t.__v_raw;
    const i = At(t),
        s = At(e);
    e !== s && !r && qr(i, "get", e), !r && qr(i, "get", s);
    const {
        has: o
    } = Jf(i), f = n ? S0 : r ? k0 : Aa;
    if (o.call(i, e)) return f(t.get(e));
    if (o.call(i, s)) return f(t.get(s));
    t !== i && t.get(e)
}

function Yf(t, e = !1) {
    const r = this.__v_raw,
        n = At(r),
        i = At(t);
    return t !== i && !e && qr(n, "has", t), !e && qr(n, "has", i), t === i ? r.has(t) : r.has(t) || r.has(i)
}

function Qf(t, e = !1) {
    return t = t.__v_raw, !e && qr(At(t), "iterate", Fs), Reflect.get(t, "size", t)
}

function _p(t) {
    t = At(t);
    const e = At(this);
    return Jf(e).has.call(e, t) || (e.add(t), Gi(e, "add", t, t)), this
}

function Tp(t, e) {
    e = At(e);
    const r = At(this),
        {
            has: n,
            get: i
        } = Jf(r);
    let s = n.call(r, t);
    s || (t = At(t), s = n.call(r, t));
    const o = i.call(r, t);
    return r.set(t, e), s ? va(e, o) && Gi(r, "set", t, e) : Gi(r, "add", t, e), this
}

function Mp(t) {
    const e = At(this),
        {
            has: r,
            get: n
        } = Jf(e);
    let i = r.call(e, t);
    i || (t = At(t), i = r.call(e, t)), n && n.call(e, t);
    const s = e.delete(t);
    return i && Gi(e, "delete", t, void 0), s
}

function Np() {
    const t = At(this),
        e = t.size !== 0,
        r = t.clear();
    return e && Gi(t, "clear", void 0, void 0), r
}

function eu(t, e) {
    return function(n, i) {
        const s = this,
            o = s.__v_raw,
            f = At(o),
            l = e ? S0 : t ? k0 : Aa;
        return !t && qr(f, "iterate", Fs), o.forEach((d, p) => n.call(i, l(d), l(p), s))
    }
}

function tu(t, e, r) {
    return function(...n) {
        const i = this.__v_raw,
            s = At(i),
            o = go(s),
            f = t === "entries" || t === Symbol.iterator && o,
            l = t === "keys" && o,
            d = i[t](...n),
            p = r ? S0 : e ? k0 : Aa;
        return !e && qr(s, "iterate", l ? A0 : Fs), {
            next() {
                const {
                    value: A,
                    done: T
                } = d.next();
                return T ? {
                    value: A,
                    done: T
                } : {
                    value: f ? [p(A[0]), p(A[1])] : p(A),
                    done: T
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function as(t) {
    return function(...e) {
        return t === "delete" ? !1 : this
    }
}

function W2() {
    const t = {
            get(s) {
                return Zf(this, s)
            },
            get size() {
                return Qf(this)
            },
            has: Yf,
            add: _p,
            set: Tp,
            delete: Mp,
            clear: Np,
            forEach: eu(!1, !1)
        },
        e = {
            get(s) {
                return Zf(this, s, !1, !0)
            },
            get size() {
                return Qf(this)
            },
            has: Yf,
            add: _p,
            set: Tp,
            delete: Mp,
            clear: Np,
            forEach: eu(!1, !0)
        },
        r = {
            get(s) {
                return Zf(this, s, !0)
            },
            get size() {
                return Qf(this, !0)
            },
            has(s) {
                return Yf.call(this, s, !0)
            },
            add: as("add"),
            set: as("set"),
            delete: as("delete"),
            clear: as("clear"),
            forEach: eu(!0, !1)
        },
        n = {
            get(s) {
                return Zf(this, s, !0, !0)
            },
            get size() {
                return Qf(this, !0)
            },
            has(s) {
                return Yf.call(this, s, !0)
            },
            add: as("add"),
            set: as("set"),
            delete: as("delete"),
            clear: as("clear"),
            forEach: eu(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = tu(s, !1, !1), r[s] = tu(s, !0, !1), e[s] = tu(s, !1, !0), n[s] = tu(s, !0, !0)
    }), [t, r, e, n]
}
const [V2, K2, X2, J2] = W2();

function P0(t, e) {
    const r = e ? t ? J2 : X2 : t ? K2 : V2;
    return (n, i, s) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? n : Reflect.get(yt(r, i) && i in n ? r : n, i, s)
}
const Z2 = {
        get: P0(!1, !1)
    },
    Y2 = {
        get: P0(!1, !0)
    },
    Q2 = {
        get: P0(!0, !1)
    },
    Sp = new WeakMap,
    Pp = new WeakMap,
    Ip = new WeakMap,
    ew = new WeakMap;

function tw(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function rw(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : tw(T2(t))
}

function wo(t) {
    return t && t.__v_isReadonly ? t : I0(t, !1, Ap, Z2, Sp)
}

function nw(t) {
    return I0(t, !1, j2, Y2, Pp)
}

function Rp(t) {
    return I0(t, !0, q2, Q2, Ip)
}

function I0(t, e, r, n, i) {
    if (!Vt(t) || t.__v_raw && !(e && t.__v_isReactive)) return t;
    const s = i.get(t);
    if (s) return s;
    const o = rw(t);
    if (o === 0) return t;
    const f = new Proxy(t, o === 2 ? n : r);
    return i.set(t, f), f
}

function fs(t) {
    return R0(t) ? fs(t.__v_raw) : !!(t && t.__v_isReactive)
}

function R0(t) {
    return !!(t && t.__v_isReadonly)
}

function kp(t) {
    return fs(t) || R0(t)
}

function At(t) {
    const e = t && t.__v_raw;
    return e ? At(e) : t
}

function Op(t) {
    return Vf(t, "__v_skip", !0), t
}
const Aa = t => Vt(t) ? wo(t) : t,
    k0 = t => Vt(t) ? Rp(t) : t;

function Cp(t) {
    xp() && (t = At(t), t.dep || (t.dep = v0()), bp(t.dep))
}

function Fp(t, e) {
    t = At(t), t.dep && M0(t.dep)
}

function Ut(t) {
    return Boolean(t && t.__v_isRef === !0)
}

function Zt(t) {
    return Dp(t, !1)
}

function iw(t) {
    return Dp(t, !0)
}

function Dp(t, e) {
    return Ut(t) ? t : new sw(t, e)
}
class sw {
    constructor(e, r) {
        this._shallow = r, this.dep = void 0, this.__v_isRef = !0, this._rawValue = r ? e : At(e), this._value = r ? e : Aa(e)
    }
    get value() {
        return Cp(this), this._value
    }
    set value(e) {
        e = this._shallow ? e : At(e), va(e, this._rawValue) && (this._rawValue = e, this._value = this._shallow ? e : Aa(e), Fp(this))
    }
}

function Us(t) {
    return Ut(t) ? t.value : t
}
const ow = {
    get: (t, e, r) => Us(Reflect.get(t, e, r)),
    set: (t, e, r, n) => {
        const i = t[e];
        return Ut(i) && !Ut(r) ? (i.value = r, !0) : Reflect.set(t, e, r, n)
    }
};

function Up(t) {
    return fs(t) ? t : new Proxy(t, ow)
}

function ES(t) {
    const e = qe(t) ? new Array(t.length) : {};
    for (const r in t) e[r] = fw(t, r);
    return e
}
class aw {
    constructor(e, r, n) {
        this._object = e, this._key = r, this._defaultValue = n, this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
}

function fw(t, e, r) {
    const n = t[e];
    return Ut(n) ? n : new aw(t, e, r)
}
class uw {
    constructor(e, r, n) {
        this._setter = r, this.dep = void 0, this._dirty = !0, this.__v_isRef = !0, this.effect = new _0(e, () => {
            this._dirty || (this._dirty = !0, Fp(this))
        }), this.__v_isReadonly = n
    }
    get value() {
        const e = At(this);
        return Cp(e), e._dirty && (e._dirty = !1, e._value = e.effect.run()), e._value
    }
    set value(e) {
        this._setter(e)
    }
}

function br(t, e) {
    let r, n;
    const i = Qe(t);
    return i ? (r = t, n = Un) : (r = t.get, n = t.set), new uw(r, n, i || !n)
}
Promise.resolve();

function lw(t, e, ...r) {
    const n = t.vnode.props || Pt;
    let i = r;
    const s = e.startsWith("update:"),
        o = s && e.slice(7);
    if (o && o in n) {
        const p = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: A,
                trim: T
            } = n[p] || Pt;
        T ? i = r.map(N => N.trim()) : A && (i = r.map(Kf))
    }
    let f, l = n[f = b0(e)] || n[f = b0(ai(e))];
    !l && s && (l = n[f = b0(xo(e))]), l && nn(l, t, 6, i);
    const d = n[f + "Once"];
    if (d) {
        if (!t.emitted) t.emitted = {};
        else if (t.emitted[f]) return;
        t.emitted[f] = !0, nn(d, t, 6, i)
    }
}

function Lp(t, e, r = !1) {
    const n = e.emitsCache,
        i = n.get(t);
    if (i !== void 0) return i;
    const s = t.emits;
    let o = {},
        f = !1;
    if (!Qe(t)) {
        const l = d => {
            const p = Lp(d, e, !0);
            p && (f = !0, fr(o, p))
        };
        !r && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l)
    }
    return !s && !f ? (n.set(t, null), null) : (qe(s) ? s.forEach(l => o[l] = null) : fr(o, s), n.set(t, o), o)
}

function O0(t, e) {
    return !t || !Gf(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), yt(t, e[0].toLowerCase() + e.slice(1)) || yt(t, xo(e)) || yt(t, e))
}
let jr = null,
    Bp = null;

function ru(t) {
    const e = jr;
    return jr = t, Bp = t && t.type.__scopeId || null, e
}

function $p(t, e = jr, r) {
    if (!e || t._n) return t;
    const n = (...i) => {
        n._d && hm(-1);
        const s = ru(e),
            o = t(...i);
        return ru(s), n._d && hm(1), o
    };
    return n._n = !0, n._c = !0, n._d = !0, n
}

function C0(t) {
    const {
        type: e,
        vnode: r,
        proxy: n,
        withProxy: i,
        props: s,
        propsOptions: [o],
        slots: f,
        attrs: l,
        emit: d,
        render: p,
        renderCache: A,
        data: T,
        setupState: N,
        ctx: P,
        inheritAttrs: C
    } = t;
    let S, k;
    const I = ru(t);
    try {
        if (r.shapeFlag & 4) {
            const M = i || n;
            S = ui(p.call(M, M, A, s, N, T, P)), k = l
        } else {
            const M = e;
            S = ui(M.length > 1 ? M(s, {
                attrs: l,
                slots: f,
                emit: d
            }) : M(s, null)), k = e.props ? l : cw(l)
        }
    } catch (M) {
        _a.length = 0, du(M, t, 1), S = _t(Ln)
    }
    let U = S;
    if (k && C !== !1) {
        const M = Object.keys(k),
            {
                shapeFlag: F
            } = U;
        M.length && F & (1 | 6) && (o && M.some(m0) && (k = hw(k, o)), U = _o(U, k))
    }
    return r.dirs && (U.dirs = U.dirs ? U.dirs.concat(r.dirs) : r.dirs), r.transition && (U.transition = r.transition), S = U, ru(I), S
}
const cw = t => {
        let e;
        for (const r in t)(r === "class" || r === "style" || Gf(r)) && ((e || (e = {}))[r] = t[r]);
        return e
    },
    hw = (t, e) => {
        const r = {};
        for (const n in t)(!m0(n) || !(n.slice(9) in e)) && (r[n] = t[n]);
        return r
    };

function dw(t, e, r) {
    const {
        props: n,
        children: i,
        component: s
    } = t, {
        props: o,
        children: f,
        patchFlag: l
    } = e, d = s.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (r && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return n ? Gp(n, o, d) : !!o;
        if (l & 8) {
            const p = e.dynamicProps;
            for (let A = 0; A < p.length; A++) {
                const T = p[A];
                if (o[T] !== n[T] && !O0(d, T)) return !0
            }
        }
    } else return (i || f) && (!f || !f.$stable) ? !0 : n === o ? !1 : n ? o ? Gp(n, o, d) : !0 : !!o;
    return !1
}

function Gp(t, e, r) {
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length) return !0;
    for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (e[s] !== t[s] && !O0(r, s)) return !0
    }
    return !1
}

function pw({
    vnode: t,
    parent: e
}, r) {
    for (; e && e.subTree === t;)(t = e.vnode).el = r, e = e.parent
}
const mw = t => t.__isSuspense;

function yw(t, e) {
    e && e.pendingBranch ? qe(t) ? e.effects.push(...t) : e.effects.push(t) : p6(t)
}

function nu(t, e) {
    if (er) {
        let r = er.provides;
        const n = er.parent && er.parent.provides;
        n === r && (r = er.provides = Object.create(n)), r[t] = e
    }
}

function fi(t, e, r = !1) {
    const n = er || jr;
    if (n) {
        const i = n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides;
        if (i && t in i) return i[t];
        if (arguments.length > 1) return r && Qe(e) ? e.call(n.proxy) : e
    }
}

function gw() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return us(() => {
        t.isMounted = !0
    }), Vp(() => {
        t.isUnmounting = !0
    }), t
}
const tn = [Function, Array],
    xw = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: tn,
            onEnter: tn,
            onAfterEnter: tn,
            onEnterCancelled: tn,
            onBeforeLeave: tn,
            onLeave: tn,
            onAfterLeave: tn,
            onLeaveCancelled: tn,
            onBeforeAppear: tn,
            onAppear: tn,
            onAfterAppear: tn,
            onAppearCancelled: tn
        },
        setup(t, {
            slots: e
        }) {
            const r = gm(),
                n = gw();
            let i;
            return () => {
                const s = e.default && jp(e.default(), !0);
                if (!s || !s.length) return;
                const o = At(t),
                    {
                        mode: f
                    } = o,
                    l = s[0];
                if (n.isLeaving) return D0(l);
                const d = qp(l);
                if (!d) return D0(l);
                const p = F0(d, o, n, r);
                U0(d, p);
                const A = r.subTree,
                    T = A && qp(A);
                let N = !1;
                const {
                    getTransitionKey: P
                } = d.type;
                if (P) {
                    const C = P();
                    i === void 0 ? i = C : C !== i && (i = C, N = !0)
                }
                if (T && T.type !== Ln && (!zs(d, T) || N)) {
                    const C = F0(T, o, n, r);
                    if (U0(T, C), f === "out-in") return n.isLeaving = !0, C.afterLeave = () => {
                        n.isLeaving = !1, r.update()
                    }, D0(l);
                    f === "in-out" && d.type !== Ln && (C.delayLeave = (S, k, I) => {
                        const U = Hp(n, T);
                        U[String(T.key)] = T, S._leaveCb = () => {
                            k(), S._leaveCb = void 0, delete p.delayedLeave
                        }, p.delayedLeave = I
                    })
                }
                return l
            }
        }
    },
    zp = xw;

function Hp(t, e) {
    const {
        leavingVNodes: r
    } = t;
    let n = r.get(e.type);
    return n || (n = Object.create(null), r.set(e.type, n)), n
}

function F0(t, e, r, n) {
    const {
        appear: i,
        mode: s,
        persisted: o = !1,
        onBeforeEnter: f,
        onEnter: l,
        onAfterEnter: d,
        onEnterCancelled: p,
        onBeforeLeave: A,
        onLeave: T,
        onAfterLeave: N,
        onLeaveCancelled: P,
        onBeforeAppear: C,
        onAppear: S,
        onAfterAppear: k,
        onAppearCancelled: I
    } = e, U = String(t.key), M = Hp(r, t), F = (q, V) => {
        q && nn(q, n, 9, V)
    }, D = {
        mode: s,
        persisted: o,
        beforeEnter(q) {
            let V = f;
            if (!r.isMounted)
                if (i) V = C || f;
                else return;
            q._leaveCb && q._leaveCb(!0);
            const Q = M[U];
            Q && zs(t, Q) && Q.el._leaveCb && Q.el._leaveCb(), F(V, [q])
        },
        enter(q) {
            let V = l,
                Q = d,
                ce = p;
            if (!r.isMounted)
                if (i) V = S || l, Q = k || d, ce = I || p;
                else return;
            let O = !1;
            const w = q._enterCb = m => {
                O || (O = !0, m ? F(ce, [q]) : F(Q, [q]), D.delayedLeave && D.delayedLeave(), q._enterCb = void 0)
            };
            V ? (V(q, w), V.length <= 1 && w()) : w()
        },
        leave(q, V) {
            const Q = String(t.key);
            if (q._enterCb && q._enterCb(!0), r.isUnmounting) return V();
            F(A, [q]);
            let ce = !1;
            const O = q._leaveCb = w => {
                ce || (ce = !0, V(), w ? F(P, [q]) : F(N, [q]), q._leaveCb = void 0, M[Q] === t && delete M[Q])
            };
            M[Q] = t, T ? (T(q, O), T.length <= 1 && O()) : O()
        },
        clone(q) {
            return F0(q, e, r, n)
        }
    };
    return D
}

function D0(t) {
    if (iu(t)) return t = _o(t), t.children = null, t
}

function qp(t) {
    return iu(t) ? t.children ? t.children[0] : void 0 : t
}

function U0(t, e) {
    t.shapeFlag & 6 && t.component ? U0(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}

function jp(t, e = !1) {
    let r = [],
        n = 0;
    for (let i = 0; i < t.length; i++) {
        const s = t[i];
        s.type === rn ? (s.patchFlag & 128 && n++, r = r.concat(jp(s.children, e))) : (e || s.type !== Ln) && r.push(s)
    }
    if (n > 1)
        for (let i = 0; i < r.length; i++) r[i].patchFlag = -2;
    return r
}

function Eo(t) {
    return Qe(t) ? {
        setup: t,
        name: t.name
    } : t
}
const L0 = t => !!t.type.__asyncLoader,
    iu = t => t.type.__isKeepAlive;

function bw(t, e) {
    Wp(t, "a", e)
}

function vw(t, e) {
    Wp(t, "da", e)
}

function Wp(t, e, r = er) {
    const n = t.__wdc || (t.__wdc = () => {
        let i = r;
        for (; i;) {
            if (i.isDeactivated) return;
            i = i.parent
        }
        return t()
    });
    if (su(e, n, r), r) {
        let i = r.parent;
        for (; i && i.parent;) iu(i.parent.vnode) && ww(n, e, r, i), i = i.parent
    }
}

function ww(t, e, r, n) {
    const i = su(e, t, n, !0);
    Ao(() => {
        y0(n[e], i)
    }, r)
}

function su(t, e, r = er, n = !1) {
    if (r) {
        const i = r[t] || (r[t] = []),
            s = e.__weh || (e.__weh = (...o) => {
                if (r.isUnmounted) return;
                vo(), To(r);
                const f = nn(e, r, t, o);
                return qs(), Ds(), f
            });
        return n ? i.unshift(s) : i.push(s), s
    }
}
const zi = t => (e, r = er) => (!hu || t === "sp") && su(t, e, r),
    Ew = zi("bm"),
    us = zi("m"),
    Aw = zi("bu"),
    _w = zi("u"),
    Vp = zi("bum"),
    Ao = zi("um"),
    Tw = zi("sp"),
    Mw = zi("rtg"),
    Nw = zi("rtc");

function Sw(t, e = er) {
    su("ec", t, e)
}
let B0 = !0;

function Pw(t) {
    const e = Jp(t),
        r = t.proxy,
        n = t.ctx;
    B0 = !1, e.beforeCreate && Kp(e.beforeCreate, t, "bc");
    const {
        data: i,
        computed: s,
        methods: o,
        watch: f,
        provide: l,
        inject: d,
        created: p,
        beforeMount: A,
        mounted: T,
        beforeUpdate: N,
        updated: P,
        activated: C,
        deactivated: S,
        beforeDestroy: k,
        beforeUnmount: I,
        destroyed: U,
        unmounted: M,
        render: F,
        renderTracked: D,
        renderTriggered: q,
        errorCaptured: V,
        serverPrefetch: Q,
        expose: ce,
        inheritAttrs: O,
        components: w,
        directives: m,
        filters: a
    } = e;
    if (d && Iw(d, n, null, t.appContext.config.unwrapInjectedRef), o)
        for (const v in o) {
            const x = o[v];
            Qe(x) && (n[v] = x.bind(r))
        }
    if (i) {
        const v = i.call(r, r);
        Vt(v) && (t.data = wo(v))
    }
    if (B0 = !0, s)
        for (const v in s) {
            const x = s[v],
                b = Qe(x) ? x.bind(r, r) : Qe(x.get) ? x.get.bind(r, r) : Un,
                y = !Qe(x) && Qe(x.set) ? x.set.bind(r) : Un,
                h = br({
                    get: b,
                    set: y
                });
            Object.defineProperty(n, v, {
                enumerable: !0,
                configurable: !0,
                get: () => h.value,
                set: u => h.value = u
            })
        }
    if (f)
        for (const v in f) Xp(f[v], n, r, v);
    if (l) {
        const v = Qe(l) ? l.call(r) : l;
        Reflect.ownKeys(v).forEach(x => {
            nu(x, v[x])
        })
    }
    p && Kp(p, t, "c");

    function g(v, x) {
        qe(x) ? x.forEach(b => v(b.bind(r))) : x && v(x.bind(r))
    }
    if (g(Ew, A), g(us, T), g(Aw, N), g(_w, P), g(bw, C), g(vw, S), g(Sw, V), g(Nw, D), g(Mw, q), g(Vp, I), g(Ao, M), g(Tw, Q), qe(ce))
        if (ce.length) {
            const v = t.exposed || (t.exposed = {});
            ce.forEach(x => {
                Object.defineProperty(v, x, {
                    get: () => r[x],
                    set: b => r[x] = b
                })
            })
        } else t.exposed || (t.exposed = {});
    F && t.render === Un && (t.render = F), O != null && (t.inheritAttrs = O), w && (t.components = w), m && (t.directives = m)
}

function Iw(t, e, r = Un, n = !1) {
    qe(t) && (t = $0(t));
    for (const i in t) {
        const s = t[i];
        let o;
        Vt(s) ? "default" in s ? o = fi(s.from || i, s.default, !0) : o = fi(s.from || i) : o = fi(s), Ut(o) && n ? Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: f => o.value = f
        }) : e[i] = o
    }
}

function Kp(t, e, r) {
    nn(qe(t) ? t.map(n => n.bind(e.proxy)) : t.bind(e.proxy), e, r)
}

function Xp(t, e, r, n) {
    const i = n.includes(".") ? Pm(r, n) : () => r[n];
    if (ur(t)) {
        const s = e[t];
        Qe(s) && ds(i, s)
    } else if (Qe(t)) ds(i, t.bind(r));
    else if (Vt(t))
        if (qe(t)) t.forEach(s => Xp(s, e, r, n));
        else {
            const s = Qe(t.handler) ? t.handler.bind(r) : e[t.handler];
            Qe(s) && ds(i, s, t)
        }
}

function Jp(t) {
    const e = t.type,
        {
            mixins: r,
            extends: n
        } = e,
        {
            mixins: i,
            optionsCache: s,
            config: {
                optionMergeStrategies: o
            }
        } = t.appContext,
        f = s.get(e);
    let l;
    return f ? l = f : !i.length && !r && !n ? l = e : (l = {}, i.length && i.forEach(d => ou(l, d, o, !0)), ou(l, e, o)), s.set(e, l), l
}

function ou(t, e, r, n = !1) {
    const {
        mixins: i,
        extends: s
    } = e;
    s && ou(t, s, r, !0), i && i.forEach(o => ou(t, o, r, !0));
    for (const o in e)
        if (!(n && o === "expose")) {
            const f = Rw[o] || r && r[o];
            t[o] = f ? f(t[o], e[o]) : e[o]
        }
    return t
}
const Rw = {
    data: Zp,
    props: Ls,
    emits: Ls,
    methods: Ls,
    computed: Ls,
    beforeCreate: Mr,
    created: Mr,
    beforeMount: Mr,
    mounted: Mr,
    beforeUpdate: Mr,
    updated: Mr,
    beforeDestroy: Mr,
    beforeUnmount: Mr,
    destroyed: Mr,
    unmounted: Mr,
    activated: Mr,
    deactivated: Mr,
    errorCaptured: Mr,
    serverPrefetch: Mr,
    components: Ls,
    directives: Ls,
    watch: Ow,
    provide: Zp,
    inject: kw
};

function Zp(t, e) {
    return e ? t ? function() {
        return fr(Qe(t) ? t.call(this, this) : t, Qe(e) ? e.call(this, this) : e)
    } : e : t
}

function kw(t, e) {
    return Ls($0(t), $0(e))
}

function $0(t) {
    if (qe(t)) {
        const e = {};
        for (let r = 0; r < t.length; r++) e[t[r]] = t[r];
        return e
    }
    return t
}

function Mr(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}

function Ls(t, e) {
    return t ? fr(fr(Object.create(null), t), e) : e
}

function Ow(t, e) {
    if (!t) return e;
    if (!e) return t;
    const r = fr(Object.create(null), t);
    for (const n in e) r[n] = Mr(t[n], e[n]);
    return r
}

function Cw(t, e, r, n = !1) {
    const i = {},
        s = {};
    Vf(s, uu, 1), t.propsDefaults = Object.create(null), Yp(t, e, i, s);
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
    r ? t.props = n ? i : nw(i) : t.type.props ? t.props = i : t.props = s, t.attrs = s
}

function Fw(t, e, r, n) {
    const {
        props: i,
        attrs: s,
        vnode: {
            patchFlag: o
        }
    } = t, f = At(i), [l] = t.propsOptions;
    let d = !1;
    if ((n || o > 0) && !(o & 16)) {
        if (o & 8) {
            const p = t.vnode.dynamicProps;
            for (let A = 0; A < p.length; A++) {
                let T = p[A];
                const N = e[T];
                if (l)
                    if (yt(s, T)) N !== s[T] && (s[T] = N, d = !0);
                    else {
                        const P = ai(T);
                        i[P] = G0(l, f, P, N, t, !1)
                    }
                else N !== s[T] && (s[T] = N, d = !0)
            }
        }
    } else {
        Yp(t, e, i, s) && (d = !0);
        let p;
        for (const A in f)(!e || !yt(e, A) && ((p = xo(A)) === A || !yt(e, p))) && (l ? r && (r[A] !== void 0 || r[p] !== void 0) && (i[A] = G0(l, f, A, void 0, t, !0)) : delete i[A]);
        if (s !== f)
            for (const A in s)(!e || !yt(e, A)) && (delete s[A], d = !0)
    }
    d && Gi(t, "set", "$attrs")
}

function Yp(t, e, r, n) {
    const [i, s] = t.propsOptions;
    let o = !1,
        f;
    if (e)
        for (let l in e) {
            if (Hf(l)) continue;
            const d = e[l];
            let p;
            i && yt(i, p = ai(l)) ? !s || !s.includes(p) ? r[p] = d : (f || (f = {}))[p] = d : O0(t.emitsOptions, l) || (!(l in n) || d !== n[l]) && (n[l] = d, o = !0)
        }
    if (s) {
        const l = At(r),
            d = f || Pt;
        for (let p = 0; p < s.length; p++) {
            const A = s[p];
            r[A] = G0(i, l, A, d[A], t, !yt(d, A))
        }
    }
    return o
}

function G0(t, e, r, n, i, s) {
    const o = t[r];
    if (o != null) {
        const f = yt(o, "default");
        if (f && n === void 0) {
            const l = o.default;
            if (o.type !== Function && Qe(l)) {
                const {
                    propsDefaults: d
                } = i;
                r in d ? n = d[r] : (To(i), n = d[r] = l.call(null, e), qs())
            } else n = l
        }
        o[0] && (s && !f ? n = !1 : o[1] && (n === "" || n === xo(r)) && (n = !0))
    }
    return n
}

function Qp(t, e, r = !1) {
    const n = e.propsCache,
        i = n.get(t);
    if (i) return i;
    const s = t.props,
        o = {},
        f = [];
    let l = !1;
    if (!Qe(t)) {
        const p = A => {
            l = !0;
            const [T, N] = Qp(A, e, !0);
            fr(o, T), N && f.push(...N)
        };
        !r && e.mixins.length && e.mixins.forEach(p), t.extends && p(t.extends), t.mixins && t.mixins.forEach(p)
    }
    if (!s && !l) return n.set(t, yo), yo;
    if (qe(s))
        for (let p = 0; p < s.length; p++) {
            const A = ai(s[p]);
            em(A) && (o[A] = Pt)
        } else if (s)
            for (const p in s) {
                const A = ai(p);
                if (em(A)) {
                    const T = s[p],
                        N = o[A] = qe(T) || Qe(T) ? {
                            type: T
                        } : T;
                    if (N) {
                        const P = nm(Boolean, N.type),
                            C = nm(String, N.type);
                        N[0] = P > -1, N[1] = C < 0 || P < C, (P > -1 || yt(N, "default")) && f.push(A)
                    }
                }
            }
    const d = [o, f];
    return n.set(t, d), d
}

function em(t) {
    return t[0] !== "$"
}

function tm(t) {
    const e = t && t.toString().match(/^\s*function (\w+)/);
    return e ? e[1] : t === null ? "null" : ""
}

function rm(t, e) {
    return tm(t) === tm(e)
}

function nm(t, e) {
    return qe(e) ? e.findIndex(r => rm(r, t)) : Qe(e) && rm(e, t) ? 0 : -1
}
const im = t => t[0] === "_" || t === "$stable",
    z0 = t => qe(t) ? t.map(ui) : [ui(t)],
    Dw = (t, e, r) => {
        const n = $p((...i) => z0(e(...i)), r);
        return n._c = !1, n
    },
    sm = (t, e, r) => {
        const n = t._ctx;
        for (const i in t) {
            if (im(i)) continue;
            const s = t[i];
            if (Qe(s)) e[i] = Dw(i, s, n);
            else if (s != null) {
                const o = z0(s);
                e[i] = () => o
            }
        }
    },
    om = (t, e) => {
        const r = z0(e);
        t.slots.default = () => r
    },
    Uw = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const r = e._;
            r ? (t.slots = At(e), Vf(e, "_", r)) : sm(e, t.slots = {})
        } else t.slots = {}, e && om(t, e);
        Vf(t.slots, uu, 1)
    },
    Lw = (t, e, r) => {
        const {
            vnode: n,
            slots: i
        } = t;
        let s = !0,
            o = Pt;
        if (n.shapeFlag & 32) {
            const f = e._;
            f ? r && f === 1 ? s = !1 : (fr(i, e), !r && f === 1 && delete i._) : (s = !e.$stable, sm(e, i)), o = e
        } else e && (om(t, e), o = {
            default: 1
        });
        if (s)
            for (const f in i) !im(f) && !(f in o) && delete i[f]
    };

function AS(t, e) {
    const r = jr;
    if (r === null) return t;
    const n = r.proxy,
        i = t.dirs || (t.dirs = []);
    for (let s = 0; s < e.length; s++) {
        let [o, f, l, d = Pt] = e[s];
        Qe(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && js(f), i.push({
            dir: o,
            instance: n,
            value: f,
            oldValue: void 0,
            arg: l,
            modifiers: d
        })
    }
    return t
}

function Bs(t, e, r, n) {
    const i = t.dirs,
        s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
        const f = i[o];
        s && (f.oldValue = s[o].value);
        let l = f.dir[n];
        l && (vo(), nn(l, r, 8, [t.el, f, t, e]), Ds())
    }
}

function am() {
    return {
        app: null,
        config: {
            isNativeTag: E2,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let Bw = 0;

function $w(t, e) {
    return function(n, i = null) {
        i != null && !Vt(i) && (i = null);
        const s = am(),
            o = new Set;
        let f = !1;
        const l = s.app = {
            _uid: Bw++,
            _component: n,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: g6,
            get config() {
                return s.config
            },
            set config(d) {},
            use(d, ...p) {
                return o.has(d) || (d && Qe(d.install) ? (o.add(d), d.install(l, ...p)) : Qe(d) && (o.add(d), d(l, ...p))), l
            },
            mixin(d) {
                return s.mixins.includes(d) || s.mixins.push(d), l
            },
            component(d, p) {
                return p ? (s.components[d] = p, l) : s.components[d]
            },
            directive(d, p) {
                return p ? (s.directives[d] = p, l) : s.directives[d]
            },
            mount(d, p, A) {
                if (!f) {
                    const T = _t(n, i);
                    return T.appContext = s, p && e ? e(T, d) : t(T, d, A), f = !0, l._container = d, d.__vue_app__ = l, V0(T.component) || T.component.proxy
                }
            },
            unmount() {
                f && (t(null, l._container), delete l._container.__vue_app__)
            },
            provide(d, p) {
                return s.provides[d] = p, l
            }
        };
        return l
    }
}

function H0(t, e, r, n, i = !1) {
    if (qe(t)) {
        t.forEach((T, N) => H0(T, e && (qe(e) ? e[N] : e), r, n, i));
        return
    }
    if (L0(n) && !i) return;
    const s = n.shapeFlag & 4 ? V0(n.component) || n.component.proxy : n.el,
        o = i ? null : s,
        {
            i: f,
            r: l
        } = t,
        d = e && e.r,
        p = f.refs === Pt ? f.refs = {} : f.refs,
        A = f.setupState;
    if (d != null && d !== l && (ur(d) ? (p[d] = null, yt(A, d) && (A[d] = null)) : Ut(d) && (d.value = null)), Qe(l)) cs(l, f, 12, [o, p]);
    else {
        const T = ur(l),
            N = Ut(l);
        if (T || N) {
            const P = () => {
                if (t.f) {
                    const C = T ? p[l] : l.value;
                    i ? qe(C) && y0(C, s) : qe(C) ? C.includes(s) || C.push(s) : T ? p[l] = [s] : (l.value = [s], t.k && (p[t.k] = l.value))
                } else T ? (p[l] = o, yt(A, l) && (A[l] = o)) : Ut(l) && (l.value = o, t.k && (p[t.k] = o))
            };
            o ? (P.id = -1, kr(P, r)) : P()
        }
    }
}
const kr = yw;

function Gw(t) {
    return zw(t)
}

function zw(t, e) {
    const r = S2();
    r.__VUE__ = !0;
    const {
        insert: n,
        remove: i,
        patchProp: s,
        createElement: o,
        createText: f,
        createComment: l,
        setText: d,
        setElementText: p,
        parentNode: A,
        nextSibling: T,
        setScopeId: N = Un,
        cloneNode: P,
        insertStaticContent: C
    } = t, S = (B, $, H, ne = null, J = null, Y = null, ue = !1, te = null, Z = !!$.dynamicChildren) => {
        if (B === $) return;
        B && !zs(B, $) && (ne = z(B), _(B, J, Y, !0), B = null), $.patchFlag === -2 && (Z = !1, $.dynamicChildren = null);
        const {
            type: se,
            ref: fe,
            shapeFlag: ie
        } = $;
        switch (se) {
            case q0:
                k(B, $, H, ne);
                break;
            case Ln:
                I(B, $, H, ne);
                break;
            case au:
                B == null && U($, H, ne, ue);
                break;
            case rn:
                m(B, $, H, ne, J, Y, ue, te, Z);
                break;
            default:
                ie & 1 ? D(B, $, H, ne, J, Y, ue, te, Z) : ie & 6 ? a(B, $, H, ne, J, Y, ue, te, Z) : (ie & 64 || ie & 128) && se.process(B, $, H, ne, J, Y, ue, te, Z, re)
        }
        fe != null && J && H0(fe, B && B.ref, Y, $ || B, !$)
    }, k = (B, $, H, ne) => {
        if (B == null) n($.el = f($.children), H, ne);
        else {
            const J = $.el = B.el;
            $.children !== B.children && d(J, $.children)
        }
    }, I = (B, $, H, ne) => {
        B == null ? n($.el = l($.children || ""), H, ne) : $.el = B.el
    }, U = (B, $, H, ne) => {
        [B.el, B.anchor] = C(B.children, $, H, ne)
    }, M = ({
        el: B,
        anchor: $
    }, H, ne) => {
        let J;
        for (; B && B !== $;) J = T(B), n(B, H, ne), B = J;
        n($, H, ne)
    }, F = ({
        el: B,
        anchor: $
    }) => {
        let H;
        for (; B && B !== $;) H = T(B), i(B), B = H;
        i($)
    }, D = (B, $, H, ne, J, Y, ue, te, Z) => {
        ue = ue || $.type === "svg", B == null ? q($, H, ne, J, Y, ue, te, Z) : ce(B, $, J, Y, ue, te, Z)
    }, q = (B, $, H, ne, J, Y, ue, te) => {
        let Z, se;
        const {
            type: fe,
            props: ie,
            shapeFlag: me,
            transition: he,
            patchFlag: le,
            dirs: Pe
        } = B;
        if (B.el && P !== void 0 && le === -1) Z = B.el = P(B.el);
        else {
            if (Z = B.el = o(B.type, Y, ie && ie.is, ie), me & 8 ? p(Z, B.children) : me & 16 && Q(B.children, Z, null, ne, J, Y && fe !== "foreignObject", ue, te), Pe && Bs(B, null, ne, "created"), ie) {
                for (const de in ie) de !== "value" && !Hf(de) && s(Z, de, null, ie[de], Y, B.children, ne, J, G);
                "value" in ie && s(Z, "value", null, ie.value), (se = ie.onVnodeBeforeMount) && li(se, ne, B)
            }
            V(Z, B, B.scopeId, ue, ne)
        }
        Pe && Bs(B, null, ne, "beforeMount");
        const xe = (!J || J && !J.pendingBranch) && he && !he.persisted;
        xe && he.beforeEnter(Z), n(Z, $, H), ((se = ie && ie.onVnodeMounted) || xe || Pe) && kr(() => {
            se && li(se, ne, B), xe && he.enter(Z), Pe && Bs(B, null, ne, "mounted")
        }, J)
    }, V = (B, $, H, ne, J) => {
        if (H && N(B, H), ne)
            for (let Y = 0; Y < ne.length; Y++) N(B, ne[Y]);
        if (J) {
            let Y = J.subTree;
            if ($ === Y) {
                const ue = J.vnode;
                V(B, ue, ue.scopeId, ue.slotScopeIds, J.parent)
            }
        }
    }, Q = (B, $, H, ne, J, Y, ue, te, Z = 0) => {
        for (let se = Z; se < B.length; se++) {
            const fe = B[se] = te ? ls(B[se]) : ui(B[se]);
            S(null, fe, $, H, ne, J, Y, ue, te)
        }
    }, ce = (B, $, H, ne, J, Y, ue) => {
        const te = $.el = B.el;
        let {
            patchFlag: Z,
            dynamicChildren: se,
            dirs: fe
        } = $;
        Z |= B.patchFlag & 16;
        const ie = B.props || Pt,
            me = $.props || Pt;
        let he;
        H && $s(H, !1), (he = me.onVnodeBeforeUpdate) && li(he, H, $, B), fe && Bs($, B, H, "beforeUpdate"), H && $s(H, !0);
        const le = J && $.type !== "foreignObject";
        if (se ? O(B.dynamicChildren, se, te, H, ne, le, Y) : ue || b(B, $, te, null, H, ne, le, Y, !1), Z > 0) {
            if (Z & 16) w(te, $, ie, me, H, ne, J);
            else if (Z & 2 && ie.class !== me.class && s(te, "class", null, me.class, J), Z & 4 && s(te, "style", ie.style, me.style, J), Z & 8) {
                const Pe = $.dynamicProps;
                for (let xe = 0; xe < Pe.length; xe++) {
                    const de = Pe[xe],
                        je = ie[de],
                        Ie = me[de];
                    (Ie !== je || de === "value") && s(te, de, je, Ie, J, B.children, H, ne, G)
                }
            }
            Z & 1 && B.children !== $.children && p(te, $.children)
        } else !ue && se == null && w(te, $, ie, me, H, ne, J);
        ((he = me.onVnodeUpdated) || fe) && kr(() => {
            he && li(he, H, $, B), fe && Bs($, B, H, "updated")
        }, ne)
    }, O = (B, $, H, ne, J, Y, ue) => {
        for (let te = 0; te < $.length; te++) {
            const Z = B[te],
                se = $[te],
                fe = Z.el && (Z.type === rn || !zs(Z, se) || Z.shapeFlag & (6 | 64)) ? A(Z.el) : H;
            S(Z, se, fe, null, ne, J, Y, ue, !0)
        }
    }, w = (B, $, H, ne, J, Y, ue) => {
        if (H !== ne) {
            for (const te in ne) {
                if (Hf(te)) continue;
                const Z = ne[te],
                    se = H[te];
                Z !== se && te !== "value" && s(B, te, se, Z, ue, $.children, J, Y, G)
            }
            if (H !== Pt)
                for (const te in H) !Hf(te) && !(te in ne) && s(B, te, H[te], null, ue, $.children, J, Y, G);
            "value" in ne && s(B, "value", H.value, ne.value)
        }
    }, m = (B, $, H, ne, J, Y, ue, te, Z) => {
        const se = $.el = B ? B.el : f(""),
            fe = $.anchor = B ? B.anchor : f("");
        let {
            patchFlag: ie,
            dynamicChildren: me,
            slotScopeIds: he
        } = $;
        he && (te = te ? te.concat(he) : he), B == null ? (n(se, H, ne), n(fe, H, ne), Q($.children, H, fe, J, Y, ue, te, Z)) : ie > 0 && ie & 64 && me && B.dynamicChildren ? (O(B.dynamicChildren, me, H, J, Y, ue, te), ($.key != null || J && $ === J.subTree) && fm(B, $, !0)) : b(B, $, H, fe, J, Y, ue, te, Z)
    }, a = (B, $, H, ne, J, Y, ue, te, Z) => {
        $.slotScopeIds = te, B == null ? $.shapeFlag & 512 ? J.ctx.activate($, H, ne, ue, Z) : c($, H, ne, J, Y, ue, Z) : g(B, $, Z)
    }, c = (B, $, H, ne, J, Y, ue) => {
        const te = B.component = n6(B, ne, J);
        if (iu(B) && (te.ctx.renderer = re), i6(te), te.asyncDep) {
            if (J && J.registerDep(te, v), !B.el) {
                const Z = te.subTree = _t(Ln);
                I(null, Z, $, H)
            }
            return
        }
        v(te, B, $, H, J, Y, ue)
    }, g = (B, $, H) => {
        const ne = $.component = B.component;
        if (dw(B, $, H))
            if (ne.asyncDep && !ne.asyncResolved) {
                x(ne, $, H);
                return
            } else ne.next = $, h6(ne.update), ne.update();
        else $.component = B.component, $.el = B.el, ne.vnode = $
    }, v = (B, $, H, ne, J, Y, ue) => {
        const te = () => {
                if (B.isMounted) {
                    let {
                        next: fe,
                        bu: ie,
                        u: me,
                        parent: he,
                        vnode: le
                    } = B, Pe = fe, xe;
                    $s(B, !1), fe ? (fe.el = le.el, x(B, fe, ue)) : fe = le, ie && Wf(ie), (xe = fe.props && fe.props.onVnodeBeforeUpdate) && li(xe, he, fe, le), $s(B, !0);
                    const de = C0(B),
                        je = B.subTree;
                    B.subTree = de, S(je, de, A(je.el), z(je), B, J, Y), fe.el = de.el, Pe === null && pw(B, de.el), me && kr(me, J), (xe = fe.props && fe.props.onVnodeUpdated) && kr(() => li(xe, he, fe, le), J)
                } else {
                    let fe;
                    const {
                        el: ie,
                        props: me
                    } = $, {
                        bm: he,
                        m: le,
                        parent: Pe
                    } = B, xe = L0($);
                    if ($s(B, !1), he && Wf(he), !xe && (fe = me && me.onVnodeBeforeMount) && li(fe, Pe, $), $s(B, !0), ie && K) {
                        const de = () => {
                            B.subTree = C0(B), K(ie, B.subTree, B, J, null)
                        };
                        xe ? $.type.__asyncLoader().then(() => !B.isUnmounted && de()) : de()
                    } else {
                        const de = B.subTree = C0(B);
                        S(null, de, H, ne, B, J, Y), $.el = de.el
                    }
                    if (le && kr(le, J), !xe && (fe = me && me.onVnodeMounted)) {
                        const de = $;
                        kr(() => li(fe, Pe, de), J)
                    }
                    $.shapeFlag & 256 && B.a && kr(B.a, J), B.isMounted = !0, $ = H = ne = null
                }
            },
            Z = B.effect = new _0(te, () => Am(B.update), B.scope),
            se = B.update = Z.run.bind(Z);
        se.id = B.uid, $s(B, !0), se()
    }, x = (B, $, H) => {
        $.component = B;
        const ne = B.vnode.props;
        B.vnode = $, B.next = null, Fw(B, $.props, ne, H), Lw(B, $.children, H), vo(), Y0(void 0, B.update), Ds()
    }, b = (B, $, H, ne, J, Y, ue, te, Z = !1) => {
        const se = B && B.children,
            fe = B ? B.shapeFlag : 0,
            ie = $.children,
            {
                patchFlag: me,
                shapeFlag: he
            } = $;
        if (me > 0) {
            if (me & 128) {
                h(se, ie, H, ne, J, Y, ue, te, Z);
                return
            } else if (me & 256) {
                y(se, ie, H, ne, J, Y, ue, te, Z);
                return
            }
        }
        he & 8 ? (fe & 16 && G(se, J, Y), ie !== se && p(H, ie)) : fe & 16 ? he & 16 ? h(se, ie, H, ne, J, Y, ue, te, Z) : G(se, J, Y, !0) : (fe & 8 && p(H, ""), he & 16 && Q(ie, H, ne, J, Y, ue, te, Z))
    }, y = (B, $, H, ne, J, Y, ue, te, Z) => {
        B = B || yo, $ = $ || yo;
        const se = B.length,
            fe = $.length,
            ie = Math.min(se, fe);
        let me;
        for (me = 0; me < ie; me++) {
            const he = $[me] = Z ? ls($[me]) : ui($[me]);
            S(B[me], he, H, null, J, Y, ue, te, Z)
        }
        se > fe ? G(B, J, Y, !0, !1, ie) : Q($, H, ne, J, Y, ue, te, Z, ie)
    }, h = (B, $, H, ne, J, Y, ue, te, Z) => {
        let se = 0;
        const fe = $.length;
        let ie = B.length - 1,
            me = fe - 1;
        for (; se <= ie && se <= me;) {
            const he = B[se],
                le = $[se] = Z ? ls($[se]) : ui($[se]);
            if (zs(he, le)) S(he, le, H, null, J, Y, ue, te, Z);
            else break;
            se++
        }
        for (; se <= ie && se <= me;) {
            const he = B[ie],
                le = $[me] = Z ? ls($[me]) : ui($[me]);
            if (zs(he, le)) S(he, le, H, null, J, Y, ue, te, Z);
            else break;
            ie--, me--
        }
        if (se > ie) {
            if (se <= me) {
                const he = me + 1,
                    le = he < fe ? $[he].el : ne;
                for (; se <= me;) S(null, $[se] = Z ? ls($[se]) : ui($[se]), H, le, J, Y, ue, te, Z), se++
            }
        } else if (se > me)
            for (; se <= ie;) _(B[se], J, Y, !0), se++;
        else {
            const he = se,
                le = se,
                Pe = new Map;
            for (se = le; se <= me; se++) {
                const oe = $[se] = Z ? ls($[se]) : ui($[se]);
                oe.key != null && Pe.set(oe.key, se)
            }
            let xe, de = 0;
            const je = me - le + 1;
            let Ie = !1,
                be = 0;
            const X = new Array(je);
            for (se = 0; se < je; se++) X[se] = 0;
            for (se = he; se <= ie; se++) {
                const oe = B[se];
                if (de >= je) {
                    _(oe, J, Y, !0);
                    continue
                }
                let ve;
                if (oe.key != null) ve = Pe.get(oe.key);
                else
                    for (xe = le; xe <= me; xe++)
                        if (X[xe - le] === 0 && zs(oe, $[xe])) {
                            ve = xe;
                            break
                        }
                ve === void 0 ? _(oe, J, Y, !0) : (X[ve - le] = se + 1, ve >= be ? be = ve : Ie = !0, S(oe, $[ve], H, null, J, Y, ue, te, Z), de++)
            }
            const ae = Ie ? Hw(X) : yo;
            for (xe = ae.length - 1, se = je - 1; se >= 0; se--) {
                const oe = le + se,
                    ve = $[oe],
                    ye = oe + 1 < fe ? $[oe + 1].el : ne;
                X[se] === 0 ? S(null, ve, H, ye, J, Y, ue, te, Z) : Ie && (xe < 0 || se !== ae[xe] ? u(ve, H, ye, 2) : xe--)
            }
        }
    }, u = (B, $, H, ne, J = null) => {
        const {
            el: Y,
            type: ue,
            transition: te,
            children: Z,
            shapeFlag: se
        } = B;
        if (se & 6) {
            u(B.component.subTree, $, H, ne);
            return
        }
        if (se & 128) {
            B.suspense.move($, H, ne);
            return
        }
        if (se & 64) {
            ue.move(B, $, H, re);
            return
        }
        if (ue === rn) {
            n(Y, $, H);
            for (let ie = 0; ie < Z.length; ie++) u(Z[ie], $, H, ne);
            n(B.anchor, $, H);
            return
        }
        if (ue === au) {
            M(B, $, H);
            return
        }
        if (ne !== 2 && se & 1 && te)
            if (ne === 0) te.beforeEnter(Y), n(Y, $, H), kr(() => te.enter(Y), J);
            else {
                const {
                    leave: ie,
                    delayLeave: me,
                    afterLeave: he
                } = te, le = () => n(Y, $, H), Pe = () => {
                    ie(Y, () => {
                        le(), he && he()
                    })
                };
                me ? me(Y, le, Pe) : Pe()
            }
        else n(Y, $, H)
    }, _ = (B, $, H, ne = !1, J = !1) => {
        const {
            type: Y,
            props: ue,
            ref: te,
            children: Z,
            dynamicChildren: se,
            shapeFlag: fe,
            patchFlag: ie,
            dirs: me
        } = B;
        if (te != null && H0(te, null, H, B, !0), fe & 256) {
            $.ctx.deactivate(B);
            return
        }
        const he = fe & 1 && me,
            le = !L0(B);
        let Pe;
        if (le && (Pe = ue && ue.onVnodeBeforeUnmount) && li(Pe, $, B), fe & 6) R(B.component, H, ne);
        else {
            if (fe & 128) {
                B.suspense.unmount(H, ne);
                return
            }
            he && Bs(B, null, $, "beforeUnmount"), fe & 64 ? B.type.remove(B, $, H, J, re, ne) : se && (Y !== rn || ie > 0 && ie & 64) ? G(se, $, H, !1, !0) : (Y === rn && ie & (128 | 256) || !J && fe & 16) && G(Z, $, H), ne && L(B)
        }(le && (Pe = ue && ue.onVnodeUnmounted) || he) && kr(() => {
            Pe && li(Pe, $, B), he && Bs(B, null, $, "unmounted")
        }, H)
    }, L = B => {
        const {
            type: $,
            el: H,
            anchor: ne,
            transition: J
        } = B;
        if ($ === rn) {
            E(H, ne);
            return
        }
        if ($ === au) {
            F(B);
            return
        }
        const Y = () => {
            i(H), J && !J.persisted && J.afterLeave && J.afterLeave()
        };
        if (B.shapeFlag & 1 && J && !J.persisted) {
            const {
                leave: ue,
                delayLeave: te
            } = J, Z = () => ue(H, Y);
            te ? te(B.el, Y, Z) : Z()
        } else Y()
    }, E = (B, $) => {
        let H;
        for (; B !== $;) H = T(B), i(B), B = H;
        i($)
    }, R = (B, $, H) => {
        const {
            bum: ne,
            scope: J,
            update: Y,
            subTree: ue,
            um: te
        } = B;
        ne && Wf(ne), J.stop(), Y && (Y.active = !1, _(ue, B, $, H)), te && kr(te, $), kr(() => {
            B.isUnmounted = !0
        }, $), $ && $.pendingBranch && !$.isUnmounted && B.asyncDep && !B.asyncResolved && B.suspenseId === $.pendingId && ($.deps--, $.deps === 0 && $.resolve())
    }, G = (B, $, H, ne = !1, J = !1, Y = 0) => {
        for (let ue = Y; ue < B.length; ue++) _(B[ue], $, H, ne, J)
    }, z = B => B.shapeFlag & 6 ? z(B.component.subTree) : B.shapeFlag & 128 ? B.suspense.next() : T(B.anchor || B.el), j = (B, $, H) => {
        B == null ? $._vnode && _($._vnode, null, null, !0) : S($._vnode || null, B, $, null, null, null, H), Mm(), $._vnode = B
    }, re = {
        p: S,
        um: _,
        m: u,
        r: L,
        mt: c,
        mc: Q,
        pc: b,
        pbc: O,
        n: z,
        o: t
    };
    let ee, K;
    return e && ([ee, K] = e(re)), {
        render: j,
        hydrate: ee,
        createApp: $w(j, ee)
    }
}

function $s({
    effect: t,
    update: e
}, r) {
    t.allowRecurse = e.allowRecurse = r
}

function fm(t, e, r = !1) {
    const n = t.children,
        i = e.children;
    if (qe(n) && qe(i))
        for (let s = 0; s < n.length; s++) {
            const o = n[s];
            let f = i[s];
            f.shapeFlag & 1 && !f.dynamicChildren && ((f.patchFlag <= 0 || f.patchFlag === 32) && (f = i[s] = ls(i[s]), f.el = o.el), r || fm(o, f))
        }
}

function Hw(t) {
    const e = t.slice(),
        r = [0];
    let n, i, s, o, f;
    const l = t.length;
    for (n = 0; n < l; n++) {
        const d = t[n];
        if (d !== 0) {
            if (i = r[r.length - 1], t[i] < d) {
                e[n] = i, r.push(n);
                continue
            }
            for (s = 0, o = r.length - 1; s < o;) f = s + o >> 1, t[r[f]] < d ? s = f + 1 : o = f;
            d < t[r[s]] && (s > 0 && (e[n] = r[s - 1]), r[s] = n)
        }
    }
    for (s = r.length, o = r[s - 1]; s-- > 0;) r[s] = o, o = e[o];
    return r
}
const qw = t => t.__isTeleport,
    um = "components",
    jw = "directives";

function Ww(t, e) {
    return lm(um, t, !0, e) || t
}
const Vw = Symbol();

function _S(t) {
    return lm(jw, t)
}

function lm(t, e, r = !0, n = !1) {
    const i = jr || er;
    if (i) {
        const s = i.type;
        if (t === um) {
            const f = f6(s);
            if (f && (f === e || f === ai(e) || f === jf(ai(e)))) return s
        }
        const o = cm(i[t] || s[t], e) || cm(i.appContext[t], e);
        return !o && n ? s : o
    }
}

function cm(t, e) {
    return t && (t[e] || t[ai(e)] || t[jf(ai(e))])
}
const rn = Symbol(void 0),
    q0 = Symbol(void 0),
    Ln = Symbol(void 0),
    au = Symbol(void 0),
    _a = [];
let Gs = null;

function vr(t = !1) {
    _a.push(Gs = t ? null : [])
}

function Kw() {
    _a.pop(), Gs = _a[_a.length - 1] || null
}
let fu = 1;

function hm(t) {
    fu += t
}

function dm(t) {
    return t.dynamicChildren = fu > 0 ? Gs || yo : null, Kw(), fu > 0 && Gs && Gs.push(t), t
}

function TS(t, e, r, n, i, s) {
    return dm(mm(t, e, r, n, i, s, !0))
}

function wr(t, e, r, n, i) {
    return dm(_t(t, e, r, n, i, !0))
}

function Ta(t) {
    return t ? t.__v_isVNode === !0 : !1
}

function zs(t, e) {
    return t.type === e.type && t.key === e.key
}
const uu = "__vInternal",
    pm = ({
        key: t
    }) => t != null ? t : null,
    lu = ({
        ref: t,
        ref_key: e,
        ref_for: r
    }) => t != null ? ur(t) || Ut(t) || Qe(t) ? {
        i: jr,
        r: t,
        k: e,
        f: !!r
    } : t : null;

function mm(t, e = null, r = null, n = 0, i = null, s = t === rn ? 0 : 1, o = !1, f = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && pm(e),
        ref: e && lu(e),
        scopeId: Bp,
        slotScopeIds: null,
        children: r,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: n,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null
    };
    return f ? (j0(l, r), s & 128 && t.normalize(l)) : r && (l.shapeFlag |= ur(r) ? 8 : 16), fu > 0 && !o && Gs && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Gs.push(l), l
}
const _t = Xw;

function Xw(t, e = null, r = null, n = 0, i = null, s = !1) {
    if ((!t || t === Vw) && (t = Ln), Ta(t)) {
        const f = _o(t, e, !0);
        return r && j0(f, r), f
    }
    if (u6(t) && (t = t.__vccOpts), e) {
        e = Jw(e);
        let {
            class: f,
            style: l
        } = e;
        f && !ur(f) && (e.class = p0(f)), Vt(l) && (kp(l) && !qe(l) && (l = fr({}, l)), e.style = d0(l))
    }
    const o = ur(t) ? 1 : mw(t) ? 128 : qw(t) ? 64 : Vt(t) ? 4 : Qe(t) ? 2 : 0;
    return mm(t, e, r, n, i, o, s, !0)
}

function Jw(t) {
    return t ? kp(t) || uu in t ? fr({}, t) : t : null
}

function _o(t, e, r = !1) {
    const {
        props: n,
        ref: i,
        patchFlag: s,
        children: o
    } = t, f = e ? Yw(n || {}, e) : n;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: f,
        key: f && pm(f),
        ref: e && e.ref ? r && i ? qe(i) ? i.concat(lu(e)) : [i, lu(e)] : lu(e) : i,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: o,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== rn ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && _o(t.ssContent),
        ssFallback: t.ssFallback && _o(t.ssFallback),
        el: t.el,
        anchor: t.anchor
    }
}

function Zw(t = " ", e = 0) {
    return _t(q0, null, t, e)
}

function MS(t, e) {
    const r = _t(au, null, t);
    return r.staticCount = e, r
}

function Hs(t = "", e = !1) {
    return e ? (vr(), wr(Ln, null, t)) : _t(Ln, null, t)
}

function ui(t) {
    return t == null || typeof t == "boolean" ? _t(Ln) : qe(t) ? _t(rn, null, t.slice()) : typeof t == "object" ? ls(t) : _t(q0, null, String(t))
}

function ls(t) {
    return t.el === null || t.memo ? t : _o(t)
}

function j0(t, e) {
    let r = 0;
    const {
        shapeFlag: n
    } = t;
    if (e == null) e = null;
    else if (qe(e)) r = 16;
    else if (typeof e == "object")
        if (n & (1 | 64)) {
            const i = e.default;
            i && (i._c && (i._d = !1), j0(t, i()), i._c && (i._d = !0));
            return
        } else {
            r = 32;
            const i = e._;
            !i && !(uu in e) ? e._ctx = jr : i === 3 && jr && (jr.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
        }
    else Qe(e) ? (e = {
        default: e,
        _ctx: jr
    }, r = 32) : (e = String(e), n & 64 ? (r = 16, e = [Zw(e)]) : r = 8);
    t.children = e, t.shapeFlag |= r
}

function Yw(...t) {
    const e = {};
    for (let r = 0; r < t.length; r++) {
        const n = t[r];
        for (const i in n)
            if (i === "class") e.class !== n.class && (e.class = p0([e.class, n.class]));
            else if (i === "style") e.style = d0([e.style, n.style]);
        else if (Gf(i)) {
            const s = e[i],
                o = n[i];
            s !== o && !(qe(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
        } else i !== "" && (e[i] = n[i])
    }
    return e
}

function li(t, e, r, n = null) {
    nn(t, e, 7, [r, n])
}

function NS(t, e, r, n) {
    let i;
    const s = r && r[n];
    if (qe(t) || ur(t)) {
        i = new Array(t.length);
        for (let o = 0, f = t.length; o < f; o++) i[o] = e(t[o], o, void 0, s && s[o])
    } else if (typeof t == "number") {
        i = new Array(t);
        for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o])
    } else if (Vt(t))
        if (t[Symbol.iterator]) i = Array.from(t, (o, f) => e(o, f, void 0, s && s[f]));
        else {
            const o = Object.keys(t);
            i = new Array(o.length);
            for (let f = 0, l = o.length; f < l; f++) {
                const d = o[f];
                i[f] = e(t[d], d, f, s && s[f])
            }
        }
    else i = [];
    return r && (r[n] = i), i
}

function Qw(t, e, r = {}, n, i) {
    if (jr.isCE) return _t("slot", e === "default" ? null : {
        name: e
    }, n && n());
    let s = t[e];
    s && s._c && (s._d = !1), vr();
    const o = s && ym(s(r)),
        f = wr(rn, {
            key: r.key || `_${e}`
        }, o || (n ? n() : []), o && t._ === 1 ? 64 : -2);
    return !i && f.scopeId && (f.slotScopeIds = [f.scopeId + "-s"]), s && s._c && (s._d = !0), f
}

function ym(t) {
    return t.some(e => Ta(e) ? !(e.type === Ln || e.type === rn && !ym(e.children)) : !0) ? t : null
}
const W0 = t => t ? xm(t) ? V0(t) || t.proxy : W0(t.parent) : null,
    cu = fr(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => t.props,
        $attrs: t => t.attrs,
        $slots: t => t.slots,
        $refs: t => t.refs,
        $parent: t => W0(t.parent),
        $root: t => W0(t.root),
        $emit: t => t.emit,
        $options: t => Jp(t),
        $forceUpdate: t => () => Am(t.update),
        $nextTick: t => Z0.bind(t.proxy),
        $watch: t => y6.bind(t)
    }),
    e6 = {
        get({
            _: t
        }, e) {
            const {
                ctx: r,
                setupState: n,
                data: i,
                props: s,
                accessCache: o,
                type: f,
                appContext: l
            } = t;
            let d;
            if (e[0] !== "$") {
                const N = o[e];
                if (N !== void 0) switch (N) {
                    case 1:
                        return n[e];
                    case 2:
                        return i[e];
                    case 4:
                        return r[e];
                    case 3:
                        return s[e]
                } else {
                    if (n !== Pt && yt(n, e)) return o[e] = 1, n[e];
                    if (i !== Pt && yt(i, e)) return o[e] = 2, i[e];
                    if ((d = t.propsOptions[0]) && yt(d, e)) return o[e] = 3, s[e];
                    if (r !== Pt && yt(r, e)) return o[e] = 4, r[e];
                    B0 && (o[e] = 0)
                }
            }
            const p = cu[e];
            let A, T;
            if (p) return e === "$attrs" && qr(t, "get", e), p(t);
            if ((A = f.__cssModules) && (A = A[e])) return A;
            if (r !== Pt && yt(r, e)) return o[e] = 4, r[e];
            if (T = l.config.globalProperties, yt(T, e)) return T[e]
        },
        set({
            _: t
        }, e, r) {
            const {
                data: n,
                setupState: i,
                ctx: s
            } = t;
            if (i !== Pt && yt(i, e)) i[e] = r;
            else if (n !== Pt && yt(n, e)) n[e] = r;
            else if (yt(t.props, e)) return !1;
            return e[0] === "$" && e.slice(1) in t ? !1 : (s[e] = r, !0)
        },
        has({
            _: {
                data: t,
                setupState: e,
                accessCache: r,
                ctx: n,
                appContext: i,
                propsOptions: s
            }
        }, o) {
            let f;
            return !!r[o] || t !== Pt && yt(t, o) || e !== Pt && yt(e, o) || (f = s[0]) && yt(f, o) || yt(n, o) || yt(cu, o) || yt(i.config.globalProperties, o)
        }
    },
    t6 = am();
let r6 = 0;

function n6(t, e, r) {
    const n = t.type,
        i = (e ? e.appContext : t.appContext) || t6,
        s = {
            uid: r6++,
            vnode: t,
            type: n,
            parent: e,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new P2(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(i.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Qp(n, i),
            emitsOptions: Lp(n, i),
            emit: null,
            emitted: null,
            propsDefaults: Pt,
            inheritAttrs: n.inheritAttrs,
            ctx: Pt,
            data: Pt,
            props: Pt,
            attrs: Pt,
            slots: Pt,
            refs: Pt,
            setupState: Pt,
            setupContext: null,
            suspense: r,
            suspenseId: r ? r.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = {
        _: s
    }, s.root = e ? e.root : s, s.emit = lw.bind(null, s), t.ce && t.ce(s), s
}
let er = null;
const gm = () => er || jr,
    To = t => {
        er = t, t.scope.on()
    },
    qs = () => {
        er && er.scope.off(), er = null
    };

function xm(t) {
    return t.vnode.shapeFlag & 4
}
let hu = !1;

function i6(t, e = !1) {
    hu = e;
    const {
        props: r,
        children: n
    } = t.vnode, i = xm(t);
    Cw(t, r, i, e), Uw(t, n);
    const s = i ? s6(t, e) : void 0;
    return hu = !1, s
}

function s6(t, e) {
    const r = t.type;
    t.accessCache = Object.create(null), t.proxy = Op(new Proxy(t.ctx, e6));
    const {
        setup: n
    } = r;
    if (n) {
        const i = t.setupContext = n.length > 1 ? a6(t) : null;
        To(t), vo();
        const s = cs(n, t, 0, [t.props, i]);
        if (Ds(), qs(), cp(s)) {
            if (s.then(qs, qs), e) return s.then(o => {
                bm(t, o, e)
            }).catch(o => {
                du(o, t, 0)
            });
            t.asyncDep = s
        } else bm(t, s, e)
    } else wm(t, e)
}

function bm(t, e, r) {
    Qe(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : Vt(e) && (t.setupState = Up(e)), wm(t, r)
}
let vm;

function wm(t, e, r) {
    const n = t.type;
    if (!t.render) {
        if (!e && vm && !n.render) {
            const i = n.template;
            if (i) {
                const {
                    isCustomElement: s,
                    compilerOptions: o
                } = t.appContext.config, {
                    delimiters: f,
                    compilerOptions: l
                } = n, d = fr(fr({
                    isCustomElement: s,
                    delimiters: f
                }, o), l);
                n.render = vm(i, d)
            }
        }
        t.render = n.render || Un
    }
    To(t), vo(), Pw(t), Ds(), qs()
}

function o6(t) {
    return new Proxy(t.attrs, {
        get(e, r) {
            return qr(t, "get", "$attrs"), e[r]
        }
    })
}

function a6(t) {
    const e = n => {
        t.exposed = n || {}
    };
    let r;
    return {
        get attrs() {
            return r || (r = o6(t))
        },
        slots: t.slots,
        emit: t.emit,
        expose: e
    }
}

function V0(t) {
    if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(Up(Op(t.exposed)), {
        get(e, r) {
            if (r in e) return e[r];
            if (r in cu) return cu[r](t)
        }
    }))
}

function f6(t) {
    return Qe(t) && t.displayName || t.name
}

function u6(t) {
    return Qe(t) && "__vccOpts" in t
}

function cs(t, e, r, n) {
    let i;
    try {
        i = n ? t(...n) : t()
    } catch (s) {
        du(s, e, r)
    }
    return i
}

function nn(t, e, r, n) {
    if (Qe(t)) {
        const s = cs(t, e, r, n);
        return s && cp(s) && s.catch(o => {
            du(o, e, r)
        }), s
    }
    const i = [];
    for (let s = 0; s < t.length; s++) i.push(nn(t[s], e, r, n));
    return i
}

function du(t, e, r, n = !0) {
    const i = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const o = e.proxy,
            f = r;
        for (; s;) {
            const d = s.ec;
            if (d) {
                for (let p = 0; p < d.length; p++)
                    if (d[p](t, o, f) === !1) return
            }
            s = s.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            cs(l, null, 10, [t, o, f]);
            return
        }
    }
    l6(t, r, i, n)
}

function l6(t, e, r, n = !0) {
    console.error(t)
}
let pu = !1,
    K0 = !1;
const Wr = [];
let Hi = 0;
const Ma = [];
let Na = null,
    Mo = 0;
const Sa = [];
let hs = null,
    No = 0;
const Em = Promise.resolve();
let X0 = null,
    J0 = null;

function Z0(t) {
    const e = X0 || Em;
    return t ? e.then(this ? t.bind(this) : t) : e
}

function c6(t) {
    let e = Hi + 1,
        r = Wr.length;
    for (; e < r;) {
        const n = e + r >>> 1;
        Pa(Wr[n]) < t ? e = n + 1 : r = n
    }
    return e
}

function Am(t) {
    (!Wr.length || !Wr.includes(t, pu && t.allowRecurse ? Hi + 1 : Hi)) && t !== J0 && (t.id == null ? Wr.push(t) : Wr.splice(c6(t.id), 0, t), _m())
}

function _m() {
    !pu && !K0 && (K0 = !0, X0 = Em.then(Nm))
}

function h6(t) {
    const e = Wr.indexOf(t);
    e > Hi && Wr.splice(e, 1)
}

function Tm(t, e, r, n) {
    qe(t) ? r.push(...t) : (!e || !e.includes(t, t.allowRecurse ? n + 1 : n)) && r.push(t), _m()
}

function d6(t) {
    Tm(t, Na, Ma, Mo)
}

function p6(t) {
    Tm(t, hs, Sa, No)
}

function Y0(t, e = null) {
    if (Ma.length) {
        for (J0 = e, Na = [...new Set(Ma)], Ma.length = 0, Mo = 0; Mo < Na.length; Mo++) Na[Mo]();
        Na = null, Mo = 0, J0 = null, Y0(t, e)
    }
}

function Mm(t) {
    if (Sa.length) {
        const e = [...new Set(Sa)];
        if (Sa.length = 0, hs) {
            hs.push(...e);
            return
        }
        for (hs = e, hs.sort((r, n) => Pa(r) - Pa(n)), No = 0; No < hs.length; No++) hs[No]();
        hs = null, No = 0
    }
}
const Pa = t => t.id == null ? 1 / 0 : t.id;

function Nm(t) {
    K0 = !1, pu = !0, Y0(t), Wr.sort((r, n) => Pa(r) - Pa(n));
    const e = Un;
    try {
        for (Hi = 0; Hi < Wr.length; Hi++) {
            const r = Wr[Hi];
            r && r.active !== !1 && cs(r, null, 14)
        }
    } finally {
        Hi = 0, Wr.length = 0, Mm(), pu = !1, X0 = null, (Wr.length || Ma.length || Sa.length) && Nm(t)
    }
}

function m6(t, e) {
    return Q0(t, null, e)
}
const Sm = {};

function ds(t, e, r) {
    return Q0(t, e, r)
}

function Q0(t, e, {
    immediate: r,
    deep: n,
    flush: i,
    onTrack: s,
    onTrigger: o
} = Pt) {
    const f = er;
    let l, d = !1,
        p = !1;
    if (Ut(t) ? (l = () => t.value, d = !!t._shallow) : fs(t) ? (l = () => t, n = !0) : qe(t) ? (p = !0, d = t.some(fs), l = () => t.map(k => {
            if (Ut(k)) return k.value;
            if (fs(k)) return js(k);
            if (Qe(k)) return cs(k, f, 2)
        })) : Qe(t) ? e ? l = () => cs(t, f, 2) : l = () => {
            if (!(f && f.isUnmounted)) return A && A(), nn(t, f, 3, [T])
        } : l = Un, e && n) {
        const k = l;
        l = () => js(k())
    }
    let A, T = k => {
        A = S.onStop = () => {
            cs(k, f, 4)
        }
    };
    if (hu) return T = Un, e ? r && nn(e, f, 3, [l(), p ? [] : void 0, T]) : l(), Un;
    let N = p ? [] : Sm;
    const P = () => {
        if (!!S.active)
            if (e) {
                const k = S.run();
                (n || d || (p ? k.some((I, U) => va(I, N[U])) : va(k, N))) && (A && A(), nn(e, f, 3, [k, N === Sm ? void 0 : N, T]), N = k)
            } else S.run()
    };
    P.allowRecurse = !!e;
    let C;
    i === "sync" ? C = P : i === "post" ? C = () => kr(P, f && f.suspense) : C = () => {
        !f || f.isMounted ? d6(P) : P()
    };
    const S = new _0(l, C);
    return e ? r ? P() : N = S.run() : i === "post" ? kr(S.run.bind(S), f && f.suspense) : S.run(), () => {
        S.stop(), f && f.scope && y0(f.scope.effects, S)
    }
}

function y6(t, e, r) {
    const n = this.proxy,
        i = ur(t) ? t.includes(".") ? Pm(n, t) : () => n[t] : t.bind(n, n);
    let s;
    Qe(e) ? s = e : (s = e.handler, r = e);
    const o = er;
    To(this);
    const f = Q0(i, s.bind(n), r);
    return o ? To(o) : qs(), f
}

function Pm(t, e) {
    const r = e.split(".");
    return () => {
        let n = t;
        for (let i = 0; i < r.length && n; i++) n = n[r[i]];
        return n
    }
}

function js(t, e) {
    if (!Vt(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
    if (e.add(t), Ut(t)) js(t.value, e);
    else if (qe(t))
        for (let r = 0; r < t.length; r++) js(t[r], e);
    else if (lp(t) || go(t)) t.forEach(r => {
        js(r, e)
    });
    else if (dp(t))
        for (const r in t) js(t[r], e);
    return t
}

function Ws(t, e, r) {
    const n = arguments.length;
    return n === 2 ? Vt(e) && !qe(e) ? Ta(e) ? _t(t, null, [e]) : _t(t, e) : _t(t, null, e) : (n > 3 ? r = Array.prototype.slice.call(arguments, 2) : n === 3 && Ta(r) && (r = [r]), _t(t, e, r))
}
const g6 = "3.2.26",
    x6 = "http://www.w3.org/2000/svg",
    So = typeof document != "undefined" ? document : null,
    Im = new Map,
    b6 = {
        insert: (t, e, r) => {
            e.insertBefore(t, r || null)
        },
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        },
        createElement: (t, e, r, n) => {
            const i = e ? So.createElementNS(x6, t) : So.createElement(t, r ? {
                is: r
            } : void 0);
            return t === "select" && n && n.multiple != null && i.setAttribute("multiple", n.multiple), i
        },
        createText: t => So.createTextNode(t),
        createComment: t => So.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => So.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        cloneNode(t) {
            const e = t.cloneNode(!0);
            return "_value" in t && (e._value = t._value), e
        },
        insertStaticContent(t, e, r, n) {
            const i = r ? r.previousSibling : e.lastChild;
            let s = Im.get(t);
            if (!s) {
                const o = So.createElement("template");
                if (o.innerHTML = n ? `<svg>${t}</svg>` : t, s = o.content, n) {
                    const f = s.firstChild;
                    for (; f.firstChild;) s.appendChild(f.firstChild);
                    s.removeChild(f)
                }
                Im.set(t, s)
            }
            return e.insertBefore(s.cloneNode(!0), r), [i ? i.nextSibling : e.firstChild, r ? r.previousSibling : e.lastChild]
        }
    };

function v6(t, e, r) {
    const n = t._vtc;
    n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? t.removeAttribute("class") : r ? t.setAttribute("class", e) : t.className = e
}

function w6(t, e, r) {
    const n = t.style,
        i = ur(r);
    if (r && !i) {
        for (const s in r) ec(n, s, r[s]);
        if (e && !ur(e))
            for (const s in e) r[s] == null && ec(n, s, "")
    } else {
        const s = n.display;
        i ? e !== r && (n.cssText = r) : e && t.removeAttribute("style"), "_vod" in t && (n.display = s)
    }
}
const Rm = /\s*!important$/;

function ec(t, e, r) {
    if (qe(r)) r.forEach(n => ec(t, e, n));
    else if (e.startsWith("--")) t.setProperty(e, r);
    else {
        const n = E6(t, e);
        Rm.test(r) ? t.setProperty(xo(n), r.replace(Rm, ""), "important") : t[n] = r
    }
}
const km = ["Webkit", "Moz", "ms"],
    tc = {};

function E6(t, e) {
    const r = tc[e];
    if (r) return r;
    let n = ai(e);
    if (n !== "filter" && n in t) return tc[e] = n;
    n = jf(n);
    for (let i = 0; i < km.length; i++) {
        const s = km[i] + n;
        if (s in t) return tc[e] = s
    }
    return e
}
const Om = "http://www.w3.org/1999/xlink";

function A6(t, e, r, n, i) {
    if (n && e.startsWith("xlink:")) r == null ? t.removeAttributeNS(Om, e.slice(6, e.length)) : t.setAttributeNS(Om, e, r);
    else {
        const s = x2(e);
        r == null || s && !ap(r) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : r)
    }
}

function _6(t, e, r, n, i, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        n && o(n, i, s), t[e] = r == null ? "" : r;
        return
    }
    if (e === "value" && t.tagName !== "PROGRESS" && !t.tagName.includes("-")) {
        t._value = r;
        const f = r == null ? "" : r;
        (t.value !== f || t.tagName === "OPTION") && (t.value = f), r == null && t.removeAttribute(e);
        return
    }
    if (r === "" || r == null) {
        const f = typeof t[e];
        if (f === "boolean") {
            t[e] = ap(r);
            return
        } else if (r == null && f === "string") {
            t[e] = "", t.removeAttribute(e);
            return
        } else if (f === "number") {
            try {
                t[e] = 0
            } catch {}
            t.removeAttribute(e);
            return
        }
    }
    try {
        t[e] = r
    } catch {}
}
let mu = Date.now,
    Cm = !1;
if (typeof window != "undefined") {
    mu() > document.createEvent("Event").timeStamp && (mu = () => performance.now());
    const t = navigator.userAgent.match(/firefox\/(\d+)/i);
    Cm = !!(t && Number(t[1]) <= 53)
}
let rc = 0;
const T6 = Promise.resolve(),
    M6 = () => {
        rc = 0
    },
    N6 = () => rc || (T6.then(M6), rc = mu());

function Po(t, e, r, n) {
    t.addEventListener(e, r, n)
}

function S6(t, e, r, n) {
    t.removeEventListener(e, r, n)
}

function P6(t, e, r, n, i = null) {
    const s = t._vei || (t._vei = {}),
        o = s[e];
    if (n && o) o.value = n;
    else {
        const [f, l] = I6(e);
        if (n) {
            const d = s[e] = R6(n, i);
            Po(t, f, d, l)
        } else o && (S6(t, f, o, l), s[e] = void 0)
    }
}
const Fm = /(?:Once|Passive|Capture)$/;

function I6(t) {
    let e;
    if (Fm.test(t)) {
        e = {};
        let r;
        for (; r = t.match(Fm);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
    }
    return [xo(t.slice(2)), e]
}

function R6(t, e) {
    const r = n => {
        const i = n.timeStamp || mu();
        (Cm || i >= r.attached - 1) && nn(k6(n, r.value), e, 5, [n])
    };
    return r.value = t, r.attached = N6(), r
}

function k6(t, e) {
    if (qe(e)) {
        const r = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            r.call(t), t._stopped = !0
        }, e.map(n => i => !i._stopped && n(i))
    } else return e
}
const Dm = /^on[a-z]/,
    O6 = (t, e, r, n, i = !1, s, o, f, l) => {
        e === "class" ? v6(t, n, i) : e === "style" ? w6(t, r, n) : Gf(e) ? m0(e) || P6(t, e, r, n, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : C6(t, e, n, i)) ? _6(t, e, n, s, o, f, l) : (e === "true-value" ? t._trueValue = n : e === "false-value" && (t._falseValue = n), A6(t, e, n, i))
    };

function C6(t, e, r, n) {
    return n ? !!(e === "innerHTML" || e === "textContent" || e in t && Dm.test(e) && Qe(r)) : e === "spellcheck" || e === "draggable" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || Dm.test(e) && ur(r) ? !1 : e in t
}
const ps = "transition",
    Ia = "animation",
    nc = (t, {
        slots: e
    }) => Ws(zp, F6(t), e);
nc.displayName = "Transition";
const Um = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
nc.props = fr({}, zp.props, Um);
const Vs = (t, e = []) => {
        qe(t) ? t.forEach(r => r(...e)) : t && t(...e)
    },
    Lm = t => t ? qe(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

function F6(t) {
    const e = {};
    for (const w in t) w in Um || (e[w] = t[w]);
    if (t.css === !1) return e;
    const {
        name: r = "v",
        type: n,
        duration: i,
        enterFromClass: s = `${r}-enter-from`,
        enterActiveClass: o = `${r}-enter-active`,
        enterToClass: f = `${r}-enter-to`,
        appearFromClass: l = s,
        appearActiveClass: d = o,
        appearToClass: p = f,
        leaveFromClass: A = `${r}-leave-from`,
        leaveActiveClass: T = `${r}-leave-active`,
        leaveToClass: N = `${r}-leave-to`
    } = t, P = D6(i), C = P && P[0], S = P && P[1], {
        onBeforeEnter: k,
        onEnter: I,
        onEnterCancelled: U,
        onLeave: M,
        onLeaveCancelled: F,
        onBeforeAppear: D = k,
        onAppear: q = I,
        onAppearCancelled: V = U
    } = e, Q = (w, m, a) => {
        Io(w, m ? p : f), Io(w, m ? d : o), a && a()
    }, ce = (w, m) => {
        Io(w, N), Io(w, T), m && m()
    }, O = w => (m, a) => {
        const c = w ? q : I,
            g = () => Q(m, w, a);
        Vs(c, [m, g]), Bm(() => {
            Io(m, w ? l : s), ms(m, w ? p : f), Lm(c) || $m(m, n, C, g)
        })
    };
    return fr(e, {
        onBeforeEnter(w) {
            Vs(k, [w]), ms(w, s), ms(w, o)
        },
        onBeforeAppear(w) {
            Vs(D, [w]), ms(w, l), ms(w, d)
        },
        onEnter: O(!1),
        onAppear: O(!0),
        onLeave(w, m) {
            const a = () => ce(w, m);
            ms(w, A), B6(), ms(w, T), Bm(() => {
                Io(w, A), ms(w, N), Lm(M) || $m(w, n, S, a)
            }), Vs(M, [w, a])
        },
        onEnterCancelled(w) {
            Q(w, !1), Vs(U, [w])
        },
        onAppearCancelled(w) {
            Q(w, !0), Vs(V, [w])
        },
        onLeaveCancelled(w) {
            ce(w), Vs(F, [w])
        }
    })
}

function D6(t) {
    if (t == null) return null;
    if (Vt(t)) return [ic(t.enter), ic(t.leave)]; {
        const e = ic(t);
        return [e, e]
    }
}

function ic(t) {
    return Kf(t)
}

function ms(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.add(r)), (t._vtc || (t._vtc = new Set)).add(e)
}

function Io(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.remove(n));
    const {
        _vtc: r
    } = t;
    r && (r.delete(e), r.size || (t._vtc = void 0))
}

function Bm(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let U6 = 0;

function $m(t, e, r, n) {
    const i = t._endId = ++U6,
        s = () => {
            i === t._endId && n()
        };
    if (r) return setTimeout(s, r);
    const {
        type: o,
        timeout: f,
        propCount: l
    } = L6(t, e);
    if (!o) return n();
    const d = o + "end";
    let p = 0;
    const A = () => {
            t.removeEventListener(d, T), s()
        },
        T = N => {
            N.target === t && ++p >= l && A()
        };
    setTimeout(() => {
        p < l && A()
    }, f + 1), t.addEventListener(d, T)
}

function L6(t, e) {
    const r = window.getComputedStyle(t),
        n = P => (r[P] || "").split(", "),
        i = n(ps + "Delay"),
        s = n(ps + "Duration"),
        o = Gm(i, s),
        f = n(Ia + "Delay"),
        l = n(Ia + "Duration"),
        d = Gm(f, l);
    let p = null,
        A = 0,
        T = 0;
    e === ps ? o > 0 && (p = ps, A = o, T = s.length) : e === Ia ? d > 0 && (p = Ia, A = d, T = l.length) : (A = Math.max(o, d), p = A > 0 ? o > d ? ps : Ia : null, T = p ? p === ps ? s.length : l.length : 0);
    const N = p === ps && /\b(transform|all)(,|$)/.test(r[ps + "Property"]);
    return {
        type: p,
        timeout: A,
        propCount: T,
        hasTransform: N
    }
}

function Gm(t, e) {
    for (; t.length < e.length;) t = t.concat(t);
    return Math.max(...e.map((r, n) => zm(r) + zm(t[n])))
}

function zm(t) {
    return Number(t.slice(0, -1).replace(",", ".")) * 1e3
}

function B6() {
    return document.body.offsetHeight
}
const Hm = t => {
    const e = t.props["onUpdate:modelValue"];
    return qe(e) ? r => Wf(e, r) : e
};

function $6(t) {
    t.target.composing = !0
}

function qm(t) {
    const e = t.target;
    e.composing && (e.composing = !1, G6(e, "input"))
}

function G6(t, e) {
    const r = document.createEvent("HTMLEvents");
    r.initEvent(e, !0, !0), t.dispatchEvent(r)
}
const SS = {
        created(t, {
            modifiers: {
                lazy: e,
                trim: r,
                number: n
            }
        }, i) {
            t._assign = Hm(i);
            const s = n || i.props && i.props.type === "number";
            Po(t, e ? "change" : "input", o => {
                if (o.target.composing) return;
                let f = t.value;
                r ? f = f.trim() : s && (f = Kf(f)), t._assign(f)
            }), r && Po(t, "change", () => {
                t.value = t.value.trim()
            }), e || (Po(t, "compositionstart", $6), Po(t, "compositionend", qm), Po(t, "change", qm))
        },
        mounted(t, {
            value: e
        }) {
            t.value = e == null ? "" : e
        },
        beforeUpdate(t, {
            value: e,
            modifiers: {
                lazy: r,
                trim: n,
                number: i
            }
        }, s) {
            if (t._assign = Hm(s), t.composing || document.activeElement === t && (r || n && t.value.trim() === e || (i || t.type === "number") && Kf(t.value) === e)) return;
            const o = e == null ? "" : e;
            t.value !== o && (t.value = o)
        }
    },
    z6 = ["ctrl", "shift", "alt", "meta"],
    H6 = {
        stop: t => t.stopPropagation(),
        prevent: t => t.preventDefault(),
        self: t => t.target !== t.currentTarget,
        ctrl: t => !t.ctrlKey,
        shift: t => !t.shiftKey,
        alt: t => !t.altKey,
        meta: t => !t.metaKey,
        left: t => "button" in t && t.button !== 0,
        middle: t => "button" in t && t.button !== 1,
        right: t => "button" in t && t.button !== 2,
        exact: (t, e) => z6.some(r => t[`${r}Key`] && !e.includes(r))
    },
    PS = (t, e) => (r, ...n) => {
        for (let i = 0; i < e.length; i++) {
            const s = H6[e[i]];
            if (s && s(r, e)) return
        }
        return t(r, ...n)
    },
    q6 = fr({
        patchProp: O6
    }, b6);
let jm;

function Wm() {
    return jm || (jm = Gw(q6))
}
const yu = (...t) => {
        Wm().render(...t)
    },
    IS = (...t) => {
        const e = Wm().createApp(...t),
            {
                mount: r
            } = e;
        return e.mount = n => {
            const i = j6(n);
            if (!i) return;
            const s = e._component;
            !Qe(s) && !s.render && !s.template && (s.template = i.innerHTML), i.innerHTML = "";
            const o = r(i, !1, i instanceof SVGElement);
            return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o
        }, e
    };

function j6(t) {
    return ur(t) ? document.querySelector(t) : t
}
/*!
 * vue-router v4.1.6
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */
const Ro = typeof window != "undefined";

function W6(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const Nt = Object.assign;

function sc(t, e) {
    const r = {};
    for (const n in e) {
        const i = e[n];
        r[n] = Bn(i) ? i.map(t) : t(i)
    }
    return r
}
const Ra = () => {},
    Bn = Array.isArray,
    V6 = /\/$/,
    K6 = t => t.replace(V6, "");

function oc(t, e, r = "/") {
    let n, i = {},
        s = "",
        o = "";
    const f = e.indexOf("#");
    let l = e.indexOf("?");
    return f < l && f >= 0 && (l = -1), l > -1 && (n = e.slice(0, l), s = e.slice(l + 1, f > -1 ? f : e.length), i = t(s)), f > -1 && (n = n || e.slice(0, f), o = e.slice(f, e.length)), n = Y6(n != null ? n : e, r), {
        fullPath: n + (s && "?") + s + o,
        path: n,
        query: i,
        hash: o
    }
}

function X6(t, e) {
    const r = e.query ? t(e.query) : "";
    return e.path + (r && "?") + r + (e.hash || "")
}

function Vm(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}

function J6(t, e, r) {
    const n = e.matched.length - 1,
        i = r.matched.length - 1;
    return n > -1 && n === i && ko(e.matched[n], r.matched[i]) && Km(e.params, r.params) && t(e.query) === t(r.query) && e.hash === r.hash
}

function ko(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}

function Km(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1;
    for (const r in t)
        if (!Z6(t[r], e[r])) return !1;
    return !0
}

function Z6(t, e) {
    return Bn(t) ? Xm(t, e) : Bn(e) ? Xm(e, t) : t === e
}

function Xm(t, e) {
    return Bn(e) ? t.length === e.length && t.every((r, n) => r === e[n]) : t.length === 1 && t[0] === e
}

function Y6(t, e) {
    if (t.startsWith("/")) return t;
    if (!t) return e;
    const r = e.split("/"),
        n = t.split("/");
    let i = r.length - 1,
        s, o;
    for (s = 0; s < n.length; s++)
        if (o = n[s], o !== ".")
            if (o === "..") i > 1 && i--;
            else break;
    return r.slice(0, i).join("/") + "/" + n.slice(s - (s === n.length ? 1 : 0)).join("/")
}
var ka;
(function(t) {
    t.pop = "pop", t.push = "push"
})(ka || (ka = {}));
var Oa;
(function(t) {
    t.back = "back", t.forward = "forward", t.unknown = ""
})(Oa || (Oa = {}));

function Q6(t) {
    if (!t)
        if (Ro) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), K6(t)
}
const e3 = /^[^#]+#/;

function t3(t, e) {
    return t.replace(e3, "#") + e
}

function r3(t, e) {
    const r = document.documentElement.getBoundingClientRect(),
        n = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: n.left - r.left - (e.left || 0),
        top: n.top - r.top - (e.top || 0)
    }
}
const gu = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});

function n3(t) {
    let e;
    if ("el" in t) {
        const r = t.el,
            n = typeof r == "string" && r.startsWith("#"),
            i = typeof r == "string" ? n ? document.getElementById(r.slice(1)) : document.querySelector(r) : r;
        if (!i) return;
        e = r3(i, t)
    } else e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}

function Jm(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const ac = new Map;

function i3(t, e) {
    ac.set(t, e)
}

function s3(t) {
    const e = ac.get(t);
    return ac.delete(t), e
}
let o3 = () => location.protocol + "//" + location.host;

function Zm(t, e) {
    const {
        pathname: r,
        search: n,
        hash: i
    } = e, s = t.indexOf("#");
    if (s > -1) {
        let f = i.includes(t.slice(s)) ? t.slice(s).length : 1,
            l = i.slice(f);
        return l[0] !== "/" && (l = "/" + l), Vm(l, "")
    }
    return Vm(r, t) + n + i
}

function a3(t, e, r, n) {
    let i = [],
        s = [],
        o = null;
    const f = ({
        state: T
    }) => {
        const N = Zm(t, location),
            P = r.value,
            C = e.value;
        let S = 0;
        if (T) {
            if (r.value = N, e.value = T, o && o === P) {
                o = null;
                return
            }
            S = C ? T.position - C.position : 0
        } else n(N);
        i.forEach(k => {
            k(r.value, P, {
                delta: S,
                type: ka.pop,
                direction: S ? S > 0 ? Oa.forward : Oa.back : Oa.unknown
            })
        })
    };

    function l() {
        o = r.value
    }

    function d(T) {
        i.push(T);
        const N = () => {
            const P = i.indexOf(T);
            P > -1 && i.splice(P, 1)
        };
        return s.push(N), N
    }

    function p() {
        const {
            history: T
        } = window;
        !T.state || T.replaceState(Nt({}, T.state, {
            scroll: gu()
        }), "")
    }

    function A() {
        for (const T of s) T();
        s = [], window.removeEventListener("popstate", f), window.removeEventListener("beforeunload", p)
    }
    return window.addEventListener("popstate", f), window.addEventListener("beforeunload", p), {
        pauseListeners: l,
        listen: d,
        destroy: A
    }
}

function Ym(t, e, r, n = !1, i = !1) {
    return {
        back: t,
        current: e,
        forward: r,
        replaced: n,
        position: window.history.length,
        scroll: i ? gu() : null
    }
}

function f3(t) {
    const {
        history: e,
        location: r
    } = window, n = {
        value: Zm(t, r)
    }, i = {
        value: e.state
    };
    i.value || s(n.value, {
        back: null,
        current: n.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function s(l, d, p) {
        const A = t.indexOf("#"),
            T = A > -1 ? (r.host && document.querySelector("base") ? t : t.slice(A)) + l : o3() + t + l;
        try {
            e[p ? "replaceState" : "pushState"](d, "", T), i.value = d
        } catch (N) {
            console.error(N), r[p ? "replace" : "assign"](T)
        }
    }

    function o(l, d) {
        const p = Nt({}, e.state, Ym(i.value.back, l, i.value.forward, !0), d, {
            position: i.value.position
        });
        s(l, p, !0), n.value = l
    }

    function f(l, d) {
        const p = Nt({}, i.value, e.state, {
            forward: l,
            scroll: gu()
        });
        s(p.current, p, !0);
        const A = Nt({}, Ym(n.value, l, null), {
            position: p.position + 1
        }, d);
        s(l, A, !1), n.value = l
    }
    return {
        location: n,
        state: i,
        push: f,
        replace: o
    }
}

function RS(t) {
    t = Q6(t);
    const e = f3(t),
        r = a3(t, e.state, e.location, e.replace);

    function n(s, o = !0) {
        o || r.pauseListeners(), history.go(s)
    }
    const i = Nt({
        location: "",
        base: t,
        go: n,
        createHref: t3.bind(null, t)
    }, e, r);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => e.location.value
    }), Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => e.state.value
    }), i
}

function u3(t) {
    return typeof t == "string" || t && typeof t == "object"
}

function Qm(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const ys = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
    },
    ey = Symbol("");
var ty;
(function(t) {
    t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated"
})(ty || (ty = {}));

function Oo(t, e) {
    return Nt(new Error, {
        type: t,
        [ey]: !0
    }, e)
}

function qi(t, e) {
    return t instanceof Error && ey in t && (e == null || !!(t.type & e))
}
const ry = "[^/]+?",
    l3 = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    c3 = /[.+*?^${}()[\]/\\]/g;

function h3(t, e) {
    const r = Nt({}, l3, e),
        n = [];
    let i = r.start ? "^" : "";
    const s = [];
    for (const d of t) {
        const p = d.length ? [] : [90];
        r.strict && !d.length && (i += "/");
        for (let A = 0; A < d.length; A++) {
            const T = d[A];
            let N = 40 + (r.sensitive ? .25 : 0);
            if (T.type === 0) A || (i += "/"), i += T.value.replace(c3, "\\$&"), N += 40;
            else if (T.type === 1) {
                const {
                    value: P,
                    repeatable: C,
                    optional: S,
                    regexp: k
                } = T;
                s.push({
                    name: P,
                    repeatable: C,
                    optional: S
                });
                const I = k || ry;
                if (I !== ry) {
                    N += 10;
                    try {
                        new RegExp(`(${I})`)
                    } catch (M) {
                        throw new Error(`Invalid custom RegExp for param "${P}" (${I}): ` + M.message)
                    }
                }
                let U = C ? `((?:${I})(?:/(?:${I}))*)` : `(${I})`;
                A || (U = S && d.length < 2 ? `(?:/${U})` : "/" + U), S && (U += "?"), i += U, N += 20, S && (N += -8), C && (N += -20), I === ".*" && (N += -50)
            }
            p.push(N)
        }
        n.push(p)
    }
    if (r.strict && r.end) {
        const d = n.length - 1;
        n[d][n[d].length - 1] += .7000000000000001
    }
    r.strict || (i += "/?"), r.end ? i += "$" : r.strict && (i += "(?:/|$)");
    const o = new RegExp(i, r.sensitive ? "" : "i");

    function f(d) {
        const p = d.match(o),
            A = {};
        if (!p) return null;
        for (let T = 1; T < p.length; T++) {
            const N = p[T] || "",
                P = s[T - 1];
            A[P.name] = N && P.repeatable ? N.split("/") : N
        }
        return A
    }

    function l(d) {
        let p = "",
            A = !1;
        for (const T of t) {
            (!A || !p.endsWith("/")) && (p += "/"), A = !1;
            for (const N of T)
                if (N.type === 0) p += N.value;
                else if (N.type === 1) {
                const {
                    value: P,
                    repeatable: C,
                    optional: S
                } = N, k = P in d ? d[P] : "";
                if (Bn(k) && !C) throw new Error(`Provided param "${P}" is an array but it is not repeatable (* or + modifiers)`);
                const I = Bn(k) ? k.join("/") : k;
                if (!I)
                    if (S) T.length < 2 && (p.endsWith("/") ? p = p.slice(0, -1) : A = !0);
                    else throw new Error(`Missing required param "${P}"`);
                p += I
            }
        }
        return p || "/"
    }
    return {
        re: o,
        score: n,
        keys: s,
        parse: f,
        stringify: l
    }
}

function d3(t, e) {
    let r = 0;
    for (; r < t.length && r < e.length;) {
        const n = e[r] - t[r];
        if (n) return n;
        r++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}

function p3(t, e) {
    let r = 0;
    const n = t.score,
        i = e.score;
    for (; r < n.length && r < i.length;) {
        const s = d3(n[r], i[r]);
        if (s) return s;
        r++
    }
    if (Math.abs(i.length - n.length) === 1) {
        if (ny(n)) return 1;
        if (ny(i)) return -1
    }
    return i.length - n.length
}

function ny(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const m3 = {
        type: 0,
        value: ""
    },
    y3 = /[a-zA-Z0-9_]/;

function g3(t) {
    if (!t) return [
        []
    ];
    if (t === "/") return [
        [m3]
    ];
    if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`);

    function e(N) {
        throw new Error(`ERR (${r})/"${d}": ${N}`)
    }
    let r = 0,
        n = r;
    const i = [];
    let s;

    function o() {
        s && i.push(s), s = []
    }
    let f = 0,
        l, d = "",
        p = "";

    function A() {
        !d || (r === 0 ? s.push({
            type: 0,
            value: d
        }) : r === 1 || r === 2 || r === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${d}) must be alone in its segment. eg: '/:ids+.`), s.push({
            type: 1,
            value: d,
            regexp: p,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"), d = "")
    }

    function T() {
        d += l
    }
    for (; f < t.length;) {
        if (l = t[f++], l === "\\" && r !== 2) {
            n = r, r = 4;
            continue
        }
        switch (r) {
            case 0:
                l === "/" ? (d && A(), o()) : l === ":" ? (A(), r = 1) : T();
                break;
            case 4:
                T(), r = n;
                break;
            case 1:
                l === "(" ? r = 2 : y3.test(l) ? T() : (A(), r = 0, l !== "*" && l !== "?" && l !== "+" && f--);
                break;
            case 2:
                l === ")" ? p[p.length - 1] == "\\" ? p = p.slice(0, -1) + l : r = 3 : p += l;
                break;
            case 3:
                A(), r = 0, l !== "*" && l !== "?" && l !== "+" && f--, p = "";
                break;
            default:
                e("Unknown state");
                break
        }
    }
    return r === 2 && e(`Unfinished custom RegExp for param "${d}"`), A(), o(), i
}

function x3(t, e, r) {
    const n = h3(g3(t.path), r),
        i = Nt(n, {
            record: t,
            parent: e,
            children: [],
            alias: []
        });
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i
}

function b3(t, e) {
    const r = [],
        n = new Map;
    e = oy({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);

    function i(p) {
        return n.get(p)
    }

    function s(p, A, T) {
        const N = !T,
            P = v3(p);
        P.aliasOf = T && T.record;
        const C = oy(e, p),
            S = [P];
        if ("alias" in p) {
            const U = typeof p.alias == "string" ? [p.alias] : p.alias;
            for (const M of U) S.push(Nt({}, P, {
                components: T ? T.record.components : P.components,
                path: M,
                aliasOf: T ? T.record : P
            }))
        }
        let k, I;
        for (const U of S) {
            const {
                path: M
            } = U;
            if (A && M[0] !== "/") {
                const F = A.record.path,
                    D = F[F.length - 1] === "/" ? "" : "/";
                U.path = A.record.path + (M && D + M)
            }
            if (k = x3(U, A, C), T ? T.alias.push(k) : (I = I || k, I !== k && I.alias.push(k), N && p.name && !sy(k) && o(p.name)), P.children) {
                const F = P.children;
                for (let D = 0; D < F.length; D++) s(F[D], k, T && T.children[D])
            }
            T = T || k, (k.record.components && Object.keys(k.record.components).length || k.record.name || k.record.redirect) && l(k)
        }
        return I ? () => {
            o(I)
        } : Ra
    }

    function o(p) {
        if (Qm(p)) {
            const A = n.get(p);
            A && (n.delete(p), r.splice(r.indexOf(A), 1), A.children.forEach(o), A.alias.forEach(o))
        } else {
            const A = r.indexOf(p);
            A > -1 && (r.splice(A, 1), p.record.name && n.delete(p.record.name), p.children.forEach(o), p.alias.forEach(o))
        }
    }

    function f() {
        return r
    }

    function l(p) {
        let A = 0;
        for (; A < r.length && p3(p, r[A]) >= 0 && (p.record.path !== r[A].record.path || !ay(p, r[A]));) A++;
        r.splice(A, 0, p), p.record.name && !sy(p) && n.set(p.record.name, p)
    }

    function d(p, A) {
        let T, N = {},
            P, C;
        if ("name" in p && p.name) {
            if (T = n.get(p.name), !T) throw Oo(1, {
                location: p
            });
            C = T.record.name, N = Nt(iy(A.params, T.keys.filter(I => !I.optional).map(I => I.name)), p.params && iy(p.params, T.keys.map(I => I.name))), P = T.stringify(N)
        } else if ("path" in p) P = p.path, T = r.find(I => I.re.test(P)), T && (N = T.parse(P), C = T.record.name);
        else {
            if (T = A.name ? n.get(A.name) : r.find(I => I.re.test(A.path)), !T) throw Oo(1, {
                location: p,
                currentLocation: A
            });
            C = T.record.name, N = Nt({}, A.params, p.params), P = T.stringify(N)
        }
        const S = [];
        let k = T;
        for (; k;) S.unshift(k.record), k = k.parent;
        return {
            name: C,
            path: P,
            params: N,
            matched: S,
            meta: E3(S)
        }
    }
    return t.forEach(p => s(p)), {
        addRoute: s,
        resolve: d,
        removeRoute: o,
        getRoutes: f,
        getRecordMatcher: i
    }
}

function iy(t, e) {
    const r = {};
    for (const n of e) n in t && (r[n] = t[n]);
    return r
}

function v3(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: w3(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}

function w3(t) {
    const e = {},
        r = t.props || !1;
    if ("component" in t) e.default = r;
    else
        for (const n in t.components) e[n] = typeof r == "boolean" ? r : r[n];
    return e
}

function sy(t) {
    for (; t;) {
        if (t.record.aliasOf) return !0;
        t = t.parent
    }
    return !1
}

function E3(t) {
    return t.reduce((e, r) => Nt(e, r.meta), {})
}

function oy(t, e) {
    const r = {};
    for (const n in t) r[n] = n in e ? e[n] : t[n];
    return r
}

function ay(t, e) {
    return e.children.some(r => r === t || ay(t, r))
}
const fy = /#/g,
    A3 = /&/g,
    _3 = /\//g,
    T3 = /=/g,
    M3 = /\?/g,
    uy = /\+/g,
    N3 = /%5B/g,
    S3 = /%5D/g,
    ly = /%5E/g,
    P3 = /%60/g,
    cy = /%7B/g,
    I3 = /%7C/g,
    hy = /%7D/g,
    R3 = /%20/g;

function fc(t) {
    return encodeURI("" + t).replace(I3, "|").replace(N3, "[").replace(S3, "]")
}

function k3(t) {
    return fc(t).replace(cy, "{").replace(hy, "}").replace(ly, "^")
}

function uc(t) {
    return fc(t).replace(uy, "%2B").replace(R3, "+").replace(fy, "%23").replace(A3, "%26").replace(P3, "`").replace(cy, "{").replace(hy, "}").replace(ly, "^")
}

function O3(t) {
    return uc(t).replace(T3, "%3D")
}

function C3(t) {
    return fc(t).replace(fy, "%23").replace(M3, "%3F")
}

function F3(t) {
    return t == null ? "" : C3(t).replace(_3, "%2F")
}

function xu(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {}
    return "" + t
}

function D3(t) {
    const e = {};
    if (t === "" || t === "?") return e;
    const n = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let i = 0; i < n.length; ++i) {
        const s = n[i].replace(uy, " "),
            o = s.indexOf("="),
            f = xu(o < 0 ? s : s.slice(0, o)),
            l = o < 0 ? null : xu(s.slice(o + 1));
        if (f in e) {
            let d = e[f];
            Bn(d) || (d = e[f] = [d]), d.push(l)
        } else e[f] = l
    }
    return e
}

function dy(t) {
    let e = "";
    for (let r in t) {
        const n = t[r];
        if (r = O3(r), n == null) {
            n !== void 0 && (e += (e.length ? "&" : "") + r);
            continue
        }(Bn(n) ? n.map(s => s && uc(s)) : [n && uc(n)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + r, s != null && (e += "=" + s))
        })
    }
    return e
}

function U3(t) {
    const e = {};
    for (const r in t) {
        const n = t[r];
        n !== void 0 && (e[r] = Bn(n) ? n.map(i => i == null ? null : "" + i) : n == null ? n : "" + n)
    }
    return e
}
const L3 = Symbol(""),
    py = Symbol(""),
    bu = Symbol(""),
    lc = Symbol(""),
    cc = Symbol("");

function Ca() {
    let t = [];

    function e(n) {
        return t.push(n), () => {
            const i = t.indexOf(n);
            i > -1 && t.splice(i, 1)
        }
    }

    function r() {
        t = []
    }
    return {
        add: e,
        list: () => t,
        reset: r
    }
}

function gs(t, e, r, n, i) {
    const s = n && (n.enterCallbacks[i] = n.enterCallbacks[i] || []);
    return () => new Promise((o, f) => {
        const l = A => {
                A === !1 ? f(Oo(4, {
                    from: r,
                    to: e
                })) : A instanceof Error ? f(A) : u3(A) ? f(Oo(2, {
                    from: e,
                    to: A
                })) : (s && n.enterCallbacks[i] === s && typeof A == "function" && s.push(A), o())
            },
            d = t.call(n && n.instances[i], e, r, l);
        let p = Promise.resolve(d);
        t.length < 3 && (p = p.then(l)), p.catch(A => f(A))
    })
}

function hc(t, e, r, n) {
    const i = [];
    for (const s of t)
        for (const o in s.components) {
            let f = s.components[o];
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (B3(f)) {
                    const d = (f.__vccOpts || f)[e];
                    d && i.push(gs(d, r, n, s, o))
                } else {
                    let l = f();
                    i.push(() => l.then(d => {
                        if (!d) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                        const p = W6(d) ? d.default : d;
                        s.components[o] = p;
                        const T = (p.__vccOpts || p)[e];
                        return T && gs(T, r, n, s, o)()
                    }))
                }
        }
    return i
}

function B3(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}

function my(t) {
    const e = fi(bu),
        r = fi(lc),
        n = br(() => e.resolve(Us(t.to))),
        i = br(() => {
            const {
                matched: l
            } = n.value, {
                length: d
            } = l, p = l[d - 1], A = r.matched;
            if (!p || !A.length) return -1;
            const T = A.findIndex(ko.bind(null, p));
            if (T > -1) return T;
            const N = yy(l[d - 2]);
            return d > 1 && yy(p) === N && A[A.length - 1].path !== N ? A.findIndex(ko.bind(null, l[d - 2])) : T
        }),
        s = br(() => i.value > -1 && H3(r.params, n.value.params)),
        o = br(() => i.value > -1 && i.value === r.matched.length - 1 && Km(r.params, n.value.params));

    function f(l = {}) {
        return z3(l) ? e[Us(t.replace) ? "replace" : "push"](Us(t.to)).catch(Ra) : Promise.resolve()
    }
    return {
        route: n,
        href: br(() => n.value.href),
        isActive: s,
        isExactActive: o,
        navigate: f
    }
}
const $3 = Eo({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: my,
        setup(t, {
            slots: e
        }) {
            const r = wo(my(t)),
                {
                    options: n
                } = fi(bu),
                i = br(() => ({
                    [gy(t.activeClass, n.linkActiveClass, "router-link-active")]: r.isActive,
                    [gy(t.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: r.isExactActive
                }));
            return () => {
                const s = e.default && e.default(r);
                return t.custom ? s : Ws("a", {
                    "aria-current": r.isExactActive ? t.ariaCurrentValue : null,
                    href: r.href,
                    onClick: r.navigate,
                    class: i.value
                }, s)
            }
        }
    }),
    G3 = $3;

function z3(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}

function H3(t, e) {
    for (const r in e) {
        const n = e[r],
            i = t[r];
        if (typeof n == "string") {
            if (n !== i) return !1
        } else if (!Bn(i) || i.length !== n.length || n.some((s, o) => s !== i[o])) return !1
    }
    return !0
}

function yy(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const gy = (t, e, r) => t != null ? t : e != null ? e : r,
    q3 = Eo({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, {
            attrs: e,
            slots: r
        }) {
            const n = fi(cc),
                i = br(() => t.route || n.value),
                s = fi(py, 0),
                o = br(() => {
                    let d = Us(s);
                    const {
                        matched: p
                    } = i.value;
                    let A;
                    for (;
                        (A = p[d]) && !A.components;) d++;
                    return d
                }),
                f = br(() => i.value.matched[o.value]);
            nu(py, br(() => o.value + 1)), nu(L3, f), nu(cc, i);
            const l = Zt();
            return ds(() => [l.value, f.value, t.name], ([d, p, A], [T, N, P]) => {
                p && (p.instances[A] = d, N && N !== p && d && d === T && (p.leaveGuards.size || (p.leaveGuards = N.leaveGuards), p.updateGuards.size || (p.updateGuards = N.updateGuards))), d && p && (!N || !ko(p, N) || !T) && (p.enterCallbacks[A] || []).forEach(C => C(d))
            }, {
                flush: "post"
            }), () => {
                const d = i.value,
                    p = t.name,
                    A = f.value,
                    T = A && A.components[p];
                if (!T) return xy(r.default, {
                    Component: T,
                    route: d
                });
                const N = A.props[p],
                    P = N ? N === !0 ? d.params : typeof N == "function" ? N(d) : N : null,
                    S = Ws(T, Nt({}, P, e, {
                        onVnodeUnmounted: k => {
                            k.component.isUnmounted && (A.instances[p] = null)
                        },
                        ref: l
                    }));
                return xy(r.default, {
                    Component: S,
                    route: d
                }) || S
            }
        }
    });

function xy(t, e) {
    if (!t) return null;
    const r = t(e);
    return r.length === 1 ? r[0] : r
}
const j3 = q3;

function kS(t) {
    const e = b3(t.routes, t),
        r = t.parseQuery || D3,
        n = t.stringifyQuery || dy,
        i = t.history,
        s = Ca(),
        o = Ca(),
        f = Ca(),
        l = iw(ys);
    let d = ys;
    Ro && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const p = sc.bind(null, E => "" + E),
        A = sc.bind(null, F3),
        T = sc.bind(null, xu);

    function N(E, R) {
        let G, z;
        return Qm(E) ? (G = e.getRecordMatcher(E), z = R) : z = E, e.addRoute(z, G)
    }

    function P(E) {
        const R = e.getRecordMatcher(E);
        R && e.removeRoute(R)
    }

    function C() {
        return e.getRoutes().map(E => E.record)
    }

    function S(E) {
        return !!e.getRecordMatcher(E)
    }

    function k(E, R) {
        if (R = Nt({}, R || l.value), typeof E == "string") {
            const K = oc(r, E, R.path),
                B = e.resolve({
                    path: K.path
                }, R),
                $ = i.createHref(K.fullPath);
            return Nt(K, B, {
                params: T(B.params),
                hash: xu(K.hash),
                redirectedFrom: void 0,
                href: $
            })
        }
        let G;
        if ("path" in E) G = Nt({}, E, {
            path: oc(r, E.path, R.path).path
        });
        else {
            const K = Nt({}, E.params);
            for (const B in K) K[B] == null && delete K[B];
            G = Nt({}, E, {
                params: A(E.params)
            }), R.params = A(R.params)
        }
        const z = e.resolve(G, R),
            j = E.hash || "";
        z.params = p(T(z.params));
        const re = X6(n, Nt({}, E, {
                hash: k3(j),
                path: z.path
            })),
            ee = i.createHref(re);
        return Nt({
            fullPath: re,
            hash: j,
            query: n === dy ? U3(E.query) : E.query || {}
        }, z, {
            redirectedFrom: void 0,
            href: ee
        })
    }

    function I(E) {
        return typeof E == "string" ? oc(r, E, l.value.path) : Nt({}, E)
    }

    function U(E, R) {
        if (d !== E) return Oo(8, {
            from: R,
            to: E
        })
    }

    function M(E) {
        return q(E)
    }

    function F(E) {
        return M(Nt(I(E), {
            replace: !0
        }))
    }

    function D(E) {
        const R = E.matched[E.matched.length - 1];
        if (R && R.redirect) {
            const {
                redirect: G
            } = R;
            let z = typeof G == "function" ? G(E) : G;
            return typeof z == "string" && (z = z.includes("?") || z.includes("#") ? z = I(z) : {
                path: z
            }, z.params = {}), Nt({
                query: E.query,
                hash: E.hash,
                params: "path" in z ? {} : E.params
            }, z)
        }
    }

    function q(E, R) {
        const G = d = k(E),
            z = l.value,
            j = E.state,
            re = E.force,
            ee = E.replace === !0,
            K = D(G);
        if (K) return q(Nt(I(K), {
            state: typeof K == "object" ? Nt({}, j, K.state) : j,
            force: re,
            replace: ee
        }), R || G);
        const B = G;
        B.redirectedFrom = R;
        let $;
        return !re && J6(n, z, G) && ($ = Oo(16, {
            to: B,
            from: z
        }), y(z, z, !0, !1)), ($ ? Promise.resolve($) : Q(B, z)).catch(H => qi(H) ? qi(H, 2) ? H : b(H) : v(H, B, z)).then(H => {
            if (H) {
                if (qi(H, 2)) return q(Nt({
                    replace: ee
                }, I(H.to), {
                    state: typeof H.to == "object" ? Nt({}, j, H.to.state) : j,
                    force: re
                }), R || B)
            } else H = O(B, z, !0, ee, j);
            return ce(B, z, H), H
        })
    }

    function V(E, R) {
        const G = U(E, R);
        return G ? Promise.reject(G) : Promise.resolve()
    }

    function Q(E, R) {
        let G;
        const [z, j, re] = W3(E, R);
        G = hc(z.reverse(), "beforeRouteLeave", E, R);
        for (const K of z) K.leaveGuards.forEach(B => {
            G.push(gs(B, E, R))
        });
        const ee = V.bind(null, E, R);
        return G.push(ee), Co(G).then(() => {
            G = [];
            for (const K of s.list()) G.push(gs(K, E, R));
            return G.push(ee), Co(G)
        }).then(() => {
            G = hc(j, "beforeRouteUpdate", E, R);
            for (const K of j) K.updateGuards.forEach(B => {
                G.push(gs(B, E, R))
            });
            return G.push(ee), Co(G)
        }).then(() => {
            G = [];
            for (const K of E.matched)
                if (K.beforeEnter && !R.matched.includes(K))
                    if (Bn(K.beforeEnter))
                        for (const B of K.beforeEnter) G.push(gs(B, E, R));
                    else G.push(gs(K.beforeEnter, E, R));
            return G.push(ee), Co(G)
        }).then(() => (E.matched.forEach(K => K.enterCallbacks = {}), G = hc(re, "beforeRouteEnter", E, R), G.push(ee), Co(G))).then(() => {
            G = [];
            for (const K of o.list()) G.push(gs(K, E, R));
            return G.push(ee), Co(G)
        }).catch(K => qi(K, 8) ? K : Promise.reject(K))
    }

    function ce(E, R, G) {
        for (const z of f.list()) z(E, R, G)
    }

    function O(E, R, G, z, j) {
        const re = U(E, R);
        if (re) return re;
        const ee = R === ys,
            K = Ro ? history.state : {};
        G && (z || ee ? i.replace(E.fullPath, Nt({
            scroll: ee && K && K.scroll
        }, j)) : i.push(E.fullPath, j)), l.value = E, y(E, R, G, ee), b()
    }
    let w;

    function m() {
        w || (w = i.listen((E, R, G) => {
            if (!L.listening) return;
            const z = k(E),
                j = D(z);
            if (j) {
                q(Nt(j, {
                    replace: !0
                }), z).catch(Ra);
                return
            }
            d = z;
            const re = l.value;
            Ro && i3(Jm(re.fullPath, G.delta), gu()), Q(z, re).catch(ee => qi(ee, 4 | 8) ? ee : qi(ee, 2) ? (q(ee.to, z).then(K => {
                qi(K, 4 | 16) && !G.delta && G.type === ka.pop && i.go(-1, !1)
            }).catch(Ra), Promise.reject()) : (G.delta && i.go(-G.delta, !1), v(ee, z, re))).then(ee => {
                ee = ee || O(z, re, !1), ee && (G.delta && !qi(ee, 8) ? i.go(-G.delta, !1) : G.type === ka.pop && qi(ee, 4 | 16) && i.go(-1, !1)), ce(z, re, ee)
            }).catch(Ra)
        }))
    }
    let a = Ca(),
        c = Ca(),
        g;

    function v(E, R, G) {
        b(E);
        const z = c.list();
        return z.length ? z.forEach(j => j(E, R, G)) : console.error(E), Promise.reject(E)
    }

    function x() {
        return g && l.value !== ys ? Promise.resolve() : new Promise((E, R) => {
            a.add([E, R])
        })
    }

    function b(E) {
        return g || (g = !E, m(), a.list().forEach(([R, G]) => E ? G(E) : R()), a.reset()), E
    }

    function y(E, R, G, z) {
        const {
            scrollBehavior: j
        } = t;
        if (!Ro || !j) return Promise.resolve();
        const re = !G && s3(Jm(E.fullPath, 0)) || (z || !G) && history.state && history.state.scroll || null;
        return Z0().then(() => j(E, R, re)).then(ee => ee && n3(ee)).catch(ee => v(ee, E, R))
    }
    const h = E => i.go(E);
    let u;
    const _ = new Set,
        L = {
            currentRoute: l,
            listening: !0,
            addRoute: N,
            removeRoute: P,
            hasRoute: S,
            getRoutes: C,
            resolve: k,
            options: t,
            push: M,
            replace: F,
            go: h,
            back: () => h(-1),
            forward: () => h(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: f.add,
            onError: c.add,
            isReady: x,
            install(E) {
                const R = this;
                E.component("RouterLink", G3), E.component("RouterView", j3), E.config.globalProperties.$router = R, Object.defineProperty(E.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => Us(l)
                }), Ro && !u && l.value === ys && (u = !0, M(i.location).catch(j => {}));
                const G = {};
                for (const j in ys) G[j] = br(() => l.value[j]);
                E.provide(bu, R), E.provide(lc, wo(G)), E.provide(cc, l);
                const z = E.unmount;
                _.add(E), E.unmount = function() {
                    _.delete(E), _.size < 1 && (d = ys, w && w(), w = null, l.value = ys, u = !1, g = !1), z()
                }
            }
        };
    return L
}

function Co(t) {
    return t.reduce((e, r) => e.then(() => r()), Promise.resolve())
}

function W3(t, e) {
    const r = [],
        n = [],
        i = [],
        s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
        const f = e.matched[o];
        f && (t.matched.find(d => ko(d, f)) ? n.push(f) : r.push(f));
        const l = t.matched[o];
        l && (e.matched.find(d => ko(d, l)) || i.push(l))
    }
    return [r, n, i]
}

function OS() {
    return fi(bu)
}

function CS() {
    return fi(lc)
}
var vu = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function V3(t) {
    if (t.__esModule) return t;
    var e = Object.defineProperty({}, "__esModule", {
        value: !0
    });
    return Object.keys(t).forEach(function(r) {
        var n = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(e, r, n.get ? n : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), e
}
var by = {
    exports: {}
};
(function(t) {
    (function(e, r) {
        function n(O, w) {
            if (!O) throw new Error(w || "Assertion failed")
        }

        function i(O, w) {
            O.super_ = w;
            var m = function() {};
            m.prototype = w.prototype, O.prototype = new m, O.prototype.constructor = O
        }

        function s(O, w, m) {
            if (s.isBN(O)) return O;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, O !== null && ((w === "le" || w === "be") && (m = w, w = 10), this._init(O || 0, w || 10, m || "be"))
        }
        typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
        var o;
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = require("buffer").Buffer
        } catch {}
        s.isBN = function(w) {
            return w instanceof s ? !0 : w !== null && typeof w == "object" && w.constructor.wordSize === s.wordSize && Array.isArray(w.words)
        }, s.max = function(w, m) {
            return w.cmp(m) > 0 ? w : m
        }, s.min = function(w, m) {
            return w.cmp(m) < 0 ? w : m
        }, s.prototype._init = function(w, m, a) {
            if (typeof w == "number") return this._initNumber(w, m, a);
            if (typeof w == "object") return this._initArray(w, m, a);
            m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), w = w.toString().replace(/\s+/g, "");
            var c = 0;
            w[0] === "-" && (c++, this.negative = 1), c < w.length && (m === 16 ? this._parseHex(w, c, a) : (this._parseBase(w, m, c), a === "le" && this._initArray(this.toArray(), m, a)))
        }, s.prototype._initNumber = function(w, m, a) {
            w < 0 && (this.negative = 1, w = -w), w < 67108864 ? (this.words = [w & 67108863], this.length = 1) : w < 4503599627370496 ? (this.words = [w & 67108863, w / 67108864 & 67108863], this.length = 2) : (n(w < 9007199254740992), this.words = [w & 67108863, w / 67108864 & 67108863, 1], this.length = 3), a === "le" && this._initArray(this.toArray(), m, a)
        }, s.prototype._initArray = function(w, m, a) {
            if (n(typeof w.length == "number"), w.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(w.length / 3), this.words = new Array(this.length);
            for (var c = 0; c < this.length; c++) this.words[c] = 0;
            var g, v, x = 0;
            if (a === "be")
                for (c = w.length - 1, g = 0; c >= 0; c -= 3) v = w[c] | w[c - 1] << 8 | w[c - 2] << 16, this.words[g] |= v << x & 67108863, this.words[g + 1] = v >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, g++);
            else if (a === "le")
                for (c = 0, g = 0; c < w.length; c += 3) v = w[c] | w[c + 1] << 8 | w[c + 2] << 16, this.words[g] |= v << x & 67108863, this.words[g + 1] = v >>> 26 - x & 67108863, x += 24, x >= 26 && (x -= 26, g++);
            return this.strip()
        };

        function f(O, w) {
            var m = O.charCodeAt(w);
            return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15
        }

        function l(O, w, m) {
            var a = f(O, m);
            return m - 1 >= w && (a |= f(O, m - 1) << 4), a
        }
        s.prototype._parseHex = function(w, m, a) {
            this.length = Math.ceil((w.length - m) / 6), this.words = new Array(this.length);
            for (var c = 0; c < this.length; c++) this.words[c] = 0;
            var g = 0,
                v = 0,
                x;
            if (a === "be")
                for (c = w.length - 1; c >= m; c -= 2) x = l(w, m, c) << g, this.words[v] |= x & 67108863, g >= 18 ? (g -= 18, v += 1, this.words[v] |= x >>> 26) : g += 8;
            else {
                var b = w.length - m;
                for (c = b % 2 == 0 ? m + 1 : m; c < w.length; c += 2) x = l(w, m, c) << g, this.words[v] |= x & 67108863, g >= 18 ? (g -= 18, v += 1, this.words[v] |= x >>> 26) : g += 8
            }
            this.strip()
        };

        function d(O, w, m, a) {
            for (var c = 0, g = Math.min(O.length, m), v = w; v < g; v++) {
                var x = O.charCodeAt(v) - 48;
                c *= a, x >= 49 ? c += x - 49 + 10 : x >= 17 ? c += x - 17 + 10 : c += x
            }
            return c
        }
        s.prototype._parseBase = function(w, m, a) {
            this.words = [0], this.length = 1;
            for (var c = 0, g = 1; g <= 67108863; g *= m) c++;
            c--, g = g / m | 0;
            for (var v = w.length - a, x = v % c, b = Math.min(v, v - x) + a, y = 0, h = a; h < b; h += c) y = d(w, h, h + c, m), this.imuln(g), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
            if (x !== 0) {
                var u = 1;
                for (y = d(w, h, w.length, m), h = 0; h < x; h++) u *= m;
                this.imuln(u), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y)
            }
            this.strip()
        }, s.prototype.copy = function(w) {
            w.words = new Array(this.length);
            for (var m = 0; m < this.length; m++) w.words[m] = this.words[m];
            w.length = this.length, w.negative = this.negative, w.red = this.red
        }, s.prototype.clone = function() {
            var w = new s(null);
            return this.copy(w), w
        }, s.prototype._expand = function(w) {
            for (; this.length < w;) this.words[this.length++] = 0;
            return this
        }, s.prototype.strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
            return this._normSign()
        }, s.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
        }, s.prototype.inspect = function() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        };
        var p = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            A = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            T = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(w, m) {
            w = w || 10, m = m | 0 || 1;
            var a;
            if (w === 16 || w === "hex") {
                a = "";
                for (var c = 0, g = 0, v = 0; v < this.length; v++) {
                    var x = this.words[v],
                        b = ((x << c | g) & 16777215).toString(16);
                    g = x >>> 24 - c & 16777215, g !== 0 || v !== this.length - 1 ? a = p[6 - b.length] + b + a : a = b + a, c += 2, c >= 26 && (c -= 26, v--)
                }
                for (g !== 0 && (a = g.toString(16) + a); a.length % m != 0;) a = "0" + a;
                return this.negative !== 0 && (a = "-" + a), a
            }
            if (w === (w | 0) && w >= 2 && w <= 36) {
                var y = A[w],
                    h = T[w];
                a = "";
                var u = this.clone();
                for (u.negative = 0; !u.isZero();) {
                    var _ = u.modn(h).toString(w);
                    u = u.idivn(h), u.isZero() ? a = _ + a : a = p[y - _.length] + _ + a
                }
                for (this.isZero() && (a = "0" + a); a.length % m != 0;) a = "0" + a;
                return this.negative !== 0 && (a = "-" + a), a
            }
            n(!1, "Base should be between 2 and 36")
        }, s.prototype.toNumber = function() {
            var w = this.words[0];
            return this.length === 2 ? w += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? w += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -w : w
        }, s.prototype.toJSON = function() {
            return this.toString(16)
        }, s.prototype.toBuffer = function(w, m) {
            return n(typeof o != "undefined"), this.toArrayLike(o, w, m)
        }, s.prototype.toArray = function(w, m) {
            return this.toArrayLike(Array, w, m)
        }, s.prototype.toArrayLike = function(w, m, a) {
            var c = this.byteLength(),
                g = a || Math.max(1, c);
            n(c <= g, "byte array longer than desired length"), n(g > 0, "Requested array length <= 0"), this.strip();
            var v = m === "le",
                x = new w(g),
                b, y, h = this.clone();
            if (v) {
                for (y = 0; !h.isZero(); y++) b = h.andln(255), h.iushrn(8), x[y] = b;
                for (; y < g; y++) x[y] = 0
            } else {
                for (y = 0; y < g - c; y++) x[y] = 0;
                for (y = 0; !h.isZero(); y++) b = h.andln(255), h.iushrn(8), x[g - y - 1] = b
            }
            return x
        }, Math.clz32 ? s.prototype._countBits = function(w) {
            return 32 - Math.clz32(w)
        } : s.prototype._countBits = function(w) {
            var m = w,
                a = 0;
            return m >= 4096 && (a += 13, m >>>= 13), m >= 64 && (a += 7, m >>>= 7), m >= 8 && (a += 4, m >>>= 4), m >= 2 && (a += 2, m >>>= 2), a + m
        }, s.prototype._zeroBits = function(w) {
            if (w === 0) return 26;
            var m = w,
                a = 0;
            return (m & 8191) == 0 && (a += 13, m >>>= 13), (m & 127) == 0 && (a += 7, m >>>= 7), (m & 15) == 0 && (a += 4, m >>>= 4), (m & 3) == 0 && (a += 2, m >>>= 2), (m & 1) == 0 && a++, a
        }, s.prototype.bitLength = function() {
            var w = this.words[this.length - 1],
                m = this._countBits(w);
            return (this.length - 1) * 26 + m
        };

        function N(O) {
            for (var w = new Array(O.bitLength()), m = 0; m < w.length; m++) {
                var a = m / 26 | 0,
                    c = m % 26;
                w[m] = (O.words[a] & 1 << c) >>> c
            }
            return w
        }
        s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var w = 0, m = 0; m < this.length; m++) {
                var a = this._zeroBits(this.words[m]);
                if (w += a, a !== 26) break
            }
            return w
        }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, s.prototype.toTwos = function(w) {
            return this.negative !== 0 ? this.abs().inotn(w).iaddn(1) : this.clone()
        }, s.prototype.fromTwos = function(w) {
            return this.testn(w - 1) ? this.notn(w).iaddn(1).ineg() : this.clone()
        }, s.prototype.isNeg = function() {
            return this.negative !== 0
        }, s.prototype.neg = function() {
            return this.clone().ineg()
        }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, s.prototype.iuor = function(w) {
            for (; this.length < w.length;) this.words[this.length++] = 0;
            for (var m = 0; m < w.length; m++) this.words[m] = this.words[m] | w.words[m];
            return this.strip()
        }, s.prototype.ior = function(w) {
            return n((this.negative | w.negative) == 0), this.iuor(w)
        }, s.prototype.or = function(w) {
            return this.length > w.length ? this.clone().ior(w) : w.clone().ior(this)
        }, s.prototype.uor = function(w) {
            return this.length > w.length ? this.clone().iuor(w) : w.clone().iuor(this)
        }, s.prototype.iuand = function(w) {
            var m;
            this.length > w.length ? m = w : m = this;
            for (var a = 0; a < m.length; a++) this.words[a] = this.words[a] & w.words[a];
            return this.length = m.length, this.strip()
        }, s.prototype.iand = function(w) {
            return n((this.negative | w.negative) == 0), this.iuand(w)
        }, s.prototype.and = function(w) {
            return this.length > w.length ? this.clone().iand(w) : w.clone().iand(this)
        }, s.prototype.uand = function(w) {
            return this.length > w.length ? this.clone().iuand(w) : w.clone().iuand(this)
        }, s.prototype.iuxor = function(w) {
            var m, a;
            this.length > w.length ? (m = this, a = w) : (m = w, a = this);
            for (var c = 0; c < a.length; c++) this.words[c] = m.words[c] ^ a.words[c];
            if (this !== m)
                for (; c < m.length; c++) this.words[c] = m.words[c];
            return this.length = m.length, this.strip()
        }, s.prototype.ixor = function(w) {
            return n((this.negative | w.negative) == 0), this.iuxor(w)
        }, s.prototype.xor = function(w) {
            return this.length > w.length ? this.clone().ixor(w) : w.clone().ixor(this)
        }, s.prototype.uxor = function(w) {
            return this.length > w.length ? this.clone().iuxor(w) : w.clone().iuxor(this)
        }, s.prototype.inotn = function(w) {
            n(typeof w == "number" && w >= 0);
            var m = Math.ceil(w / 26) | 0,
                a = w % 26;
            this._expand(m), a > 0 && m--;
            for (var c = 0; c < m; c++) this.words[c] = ~this.words[c] & 67108863;
            return a > 0 && (this.words[c] = ~this.words[c] & 67108863 >> 26 - a), this.strip()
        }, s.prototype.notn = function(w) {
            return this.clone().inotn(w)
        }, s.prototype.setn = function(w, m) {
            n(typeof w == "number" && w >= 0);
            var a = w / 26 | 0,
                c = w % 26;
            return this._expand(a + 1), m ? this.words[a] = this.words[a] | 1 << c : this.words[a] = this.words[a] & ~(1 << c), this.strip()
        }, s.prototype.iadd = function(w) {
            var m;
            if (this.negative !== 0 && w.negative === 0) return this.negative = 0, m = this.isub(w), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && w.negative !== 0) return w.negative = 0, m = this.isub(w), w.negative = 1, m._normSign();
            var a, c;
            this.length > w.length ? (a = this, c = w) : (a = w, c = this);
            for (var g = 0, v = 0; v < c.length; v++) m = (a.words[v] | 0) + (c.words[v] | 0) + g, this.words[v] = m & 67108863, g = m >>> 26;
            for (; g !== 0 && v < a.length; v++) m = (a.words[v] | 0) + g, this.words[v] = m & 67108863, g = m >>> 26;
            if (this.length = a.length, g !== 0) this.words[this.length] = g, this.length++;
            else if (a !== this)
                for (; v < a.length; v++) this.words[v] = a.words[v];
            return this
        }, s.prototype.add = function(w) {
            var m;
            return w.negative !== 0 && this.negative === 0 ? (w.negative = 0, m = this.sub(w), w.negative ^= 1, m) : w.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = w.sub(this), this.negative = 1, m) : this.length > w.length ? this.clone().iadd(w) : w.clone().iadd(this)
        }, s.prototype.isub = function(w) {
            if (w.negative !== 0) {
                w.negative = 0;
                var m = this.iadd(w);
                return w.negative = 1, m._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(w), this.negative = 1, this._normSign();
            var a = this.cmp(w);
            if (a === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var c, g;
            a > 0 ? (c = this, g = w) : (c = w, g = this);
            for (var v = 0, x = 0; x < g.length; x++) m = (c.words[x] | 0) - (g.words[x] | 0) + v, v = m >> 26, this.words[x] = m & 67108863;
            for (; v !== 0 && x < c.length; x++) m = (c.words[x] | 0) + v, v = m >> 26, this.words[x] = m & 67108863;
            if (v === 0 && x < c.length && c !== this)
                for (; x < c.length; x++) this.words[x] = c.words[x];
            return this.length = Math.max(this.length, x), c !== this && (this.negative = 1), this.strip()
        }, s.prototype.sub = function(w) {
            return this.clone().isub(w)
        };

        function P(O, w, m) {
            m.negative = w.negative ^ O.negative;
            var a = O.length + w.length | 0;
            m.length = a, a = a - 1 | 0;
            var c = O.words[0] | 0,
                g = w.words[0] | 0,
                v = c * g,
                x = v & 67108863,
                b = v / 67108864 | 0;
            m.words[0] = x;
            for (var y = 1; y < a; y++) {
                for (var h = b >>> 26, u = b & 67108863, _ = Math.min(y, w.length - 1), L = Math.max(0, y - O.length + 1); L <= _; L++) {
                    var E = y - L | 0;
                    c = O.words[E] | 0, g = w.words[L] | 0, v = c * g + u, h += v / 67108864 | 0, u = v & 67108863
                }
                m.words[y] = u | 0, b = h | 0
            }
            return b !== 0 ? m.words[y] = b | 0 : m.length--, m.strip()
        }
        var C = function(w, m, a) {
            var c = w.words,
                g = m.words,
                v = a.words,
                x = 0,
                b, y, h, u = c[0] | 0,
                _ = u & 8191,
                L = u >>> 13,
                E = c[1] | 0,
                R = E & 8191,
                G = E >>> 13,
                z = c[2] | 0,
                j = z & 8191,
                re = z >>> 13,
                ee = c[3] | 0,
                K = ee & 8191,
                B = ee >>> 13,
                $ = c[4] | 0,
                H = $ & 8191,
                ne = $ >>> 13,
                J = c[5] | 0,
                Y = J & 8191,
                ue = J >>> 13,
                te = c[6] | 0,
                Z = te & 8191,
                se = te >>> 13,
                fe = c[7] | 0,
                ie = fe & 8191,
                me = fe >>> 13,
                he = c[8] | 0,
                le = he & 8191,
                Pe = he >>> 13,
                xe = c[9] | 0,
                de = xe & 8191,
                je = xe >>> 13,
                Ie = g[0] | 0,
                be = Ie & 8191,
                X = Ie >>> 13,
                ae = g[1] | 0,
                oe = ae & 8191,
                ve = ae >>> 13,
                ye = g[2] | 0,
                ge = ye & 8191,
                Ve = ye >>> 13,
                ke = g[3] | 0,
                Ae = ke & 8191,
                et = ke >>> 13,
                Oe = g[4] | 0,
                we = Oe & 8191,
                rt = Oe >>> 13,
                Fe = g[5] | 0,
                Ee = Fe & 8191,
                it = Fe >>> 13,
                Le = g[6] | 0,
                _e = Le & 8191,
                bt = Le >>> 13,
                Be = g[7] | 0,
                Te = Be & 8191,
                vt = Be >>> 13,
                $e = g[8] | 0,
                Me = $e & 8191,
                wt = $e >>> 13,
                Ge = g[9] | 0,
                Ne = Ge & 8191,
                Et = Ge >>> 13;
            a.negative = w.negative ^ m.negative, a.length = 19, b = Math.imul(_, be), y = Math.imul(_, X), y = y + Math.imul(L, be) | 0, h = Math.imul(L, X);
            var De = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (De >>> 26) | 0, De &= 67108863, b = Math.imul(R, be), y = Math.imul(R, X), y = y + Math.imul(G, be) | 0, h = Math.imul(G, X), b = b + Math.imul(_, oe) | 0, y = y + Math.imul(_, ve) | 0, y = y + Math.imul(L, oe) | 0, h = h + Math.imul(L, ve) | 0;
            var Ue = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, b = Math.imul(j, be), y = Math.imul(j, X), y = y + Math.imul(re, be) | 0, h = Math.imul(re, X), b = b + Math.imul(R, oe) | 0, y = y + Math.imul(R, ve) | 0, y = y + Math.imul(G, oe) | 0, h = h + Math.imul(G, ve) | 0, b = b + Math.imul(_, ge) | 0, y = y + Math.imul(_, Ve) | 0, y = y + Math.imul(L, ge) | 0, h = h + Math.imul(L, Ve) | 0;
            var pr = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, b = Math.imul(K, be), y = Math.imul(K, X), y = y + Math.imul(B, be) | 0, h = Math.imul(B, X), b = b + Math.imul(j, oe) | 0, y = y + Math.imul(j, ve) | 0, y = y + Math.imul(re, oe) | 0, h = h + Math.imul(re, ve) | 0, b = b + Math.imul(R, ge) | 0, y = y + Math.imul(R, Ve) | 0, y = y + Math.imul(G, ge) | 0, h = h + Math.imul(G, Ve) | 0, b = b + Math.imul(_, Ae) | 0, y = y + Math.imul(_, et) | 0, y = y + Math.imul(L, Ae) | 0, h = h + Math.imul(L, et) | 0;
            var mr = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (mr >>> 26) | 0, mr &= 67108863, b = Math.imul(H, be), y = Math.imul(H, X), y = y + Math.imul(ne, be) | 0, h = Math.imul(ne, X), b = b + Math.imul(K, oe) | 0, y = y + Math.imul(K, ve) | 0, y = y + Math.imul(B, oe) | 0, h = h + Math.imul(B, ve) | 0, b = b + Math.imul(j, ge) | 0, y = y + Math.imul(j, Ve) | 0, y = y + Math.imul(re, ge) | 0, h = h + Math.imul(re, Ve) | 0, b = b + Math.imul(R, Ae) | 0, y = y + Math.imul(R, et) | 0, y = y + Math.imul(G, Ae) | 0, h = h + Math.imul(G, et) | 0, b = b + Math.imul(_, we) | 0, y = y + Math.imul(_, rt) | 0, y = y + Math.imul(L, we) | 0, h = h + Math.imul(L, rt) | 0;
            var yr = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, b = Math.imul(Y, be), y = Math.imul(Y, X), y = y + Math.imul(ue, be) | 0, h = Math.imul(ue, X), b = b + Math.imul(H, oe) | 0, y = y + Math.imul(H, ve) | 0, y = y + Math.imul(ne, oe) | 0, h = h + Math.imul(ne, ve) | 0, b = b + Math.imul(K, ge) | 0, y = y + Math.imul(K, Ve) | 0, y = y + Math.imul(B, ge) | 0, h = h + Math.imul(B, Ve) | 0, b = b + Math.imul(j, Ae) | 0, y = y + Math.imul(j, et) | 0, y = y + Math.imul(re, Ae) | 0, h = h + Math.imul(re, et) | 0, b = b + Math.imul(R, we) | 0, y = y + Math.imul(R, rt) | 0, y = y + Math.imul(G, we) | 0, h = h + Math.imul(G, rt) | 0, b = b + Math.imul(_, Ee) | 0, y = y + Math.imul(_, it) | 0, y = y + Math.imul(L, Ee) | 0, h = h + Math.imul(L, it) | 0;
            var gr = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, b = Math.imul(Z, be), y = Math.imul(Z, X), y = y + Math.imul(se, be) | 0, h = Math.imul(se, X), b = b + Math.imul(Y, oe) | 0, y = y + Math.imul(Y, ve) | 0, y = y + Math.imul(ue, oe) | 0, h = h + Math.imul(ue, ve) | 0, b = b + Math.imul(H, ge) | 0, y = y + Math.imul(H, Ve) | 0, y = y + Math.imul(ne, ge) | 0, h = h + Math.imul(ne, Ve) | 0, b = b + Math.imul(K, Ae) | 0, y = y + Math.imul(K, et) | 0, y = y + Math.imul(B, Ae) | 0, h = h + Math.imul(B, et) | 0, b = b + Math.imul(j, we) | 0, y = y + Math.imul(j, rt) | 0, y = y + Math.imul(re, we) | 0, h = h + Math.imul(re, rt) | 0, b = b + Math.imul(R, Ee) | 0, y = y + Math.imul(R, it) | 0, y = y + Math.imul(G, Ee) | 0, h = h + Math.imul(G, it) | 0, b = b + Math.imul(_, _e) | 0, y = y + Math.imul(_, bt) | 0, y = y + Math.imul(L, _e) | 0, h = h + Math.imul(L, bt) | 0;
            var xr = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, b = Math.imul(ie, be), y = Math.imul(ie, X), y = y + Math.imul(me, be) | 0, h = Math.imul(me, X), b = b + Math.imul(Z, oe) | 0, y = y + Math.imul(Z, ve) | 0, y = y + Math.imul(se, oe) | 0, h = h + Math.imul(se, ve) | 0, b = b + Math.imul(Y, ge) | 0, y = y + Math.imul(Y, Ve) | 0, y = y + Math.imul(ue, ge) | 0, h = h + Math.imul(ue, Ve) | 0, b = b + Math.imul(H, Ae) | 0, y = y + Math.imul(H, et) | 0, y = y + Math.imul(ne, Ae) | 0, h = h + Math.imul(ne, et) | 0, b = b + Math.imul(K, we) | 0, y = y + Math.imul(K, rt) | 0, y = y + Math.imul(B, we) | 0, h = h + Math.imul(B, rt) | 0, b = b + Math.imul(j, Ee) | 0, y = y + Math.imul(j, it) | 0, y = y + Math.imul(re, Ee) | 0, h = h + Math.imul(re, it) | 0, b = b + Math.imul(R, _e) | 0, y = y + Math.imul(R, bt) | 0, y = y + Math.imul(G, _e) | 0, h = h + Math.imul(G, bt) | 0, b = b + Math.imul(_, Te) | 0, y = y + Math.imul(_, vt) | 0, y = y + Math.imul(L, Te) | 0, h = h + Math.imul(L, vt) | 0;
            var Tn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Tn >>> 26) | 0, Tn &= 67108863, b = Math.imul(le, be), y = Math.imul(le, X), y = y + Math.imul(Pe, be) | 0, h = Math.imul(Pe, X), b = b + Math.imul(ie, oe) | 0, y = y + Math.imul(ie, ve) | 0, y = y + Math.imul(me, oe) | 0, h = h + Math.imul(me, ve) | 0, b = b + Math.imul(Z, ge) | 0, y = y + Math.imul(Z, Ve) | 0, y = y + Math.imul(se, ge) | 0, h = h + Math.imul(se, Ve) | 0, b = b + Math.imul(Y, Ae) | 0, y = y + Math.imul(Y, et) | 0, y = y + Math.imul(ue, Ae) | 0, h = h + Math.imul(ue, et) | 0, b = b + Math.imul(H, we) | 0, y = y + Math.imul(H, rt) | 0, y = y + Math.imul(ne, we) | 0, h = h + Math.imul(ne, rt) | 0, b = b + Math.imul(K, Ee) | 0, y = y + Math.imul(K, it) | 0, y = y + Math.imul(B, Ee) | 0, h = h + Math.imul(B, it) | 0, b = b + Math.imul(j, _e) | 0, y = y + Math.imul(j, bt) | 0, y = y + Math.imul(re, _e) | 0, h = h + Math.imul(re, bt) | 0, b = b + Math.imul(R, Te) | 0, y = y + Math.imul(R, vt) | 0, y = y + Math.imul(G, Te) | 0, h = h + Math.imul(G, vt) | 0, b = b + Math.imul(_, Me) | 0, y = y + Math.imul(_, wt) | 0, y = y + Math.imul(L, Me) | 0, h = h + Math.imul(L, wt) | 0;
            var Mn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, b = Math.imul(de, be), y = Math.imul(de, X), y = y + Math.imul(je, be) | 0, h = Math.imul(je, X), b = b + Math.imul(le, oe) | 0, y = y + Math.imul(le, ve) | 0, y = y + Math.imul(Pe, oe) | 0, h = h + Math.imul(Pe, ve) | 0, b = b + Math.imul(ie, ge) | 0, y = y + Math.imul(ie, Ve) | 0, y = y + Math.imul(me, ge) | 0, h = h + Math.imul(me, Ve) | 0, b = b + Math.imul(Z, Ae) | 0, y = y + Math.imul(Z, et) | 0, y = y + Math.imul(se, Ae) | 0, h = h + Math.imul(se, et) | 0, b = b + Math.imul(Y, we) | 0, y = y + Math.imul(Y, rt) | 0, y = y + Math.imul(ue, we) | 0, h = h + Math.imul(ue, rt) | 0, b = b + Math.imul(H, Ee) | 0, y = y + Math.imul(H, it) | 0, y = y + Math.imul(ne, Ee) | 0, h = h + Math.imul(ne, it) | 0, b = b + Math.imul(K, _e) | 0, y = y + Math.imul(K, bt) | 0, y = y + Math.imul(B, _e) | 0, h = h + Math.imul(B, bt) | 0, b = b + Math.imul(j, Te) | 0, y = y + Math.imul(j, vt) | 0, y = y + Math.imul(re, Te) | 0, h = h + Math.imul(re, vt) | 0, b = b + Math.imul(R, Me) | 0, y = y + Math.imul(R, wt) | 0, y = y + Math.imul(G, Me) | 0, h = h + Math.imul(G, wt) | 0, b = b + Math.imul(_, Ne) | 0, y = y + Math.imul(_, Et) | 0, y = y + Math.imul(L, Ne) | 0, h = h + Math.imul(L, Et) | 0;
            var Nn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, b = Math.imul(de, oe), y = Math.imul(de, ve), y = y + Math.imul(je, oe) | 0, h = Math.imul(je, ve), b = b + Math.imul(le, ge) | 0, y = y + Math.imul(le, Ve) | 0, y = y + Math.imul(Pe, ge) | 0, h = h + Math.imul(Pe, Ve) | 0, b = b + Math.imul(ie, Ae) | 0, y = y + Math.imul(ie, et) | 0, y = y + Math.imul(me, Ae) | 0, h = h + Math.imul(me, et) | 0, b = b + Math.imul(Z, we) | 0, y = y + Math.imul(Z, rt) | 0, y = y + Math.imul(se, we) | 0, h = h + Math.imul(se, rt) | 0, b = b + Math.imul(Y, Ee) | 0, y = y + Math.imul(Y, it) | 0, y = y + Math.imul(ue, Ee) | 0, h = h + Math.imul(ue, it) | 0, b = b + Math.imul(H, _e) | 0, y = y + Math.imul(H, bt) | 0, y = y + Math.imul(ne, _e) | 0, h = h + Math.imul(ne, bt) | 0, b = b + Math.imul(K, Te) | 0, y = y + Math.imul(K, vt) | 0, y = y + Math.imul(B, Te) | 0, h = h + Math.imul(B, vt) | 0, b = b + Math.imul(j, Me) | 0, y = y + Math.imul(j, wt) | 0, y = y + Math.imul(re, Me) | 0, h = h + Math.imul(re, wt) | 0, b = b + Math.imul(R, Ne) | 0, y = y + Math.imul(R, Et) | 0, y = y + Math.imul(G, Ne) | 0, h = h + Math.imul(G, Et) | 0;
            var Sn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, b = Math.imul(de, ge), y = Math.imul(de, Ve), y = y + Math.imul(je, ge) | 0, h = Math.imul(je, Ve), b = b + Math.imul(le, Ae) | 0, y = y + Math.imul(le, et) | 0, y = y + Math.imul(Pe, Ae) | 0, h = h + Math.imul(Pe, et) | 0, b = b + Math.imul(ie, we) | 0, y = y + Math.imul(ie, rt) | 0, y = y + Math.imul(me, we) | 0, h = h + Math.imul(me, rt) | 0, b = b + Math.imul(Z, Ee) | 0, y = y + Math.imul(Z, it) | 0, y = y + Math.imul(se, Ee) | 0, h = h + Math.imul(se, it) | 0, b = b + Math.imul(Y, _e) | 0, y = y + Math.imul(Y, bt) | 0, y = y + Math.imul(ue, _e) | 0, h = h + Math.imul(ue, bt) | 0, b = b + Math.imul(H, Te) | 0, y = y + Math.imul(H, vt) | 0, y = y + Math.imul(ne, Te) | 0, h = h + Math.imul(ne, vt) | 0, b = b + Math.imul(K, Me) | 0, y = y + Math.imul(K, wt) | 0, y = y + Math.imul(B, Me) | 0, h = h + Math.imul(B, wt) | 0, b = b + Math.imul(j, Ne) | 0, y = y + Math.imul(j, Et) | 0, y = y + Math.imul(re, Ne) | 0, h = h + Math.imul(re, Et) | 0;
            var Pn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, b = Math.imul(de, Ae), y = Math.imul(de, et), y = y + Math.imul(je, Ae) | 0, h = Math.imul(je, et), b = b + Math.imul(le, we) | 0, y = y + Math.imul(le, rt) | 0, y = y + Math.imul(Pe, we) | 0, h = h + Math.imul(Pe, rt) | 0, b = b + Math.imul(ie, Ee) | 0, y = y + Math.imul(ie, it) | 0, y = y + Math.imul(me, Ee) | 0, h = h + Math.imul(me, it) | 0, b = b + Math.imul(Z, _e) | 0, y = y + Math.imul(Z, bt) | 0, y = y + Math.imul(se, _e) | 0, h = h + Math.imul(se, bt) | 0, b = b + Math.imul(Y, Te) | 0, y = y + Math.imul(Y, vt) | 0, y = y + Math.imul(ue, Te) | 0, h = h + Math.imul(ue, vt) | 0, b = b + Math.imul(H, Me) | 0, y = y + Math.imul(H, wt) | 0, y = y + Math.imul(ne, Me) | 0, h = h + Math.imul(ne, wt) | 0, b = b + Math.imul(K, Ne) | 0, y = y + Math.imul(K, Et) | 0, y = y + Math.imul(B, Ne) | 0, h = h + Math.imul(B, Et) | 0;
            var In = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, b = Math.imul(de, we), y = Math.imul(de, rt), y = y + Math.imul(je, we) | 0, h = Math.imul(je, rt), b = b + Math.imul(le, Ee) | 0, y = y + Math.imul(le, it) | 0, y = y + Math.imul(Pe, Ee) | 0, h = h + Math.imul(Pe, it) | 0, b = b + Math.imul(ie, _e) | 0, y = y + Math.imul(ie, bt) | 0, y = y + Math.imul(me, _e) | 0, h = h + Math.imul(me, bt) | 0, b = b + Math.imul(Z, Te) | 0, y = y + Math.imul(Z, vt) | 0, y = y + Math.imul(se, Te) | 0, h = h + Math.imul(se, vt) | 0, b = b + Math.imul(Y, Me) | 0, y = y + Math.imul(Y, wt) | 0, y = y + Math.imul(ue, Me) | 0, h = h + Math.imul(ue, wt) | 0, b = b + Math.imul(H, Ne) | 0, y = y + Math.imul(H, Et) | 0, y = y + Math.imul(ne, Ne) | 0, h = h + Math.imul(ne, Et) | 0;
            var Rn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863, b = Math.imul(de, Ee), y = Math.imul(de, it), y = y + Math.imul(je, Ee) | 0, h = Math.imul(je, it), b = b + Math.imul(le, _e) | 0, y = y + Math.imul(le, bt) | 0, y = y + Math.imul(Pe, _e) | 0, h = h + Math.imul(Pe, bt) | 0, b = b + Math.imul(ie, Te) | 0, y = y + Math.imul(ie, vt) | 0, y = y + Math.imul(me, Te) | 0, h = h + Math.imul(me, vt) | 0, b = b + Math.imul(Z, Me) | 0, y = y + Math.imul(Z, wt) | 0, y = y + Math.imul(se, Me) | 0, h = h + Math.imul(se, wt) | 0, b = b + Math.imul(Y, Ne) | 0, y = y + Math.imul(Y, Et) | 0, y = y + Math.imul(ue, Ne) | 0, h = h + Math.imul(ue, Et) | 0;
            var kn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, b = Math.imul(de, _e), y = Math.imul(de, bt), y = y + Math.imul(je, _e) | 0, h = Math.imul(je, bt), b = b + Math.imul(le, Te) | 0, y = y + Math.imul(le, vt) | 0, y = y + Math.imul(Pe, Te) | 0, h = h + Math.imul(Pe, vt) | 0, b = b + Math.imul(ie, Me) | 0, y = y + Math.imul(ie, wt) | 0, y = y + Math.imul(me, Me) | 0, h = h + Math.imul(me, wt) | 0, b = b + Math.imul(Z, Ne) | 0, y = y + Math.imul(Z, Et) | 0, y = y + Math.imul(se, Ne) | 0, h = h + Math.imul(se, Et) | 0;
            var On = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (On >>> 26) | 0, On &= 67108863, b = Math.imul(de, Te), y = Math.imul(de, vt), y = y + Math.imul(je, Te) | 0, h = Math.imul(je, vt), b = b + Math.imul(le, Me) | 0, y = y + Math.imul(le, wt) | 0, y = y + Math.imul(Pe, Me) | 0, h = h + Math.imul(Pe, wt) | 0, b = b + Math.imul(ie, Ne) | 0, y = y + Math.imul(ie, Et) | 0, y = y + Math.imul(me, Ne) | 0, h = h + Math.imul(me, Et) | 0;
            var Cn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, b = Math.imul(de, Me), y = Math.imul(de, wt), y = y + Math.imul(je, Me) | 0, h = Math.imul(je, wt), b = b + Math.imul(le, Ne) | 0, y = y + Math.imul(le, Et) | 0, y = y + Math.imul(Pe, Ne) | 0, h = h + Math.imul(Pe, Et) | 0;
            var Fn = (x + b | 0) + ((y & 8191) << 13) | 0;
            x = (h + (y >>> 13) | 0) + (Fn >>> 26) | 0, Fn &= 67108863, b = Math.imul(de, Ne), y = Math.imul(de, Et), y = y + Math.imul(je, Ne) | 0, h = Math.imul(je, Et);
            var Dn = (x + b | 0) + ((y & 8191) << 13) | 0;
            return x = (h + (y >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, v[0] = De, v[1] = Ue, v[2] = pr, v[3] = mr, v[4] = yr, v[5] = gr, v[6] = xr, v[7] = Tn, v[8] = Mn, v[9] = Nn, v[10] = Sn, v[11] = Pn, v[12] = In, v[13] = Rn, v[14] = kn, v[15] = On, v[16] = Cn, v[17] = Fn, v[18] = Dn, x !== 0 && (v[19] = x, a.length++), a
        };
        Math.imul || (C = P);

        function S(O, w, m) {
            m.negative = w.negative ^ O.negative, m.length = O.length + w.length;
            for (var a = 0, c = 0, g = 0; g < m.length - 1; g++) {
                var v = c;
                c = 0;
                for (var x = a & 67108863, b = Math.min(g, w.length - 1), y = Math.max(0, g - O.length + 1); y <= b; y++) {
                    var h = g - y,
                        u = O.words[h] | 0,
                        _ = w.words[y] | 0,
                        L = u * _,
                        E = L & 67108863;
                    v = v + (L / 67108864 | 0) | 0, E = E + x | 0, x = E & 67108863, v = v + (E >>> 26) | 0, c += v >>> 26, v &= 67108863
                }
                m.words[g] = x, a = v, v = c
            }
            return a !== 0 ? m.words[g] = a : m.length--, m.strip()
        }

        function k(O, w, m) {
            var a = new I;
            return a.mulp(O, w, m)
        }
        s.prototype.mulTo = function(w, m) {
            var a, c = this.length + w.length;
            return this.length === 10 && w.length === 10 ? a = C(this, w, m) : c < 63 ? a = P(this, w, m) : c < 1024 ? a = S(this, w, m) : a = k(this, w, m), a
        };

        function I(O, w) {
            this.x = O, this.y = w
        }
        I.prototype.makeRBT = function(w) {
            for (var m = new Array(w), a = s.prototype._countBits(w) - 1, c = 0; c < w; c++) m[c] = this.revBin(c, a, w);
            return m
        }, I.prototype.revBin = function(w, m, a) {
            if (w === 0 || w === a - 1) return w;
            for (var c = 0, g = 0; g < m; g++) c |= (w & 1) << m - g - 1, w >>= 1;
            return c
        }, I.prototype.permute = function(w, m, a, c, g, v) {
            for (var x = 0; x < v; x++) c[x] = m[w[x]], g[x] = a[w[x]]
        }, I.prototype.transform = function(w, m, a, c, g, v) {
            this.permute(v, w, m, a, c, g);
            for (var x = 1; x < g; x <<= 1)
                for (var b = x << 1, y = Math.cos(2 * Math.PI / b), h = Math.sin(2 * Math.PI / b), u = 0; u < g; u += b)
                    for (var _ = y, L = h, E = 0; E < x; E++) {
                        var R = a[u + E],
                            G = c[u + E],
                            z = a[u + E + x],
                            j = c[u + E + x],
                            re = _ * z - L * j;
                        j = _ * j + L * z, z = re, a[u + E] = R + z, c[u + E] = G + j, a[u + E + x] = R - z, c[u + E + x] = G - j, E !== b && (re = y * _ - h * L, L = y * L + h * _, _ = re)
                    }
        }, I.prototype.guessLen13b = function(w, m) {
            var a = Math.max(m, w) | 1,
                c = a & 1,
                g = 0;
            for (a = a / 2 | 0; a; a = a >>> 1) g++;
            return 1 << g + 1 + c
        }, I.prototype.conjugate = function(w, m, a) {
            if (!(a <= 1))
                for (var c = 0; c < a / 2; c++) {
                    var g = w[c];
                    w[c] = w[a - c - 1], w[a - c - 1] = g, g = m[c], m[c] = -m[a - c - 1], m[a - c - 1] = -g
                }
        }, I.prototype.normalize13b = function(w, m) {
            for (var a = 0, c = 0; c < m / 2; c++) {
                var g = Math.round(w[2 * c + 1] / m) * 8192 + Math.round(w[2 * c] / m) + a;
                w[c] = g & 67108863, g < 67108864 ? a = 0 : a = g / 67108864 | 0
            }
            return w
        }, I.prototype.convert13b = function(w, m, a, c) {
            for (var g = 0, v = 0; v < m; v++) g = g + (w[v] | 0), a[2 * v] = g & 8191, g = g >>> 13, a[2 * v + 1] = g & 8191, g = g >>> 13;
            for (v = 2 * m; v < c; ++v) a[v] = 0;
            n(g === 0), n((g & ~8191) == 0)
        }, I.prototype.stub = function(w) {
            for (var m = new Array(w), a = 0; a < w; a++) m[a] = 0;
            return m
        }, I.prototype.mulp = function(w, m, a) {
            var c = 2 * this.guessLen13b(w.length, m.length),
                g = this.makeRBT(c),
                v = this.stub(c),
                x = new Array(c),
                b = new Array(c),
                y = new Array(c),
                h = new Array(c),
                u = new Array(c),
                _ = new Array(c),
                L = a.words;
            L.length = c, this.convert13b(w.words, w.length, x, c), this.convert13b(m.words, m.length, h, c), this.transform(x, v, b, y, c, g), this.transform(h, v, u, _, c, g);
            for (var E = 0; E < c; E++) {
                var R = b[E] * u[E] - y[E] * _[E];
                y[E] = b[E] * _[E] + y[E] * u[E], b[E] = R
            }
            return this.conjugate(b, y, c), this.transform(b, y, L, v, c, g), this.conjugate(L, v, c), this.normalize13b(L, c), a.negative = w.negative ^ m.negative, a.length = w.length + m.length, a.strip()
        }, s.prototype.mul = function(w) {
            var m = new s(null);
            return m.words = new Array(this.length + w.length), this.mulTo(w, m)
        }, s.prototype.mulf = function(w) {
            var m = new s(null);
            return m.words = new Array(this.length + w.length), k(this, w, m)
        }, s.prototype.imul = function(w) {
            return this.clone().mulTo(w, this)
        }, s.prototype.imuln = function(w) {
            n(typeof w == "number"), n(w < 67108864);
            for (var m = 0, a = 0; a < this.length; a++) {
                var c = (this.words[a] | 0) * w,
                    g = (c & 67108863) + (m & 67108863);
                m >>= 26, m += c / 67108864 | 0, m += g >>> 26, this.words[a] = g & 67108863
            }
            return m !== 0 && (this.words[a] = m, this.length++), this
        }, s.prototype.muln = function(w) {
            return this.clone().imuln(w)
        }, s.prototype.sqr = function() {
            return this.mul(this)
        }, s.prototype.isqr = function() {
            return this.imul(this.clone())
        }, s.prototype.pow = function(w) {
            var m = N(w);
            if (m.length === 0) return new s(1);
            for (var a = this, c = 0; c < m.length && m[c] === 0; c++, a = a.sqr());
            if (++c < m.length)
                for (var g = a.sqr(); c < m.length; c++, g = g.sqr()) m[c] !== 0 && (a = a.mul(g));
            return a
        }, s.prototype.iushln = function(w) {
            n(typeof w == "number" && w >= 0);
            var m = w % 26,
                a = (w - m) / 26,
                c = 67108863 >>> 26 - m << 26 - m,
                g;
            if (m !== 0) {
                var v = 0;
                for (g = 0; g < this.length; g++) {
                    var x = this.words[g] & c,
                        b = (this.words[g] | 0) - x << m;
                    this.words[g] = b | v, v = x >>> 26 - m
                }
                v && (this.words[g] = v, this.length++)
            }
            if (a !== 0) {
                for (g = this.length - 1; g >= 0; g--) this.words[g + a] = this.words[g];
                for (g = 0; g < a; g++) this.words[g] = 0;
                this.length += a
            }
            return this.strip()
        }, s.prototype.ishln = function(w) {
            return n(this.negative === 0), this.iushln(w)
        }, s.prototype.iushrn = function(w, m, a) {
            n(typeof w == "number" && w >= 0);
            var c;
            m ? c = (m - m % 26) / 26 : c = 0;
            var g = w % 26,
                v = Math.min((w - g) / 26, this.length),
                x = 67108863 ^ 67108863 >>> g << g,
                b = a;
            if (c -= v, c = Math.max(0, c), b) {
                for (var y = 0; y < v; y++) b.words[y] = this.words[y];
                b.length = v
            }
            if (v !== 0)
                if (this.length > v)
                    for (this.length -= v, y = 0; y < this.length; y++) this.words[y] = this.words[y + v];
                else this.words[0] = 0, this.length = 1;
            var h = 0;
            for (y = this.length - 1; y >= 0 && (h !== 0 || y >= c); y--) {
                var u = this.words[y] | 0;
                this.words[y] = h << 26 - g | u >>> g, h = u & x
            }
            return b && h !== 0 && (b.words[b.length++] = h), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip()
        }, s.prototype.ishrn = function(w, m, a) {
            return n(this.negative === 0), this.iushrn(w, m, a)
        }, s.prototype.shln = function(w) {
            return this.clone().ishln(w)
        }, s.prototype.ushln = function(w) {
            return this.clone().iushln(w)
        }, s.prototype.shrn = function(w) {
            return this.clone().ishrn(w)
        }, s.prototype.ushrn = function(w) {
            return this.clone().iushrn(w)
        }, s.prototype.testn = function(w) {
            n(typeof w == "number" && w >= 0);
            var m = w % 26,
                a = (w - m) / 26,
                c = 1 << m;
            if (this.length <= a) return !1;
            var g = this.words[a];
            return !!(g & c)
        }, s.prototype.imaskn = function(w) {
            n(typeof w == "number" && w >= 0);
            var m = w % 26,
                a = (w - m) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= a) return this;
            if (m !== 0 && a++, this.length = Math.min(a, this.length), m !== 0) {
                var c = 67108863 ^ 67108863 >>> m << m;
                this.words[this.length - 1] &= c
            }
            return this.strip()
        }, s.prototype.maskn = function(w) {
            return this.clone().imaskn(w)
        }, s.prototype.iaddn = function(w) {
            return n(typeof w == "number"), n(w < 67108864), w < 0 ? this.isubn(-w) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < w ? (this.words[0] = w - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(w), this.negative = 1, this) : this._iaddn(w)
        }, s.prototype._iaddn = function(w) {
            this.words[0] += w;
            for (var m = 0; m < this.length && this.words[m] >= 67108864; m++) this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
            return this.length = Math.max(this.length, m + 1), this
        }, s.prototype.isubn = function(w) {
            if (n(typeof w == "number"), n(w < 67108864), w < 0) return this.iaddn(-w);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(w), this.negative = 1, this;
            if (this.words[0] -= w, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var m = 0; m < this.length && this.words[m] < 0; m++) this.words[m] += 67108864, this.words[m + 1] -= 1;
            return this.strip()
        }, s.prototype.addn = function(w) {
            return this.clone().iaddn(w)
        }, s.prototype.subn = function(w) {
            return this.clone().isubn(w)
        }, s.prototype.iabs = function() {
            return this.negative = 0, this
        }, s.prototype.abs = function() {
            return this.clone().iabs()
        }, s.prototype._ishlnsubmul = function(w, m, a) {
            var c = w.length + a,
                g;
            this._expand(c);
            var v, x = 0;
            for (g = 0; g < w.length; g++) {
                v = (this.words[g + a] | 0) + x;
                var b = (w.words[g] | 0) * m;
                v -= b & 67108863, x = (v >> 26) - (b / 67108864 | 0), this.words[g + a] = v & 67108863
            }
            for (; g < this.length - a; g++) v = (this.words[g + a] | 0) + x, x = v >> 26, this.words[g + a] = v & 67108863;
            if (x === 0) return this.strip();
            for (n(x === -1), x = 0, g = 0; g < this.length; g++) v = -(this.words[g] | 0) + x, x = v >> 26, this.words[g] = v & 67108863;
            return this.negative = 1, this.strip()
        }, s.prototype._wordDiv = function(w, m) {
            var a = this.length - w.length,
                c = this.clone(),
                g = w,
                v = g.words[g.length - 1] | 0,
                x = this._countBits(v);
            a = 26 - x, a !== 0 && (g = g.ushln(a), c.iushln(a), v = g.words[g.length - 1] | 0);
            var b = c.length - g.length,
                y;
            if (m !== "mod") {
                y = new s(null), y.length = b + 1, y.words = new Array(y.length);
                for (var h = 0; h < y.length; h++) y.words[h] = 0
            }
            var u = c.clone()._ishlnsubmul(g, 1, b);
            u.negative === 0 && (c = u, y && (y.words[b] = 1));
            for (var _ = b - 1; _ >= 0; _--) {
                var L = (c.words[g.length + _] | 0) * 67108864 + (c.words[g.length + _ - 1] | 0);
                for (L = Math.min(L / v | 0, 67108863), c._ishlnsubmul(g, L, _); c.negative !== 0;) L--, c.negative = 0, c._ishlnsubmul(g, 1, _), c.isZero() || (c.negative ^= 1);
                y && (y.words[_] = L)
            }
            return y && y.strip(), c.strip(), m !== "div" && a !== 0 && c.iushrn(a), {
                div: y || null,
                mod: c
            }
        }, s.prototype.divmod = function(w, m, a) {
            if (n(!w.isZero()), this.isZero()) return {
                div: new s(0),
                mod: new s(0)
            };
            var c, g, v;
            return this.negative !== 0 && w.negative === 0 ? (v = this.neg().divmod(w, m), m !== "mod" && (c = v.div.neg()), m !== "div" && (g = v.mod.neg(), a && g.negative !== 0 && g.iadd(w)), {
                div: c,
                mod: g
            }) : this.negative === 0 && w.negative !== 0 ? (v = this.divmod(w.neg(), m), m !== "mod" && (c = v.div.neg()), {
                div: c,
                mod: v.mod
            }) : (this.negative & w.negative) != 0 ? (v = this.neg().divmod(w.neg(), m), m !== "div" && (g = v.mod.neg(), a && g.negative !== 0 && g.isub(w)), {
                div: v.div,
                mod: g
            }) : w.length > this.length || this.cmp(w) < 0 ? {
                div: new s(0),
                mod: this
            } : w.length === 1 ? m === "div" ? {
                div: this.divn(w.words[0]),
                mod: null
            } : m === "mod" ? {
                div: null,
                mod: new s(this.modn(w.words[0]))
            } : {
                div: this.divn(w.words[0]),
                mod: new s(this.modn(w.words[0]))
            } : this._wordDiv(w, m)
        }, s.prototype.div = function(w) {
            return this.divmod(w, "div", !1).div
        }, s.prototype.mod = function(w) {
            return this.divmod(w, "mod", !1).mod
        }, s.prototype.umod = function(w) {
            return this.divmod(w, "mod", !0).mod
        }, s.prototype.divRound = function(w) {
            var m = this.divmod(w);
            if (m.mod.isZero()) return m.div;
            var a = m.div.negative !== 0 ? m.mod.isub(w) : m.mod,
                c = w.ushrn(1),
                g = w.andln(1),
                v = a.cmp(c);
            return v < 0 || g === 1 && v === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1)
        }, s.prototype.modn = function(w) {
            n(w <= 67108863);
            for (var m = (1 << 26) % w, a = 0, c = this.length - 1; c >= 0; c--) a = (m * a + (this.words[c] | 0)) % w;
            return a
        }, s.prototype.idivn = function(w) {
            n(w <= 67108863);
            for (var m = 0, a = this.length - 1; a >= 0; a--) {
                var c = (this.words[a] | 0) + m * 67108864;
                this.words[a] = c / w | 0, m = c % w
            }
            return this.strip()
        }, s.prototype.divn = function(w) {
            return this.clone().idivn(w)
        }, s.prototype.egcd = function(w) {
            n(w.negative === 0), n(!w.isZero());
            var m = this,
                a = w.clone();
            m.negative !== 0 ? m = m.umod(w) : m = m.clone();
            for (var c = new s(1), g = new s(0), v = new s(0), x = new s(1), b = 0; m.isEven() && a.isEven();) m.iushrn(1), a.iushrn(1), ++b;
            for (var y = a.clone(), h = m.clone(); !m.isZero();) {
                for (var u = 0, _ = 1;
                    (m.words[0] & _) == 0 && u < 26; ++u, _ <<= 1);
                if (u > 0)
                    for (m.iushrn(u); u-- > 0;)(c.isOdd() || g.isOdd()) && (c.iadd(y), g.isub(h)), c.iushrn(1), g.iushrn(1);
                for (var L = 0, E = 1;
                    (a.words[0] & E) == 0 && L < 26; ++L, E <<= 1);
                if (L > 0)
                    for (a.iushrn(L); L-- > 0;)(v.isOdd() || x.isOdd()) && (v.iadd(y), x.isub(h)), v.iushrn(1), x.iushrn(1);
                m.cmp(a) >= 0 ? (m.isub(a), c.isub(v), g.isub(x)) : (a.isub(m), v.isub(c), x.isub(g))
            }
            return {
                a: v,
                b: x,
                gcd: a.iushln(b)
            }
        }, s.prototype._invmp = function(w) {
            n(w.negative === 0), n(!w.isZero());
            var m = this,
                a = w.clone();
            m.negative !== 0 ? m = m.umod(w) : m = m.clone();
            for (var c = new s(1), g = new s(0), v = a.clone(); m.cmpn(1) > 0 && a.cmpn(1) > 0;) {
                for (var x = 0, b = 1;
                    (m.words[0] & b) == 0 && x < 26; ++x, b <<= 1);
                if (x > 0)
                    for (m.iushrn(x); x-- > 0;) c.isOdd() && c.iadd(v), c.iushrn(1);
                for (var y = 0, h = 1;
                    (a.words[0] & h) == 0 && y < 26; ++y, h <<= 1);
                if (y > 0)
                    for (a.iushrn(y); y-- > 0;) g.isOdd() && g.iadd(v), g.iushrn(1);
                m.cmp(a) >= 0 ? (m.isub(a), c.isub(g)) : (a.isub(m), g.isub(c))
            }
            var u;
            return m.cmpn(1) === 0 ? u = c : u = g, u.cmpn(0) < 0 && u.iadd(w), u
        }, s.prototype.gcd = function(w) {
            if (this.isZero()) return w.abs();
            if (w.isZero()) return this.abs();
            var m = this.clone(),
                a = w.clone();
            m.negative = 0, a.negative = 0;
            for (var c = 0; m.isEven() && a.isEven(); c++) m.iushrn(1), a.iushrn(1);
            do {
                for (; m.isEven();) m.iushrn(1);
                for (; a.isEven();) a.iushrn(1);
                var g = m.cmp(a);
                if (g < 0) {
                    var v = m;
                    m = a, a = v
                } else if (g === 0 || a.cmpn(1) === 0) break;
                m.isub(a)
            } while (!0);
            return a.iushln(c)
        }, s.prototype.invm = function(w) {
            return this.egcd(w).a.umod(w)
        }, s.prototype.isEven = function() {
            return (this.words[0] & 1) == 0
        }, s.prototype.isOdd = function() {
            return (this.words[0] & 1) == 1
        }, s.prototype.andln = function(w) {
            return this.words[0] & w
        }, s.prototype.bincn = function(w) {
            n(typeof w == "number");
            var m = w % 26,
                a = (w - m) / 26,
                c = 1 << m;
            if (this.length <= a) return this._expand(a + 1), this.words[a] |= c, this;
            for (var g = c, v = a; g !== 0 && v < this.length; v++) {
                var x = this.words[v] | 0;
                x += g, g = x >>> 26, x &= 67108863, this.words[v] = x
            }
            return g !== 0 && (this.words[v] = g, this.length++), this
        }, s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, s.prototype.cmpn = function(w) {
            var m = w < 0;
            if (this.negative !== 0 && !m) return -1;
            if (this.negative === 0 && m) return 1;
            this.strip();
            var a;
            if (this.length > 1) a = 1;
            else {
                m && (w = -w), n(w <= 67108863, "Number is too big");
                var c = this.words[0] | 0;
                a = c === w ? 0 : c < w ? -1 : 1
            }
            return this.negative !== 0 ? -a | 0 : a
        }, s.prototype.cmp = function(w) {
            if (this.negative !== 0 && w.negative === 0) return -1;
            if (this.negative === 0 && w.negative !== 0) return 1;
            var m = this.ucmp(w);
            return this.negative !== 0 ? -m | 0 : m
        }, s.prototype.ucmp = function(w) {
            if (this.length > w.length) return 1;
            if (this.length < w.length) return -1;
            for (var m = 0, a = this.length - 1; a >= 0; a--) {
                var c = this.words[a] | 0,
                    g = w.words[a] | 0;
                if (c !== g) {
                    c < g ? m = -1 : c > g && (m = 1);
                    break
                }
            }
            return m
        }, s.prototype.gtn = function(w) {
            return this.cmpn(w) === 1
        }, s.prototype.gt = function(w) {
            return this.cmp(w) === 1
        }, s.prototype.gten = function(w) {
            return this.cmpn(w) >= 0
        }, s.prototype.gte = function(w) {
            return this.cmp(w) >= 0
        }, s.prototype.ltn = function(w) {
            return this.cmpn(w) === -1
        }, s.prototype.lt = function(w) {
            return this.cmp(w) === -1
        }, s.prototype.lten = function(w) {
            return this.cmpn(w) <= 0
        }, s.prototype.lte = function(w) {
            return this.cmp(w) <= 0
        }, s.prototype.eqn = function(w) {
            return this.cmpn(w) === 0
        }, s.prototype.eq = function(w) {
            return this.cmp(w) === 0
        }, s.red = function(w) {
            return new Q(w)
        }, s.prototype.toRed = function(w) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), w.convertTo(this)._forceRed(w)
        }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, s.prototype._forceRed = function(w) {
            return this.red = w, this
        }, s.prototype.forceRed = function(w) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(w)
        }, s.prototype.redAdd = function(w) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, w)
        }, s.prototype.redIAdd = function(w) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, w)
        }, s.prototype.redSub = function(w) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, w)
        }, s.prototype.redISub = function(w) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, w)
        }, s.prototype.redShl = function(w) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, w)
        }, s.prototype.redMul = function(w) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, w), this.red.mul(this, w)
        }, s.prototype.redIMul = function(w) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, w), this.red.imul(this, w)
        }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, s.prototype.redPow = function(w) {
            return n(this.red && !w.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, w)
        };
        var U = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function M(O, w) {
            this.name = O, this.p = new s(w, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        M.prototype._tmp = function() {
            var w = new s(null);
            return w.words = new Array(Math.ceil(this.n / 13)), w
        }, M.prototype.ireduce = function(w) {
            var m = w,
                a;
            do this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), a = m.bitLength(); while (a > this.n);
            var c = a < this.n ? -1 : m.ucmp(this.p);
            return c === 0 ? (m.words[0] = 0, m.length = 1) : c > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m
        }, M.prototype.split = function(w, m) {
            w.iushrn(this.n, 0, m)
        }, M.prototype.imulK = function(w) {
            return w.imul(this.k)
        };

        function F() {
            M.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(F, M), F.prototype.split = function(w, m) {
            for (var a = 4194303, c = Math.min(w.length, 9), g = 0; g < c; g++) m.words[g] = w.words[g];
            if (m.length = c, w.length <= 9) {
                w.words[0] = 0, w.length = 1;
                return
            }
            var v = w.words[9];
            for (m.words[m.length++] = v & a, g = 10; g < w.length; g++) {
                var x = w.words[g] | 0;
                w.words[g - 10] = (x & a) << 4 | v >>> 22, v = x
            }
            v >>>= 22, w.words[g - 10] = v, v === 0 && w.length > 10 ? w.length -= 10 : w.length -= 9
        }, F.prototype.imulK = function(w) {
            w.words[w.length] = 0, w.words[w.length + 1] = 0, w.length += 2;
            for (var m = 0, a = 0; a < w.length; a++) {
                var c = w.words[a] | 0;
                m += c * 977, w.words[a] = m & 67108863, m = c * 64 + (m / 67108864 | 0)
            }
            return w.words[w.length - 1] === 0 && (w.length--, w.words[w.length - 1] === 0 && w.length--), w
        };

        function D() {
            M.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(D, M);

        function q() {
            M.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(q, M);

        function V() {
            M.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(V, M), V.prototype.imulK = function(w) {
            for (var m = 0, a = 0; a < w.length; a++) {
                var c = (w.words[a] | 0) * 19 + m,
                    g = c & 67108863;
                c >>>= 26, w.words[a] = g, m = c
            }
            return m !== 0 && (w.words[w.length++] = m), w
        }, s._prime = function(w) {
            if (U[w]) return U[w];
            var m;
            if (w === "k256") m = new F;
            else if (w === "p224") m = new D;
            else if (w === "p192") m = new q;
            else if (w === "p25519") m = new V;
            else throw new Error("Unknown prime " + w);
            return U[w] = m, m
        };

        function Q(O) {
            if (typeof O == "string") {
                var w = s._prime(O);
                this.m = w.p, this.prime = w
            } else n(O.gtn(1), "modulus must be greater than 1"), this.m = O, this.prime = null
        }
        Q.prototype._verify1 = function(w) {
            n(w.negative === 0, "red works only with positives"), n(w.red, "red works only with red numbers")
        }, Q.prototype._verify2 = function(w, m) {
            n((w.negative | m.negative) == 0, "red works only with positives"), n(w.red && w.red === m.red, "red works only with red numbers")
        }, Q.prototype.imod = function(w) {
            return this.prime ? this.prime.ireduce(w)._forceRed(this) : w.umod(this.m)._forceRed(this)
        }, Q.prototype.neg = function(w) {
            return w.isZero() ? w.clone() : this.m.sub(w)._forceRed(this)
        }, Q.prototype.add = function(w, m) {
            this._verify2(w, m);
            var a = w.add(m);
            return a.cmp(this.m) >= 0 && a.isub(this.m), a._forceRed(this)
        }, Q.prototype.iadd = function(w, m) {
            this._verify2(w, m);
            var a = w.iadd(m);
            return a.cmp(this.m) >= 0 && a.isub(this.m), a
        }, Q.prototype.sub = function(w, m) {
            this._verify2(w, m);
            var a = w.sub(m);
            return a.cmpn(0) < 0 && a.iadd(this.m), a._forceRed(this)
        }, Q.prototype.isub = function(w, m) {
            this._verify2(w, m);
            var a = w.isub(m);
            return a.cmpn(0) < 0 && a.iadd(this.m), a
        }, Q.prototype.shl = function(w, m) {
            return this._verify1(w), this.imod(w.ushln(m))
        }, Q.prototype.imul = function(w, m) {
            return this._verify2(w, m), this.imod(w.imul(m))
        }, Q.prototype.mul = function(w, m) {
            return this._verify2(w, m), this.imod(w.mul(m))
        }, Q.prototype.isqr = function(w) {
            return this.imul(w, w.clone())
        }, Q.prototype.sqr = function(w) {
            return this.mul(w, w)
        }, Q.prototype.sqrt = function(w) {
            if (w.isZero()) return w.clone();
            var m = this.m.andln(3);
            if (n(m % 2 == 1), m === 3) {
                var a = this.m.add(new s(1)).iushrn(2);
                return this.pow(w, a)
            }
            for (var c = this.m.subn(1), g = 0; !c.isZero() && c.andln(1) === 0;) g++, c.iushrn(1);
            n(!c.isZero());
            var v = new s(1).toRed(this),
                x = v.redNeg(),
                b = this.m.subn(1).iushrn(1),
                y = this.m.bitLength();
            for (y = new s(2 * y * y).toRed(this); this.pow(y, b).cmp(x) !== 0;) y.redIAdd(x);
            for (var h = this.pow(y, c), u = this.pow(w, c.addn(1).iushrn(1)), _ = this.pow(w, c), L = g; _.cmp(v) !== 0;) {
                for (var E = _, R = 0; E.cmp(v) !== 0; R++) E = E.redSqr();
                n(R < L);
                var G = this.pow(h, new s(1).iushln(L - R - 1));
                u = u.redMul(G), h = G.redSqr(), _ = _.redMul(h), L = R
            }
            return u
        }, Q.prototype.invm = function(w) {
            var m = w._invmp(this.m);
            return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m)
        }, Q.prototype.pow = function(w, m) {
            if (m.isZero()) return new s(1).toRed(this);
            if (m.cmpn(1) === 0) return w.clone();
            var a = 4,
                c = new Array(1 << a);
            c[0] = new s(1).toRed(this), c[1] = w;
            for (var g = 2; g < c.length; g++) c[g] = this.mul(c[g - 1], w);
            var v = c[0],
                x = 0,
                b = 0,
                y = m.bitLength() % 26;
            for (y === 0 && (y = 26), g = m.length - 1; g >= 0; g--) {
                for (var h = m.words[g], u = y - 1; u >= 0; u--) {
                    var _ = h >> u & 1;
                    if (v !== c[0] && (v = this.sqr(v)), _ === 0 && x === 0) {
                        b = 0;
                        continue
                    }
                    x <<= 1, x |= _, b++, !(b !== a && (g !== 0 || u !== 0)) && (v = this.mul(v, c[x]), b = 0, x = 0)
                }
                y = 26
            }
            return v
        }, Q.prototype.convertTo = function(w) {
            var m = w.umod(this.m);
            return m === w ? m.clone() : m
        }, Q.prototype.convertFrom = function(w) {
            var m = w.clone();
            return m.red = null, m
        }, s.mont = function(w) {
            return new ce(w)
        };

        function ce(O) {
            Q.call(this, O), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(ce, Q), ce.prototype.convertTo = function(w) {
            return this.imod(w.ushln(this.shift))
        }, ce.prototype.convertFrom = function(w) {
            var m = this.imod(w.mul(this.rinv));
            return m.red = null, m
        }, ce.prototype.imul = function(w, m) {
            if (w.isZero() || m.isZero()) return w.words[0] = 0, w.length = 1, w;
            var a = w.imul(m),
                c = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = a.isub(c).iushrn(this.shift),
                v = g;
            return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this)
        }, ce.prototype.mul = function(w, m) {
            if (w.isZero() || m.isZero()) return new s(0)._forceRed(this);
            var a = w.mul(m),
                c = a.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                g = a.isub(c).iushrn(this.shift),
                v = g;
            return g.cmp(this.m) >= 0 ? v = g.isub(this.m) : g.cmpn(0) < 0 && (v = g.iadd(this.m)), v._forceRed(this)
        }, ce.prototype.invm = function(w) {
            var m = this.imod(w._invmp(this.m).mul(this.r2));
            return m._forceRed(this)
        }
    })(t, vu)
})(by);
var He = by.exports;
const K3 = "logger/5.5.0";
let vy = !1,
    wy = !1;
const wu = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let Ey = wu.default,
    dc = null;

function X3() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const Ay = X3();
var pc;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(pc || (pc = {}));
var mc;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED"
})(mc || (mc = {}));
const _y = "0123456789abcdef";
class W {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        wu[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(Ey > wu[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(W.levels.DEBUG, e)
    }
    info(...e) {
        this._log(W.levels.INFO, e)
    }
    warn(...e) {
        this._log(W.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (wy) return this.makeError("censored error", r, {});
        r || (r = W.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(f => {
            const l = n[f];
            try {
                if (l instanceof Uint8Array) {
                    let d = "";
                    for (let p = 0; p < l.length; p++) d += _y[l[p] >> 4], d += _y[l[p] & 15];
                    i.push(f + "=Uint8Array(0x" + d + ")")
                } else i.push(f + "=" + JSON.stringify(l))
            } catch {
                i.push(f + "=" + JSON.stringify(n[f].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        i.length && (e += " (" + i.join(", ") + ")");
        const o = new Error(e);
        return o.reason = s, o.code = r, Object.keys(n).forEach(function(f) {
            o[f] = n[f]
        }), o
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, W.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        Ay && this.throwError("platform missing String.prototype.normalize", W.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: Ay
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, W.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, W.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, W.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, W.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", W.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", W.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", W.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return dc || (dc = new W(K3)), dc
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", W.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), vy) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", W.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        wy = !!e, vy = !!r
    }
    static setLogLevel(e) {
        const r = wu[e.toLowerCase()];
        if (r == null) {
            W.globalLogger().warn("invalid log level - " + e);
            return
        }
        Ey = r
    }
    static from(e) {
        return new W(e)
    }
}
W.errors = mc;
W.levels = pc;
const J3 = "bytes/5.5.0",
    ji = new W(J3);

function Ty(t) {
    return !!t.toHexString
}

function Fa(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Fa(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function My(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function yc(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !My(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!My(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function $n(t, e) {
    if (e || (e = {}), typeof t == "number") {
        ji.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Fa(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Ty(t) && (t = t.toHexString()), Gn(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : ji.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Fa(new Uint8Array(n))
    }
    return yc(t) ? Fa(new Uint8Array(t)) : ji.throwArgumentError("invalid arrayify value", "value", t)
}

function Fo(t) {
    const e = t.map(i => $n(i)),
        r = e.reduce((i, s) => i + s.length, 0),
        n = new Uint8Array(r);
    return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), Fa(n)
}

function Gn(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const gc = "0123456789abcdef";

function tr(t, e) {
    if (e || (e = {}), typeof t == "number") {
        ji.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = gc[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Ty(t)) return t.toHexString();
    if (Gn(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : ji.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (yc(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += gc[(i & 240) >> 4] + gc[i & 15]
        }
        return r
    }
    return ji.throwArgumentError("invalid hexlify value", "value", t)
}

function Z3(t, e, r) {
    return typeof t != "string" ? t = tr(t) : (!Gn(t) || t.length % 2) && ji.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
}

function Y3(t) {
    let e = "0x";
    return t.forEach(r => {
        e += tr(r).substring(2)
    }), e
}

function Ny(t, e) {
    for (typeof t != "string" ? t = tr(t) : Gn(t) || ji.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && ji.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;) t = "0x0" + t.substring(2);
    return t
}
const Q3 = "bignumber/5.5.0";
var xc = He.BN;
const ci = new W(Q3),
    bc = {},
    Sy = 9007199254740991;
let Py = !1;
class St {
    constructor(e, r) {
        ci.checkNew(new.target, St), e !== bc && ci.throwError("cannot call constructor directly; use BigNumber.from", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Or(st(this).fromTwos(e))
    }
    toTwos(e) {
        return Or(st(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? St.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Or(st(this).add(st(e)))
    }
    sub(e) {
        return Or(st(this).sub(st(e)))
    }
    div(e) {
        return St.from(e).isZero() && sn("division by zero", "div"), Or(st(this).div(st(e)))
    }
    mul(e) {
        return Or(st(this).mul(st(e)))
    }
    mod(e) {
        const r = st(e);
        return r.isNeg() && sn("cannot modulo negative values", "mod"), Or(st(this).umod(r))
    }
    pow(e) {
        const r = st(e);
        return r.isNeg() && sn("cannot raise to negative values", "pow"), Or(st(this).pow(r))
    }
    and(e) {
        const r = st(e);
        return (this.isNegative() || r.isNeg()) && sn("cannot 'and' negative values", "and"), Or(st(this).and(r))
    }
    or(e) {
        const r = st(e);
        return (this.isNegative() || r.isNeg()) && sn("cannot 'or' negative values", "or"), Or(st(this).or(r))
    }
    xor(e) {
        const r = st(e);
        return (this.isNegative() || r.isNeg()) && sn("cannot 'xor' negative values", "xor"), Or(st(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && sn("cannot mask negative values", "mask"), Or(st(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && sn("cannot shift negative values", "shl"), Or(st(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && sn("cannot shift negative values", "shr"), Or(st(this).shrn(e))
    }
    eq(e) {
        return st(this).eq(st(e))
    }
    lt(e) {
        return st(this).lt(st(e))
    }
    lte(e) {
        return st(this).lte(st(e))
    }
    gt(e) {
        return st(this).gt(st(e))
    }
    gte(e) {
        return st(this).gte(st(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return st(this).isZero()
    }
    toNumber() {
        try {
            return st(this).toNumber()
        } catch {
            sn("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return ci.throwError("this platform does not support BigInt", W.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? Py || (Py = !0, ci.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? ci.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", W.errors.UNEXPECTED_ARGUMENT, {}) : ci.throwError("BigNumber.toString does not accept parameters", W.errors.UNEXPECTED_ARGUMENT, {})), st(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof St) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new St(bc, Da(e)) : e.match(/^-?[0-9]+$/) ? new St(bc, Da(new xc(e))) : ci.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && sn("underflow", "BigNumber.from", e), (e >= Sy || e <= -Sy) && sn("overflow", "BigNumber.from", e), St.from(String(e));
        const r = e;
        if (typeof r == "bigint") return St.from(r.toString());
        if (yc(r)) return St.from(tr(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return St.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Gn(n) || n[0] === "-" && Gn(n.substring(1)))) return St.from(n)
            }
        return ci.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function Da(t) {
    if (typeof t != "string") return Da(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && ci.throwArgumentError("invalid hex", "value", t), t = Da(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Or(t) {
    return St.from(Da(t))
}

function st(t) {
    const e = St.from(t).toHexString();
    return e[0] === "-" ? new xc("-" + e.substring(3), 16) : new xc(e.substring(2), 16)
}

function sn(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), ci.throwError(t, W.errors.NUMERIC_FAULT, n)
}
const e5 = "properties/5.5.0";
var t5 = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Eu = new W(e5);

function pe(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}

function hi(t, e) {
    for (let r = 0; r < 32; r++) {
        if (t[e]) return t[e];
        if (!t.prototype || typeof t.prototype != "object") break;
        t = Object.getPrototypeOf(t.prototype).constructor
    }
    return null
}

function kt(t) {
    return t5(this, void 0, void 0, function*() {
        const e = Object.keys(t).map(n => {
            const i = t[n];
            return Promise.resolve(i).then(s => ({
                key: n,
                value: s
            }))
        });
        return (yield Promise.all(e)).reduce((n, i) => (n[i.key] = i.value, n), {})
    })
}

function r5(t, e) {
    (!t || typeof t != "object") && Eu.throwArgumentError("invalid object", "object", t), Object.keys(t).forEach(r => {
        e[r] || Eu.throwArgumentError("invalid object key - " + r, "transaction:" + r, t)
    })
}

function Yt(t) {
    const e = {};
    for (const r in t) e[r] = t[r];
    return e
}
const n5 = {
    bigint: !0,
    boolean: !0,
    function: !0,
    number: !0,
    string: !0
};

function Iy(t) {
    if (t == null || n5[typeof t]) return !0;
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1;
        const e = Object.keys(t);
        for (let r = 0; r < e.length; r++) {
            let n = null;
            try {
                n = t[e[r]]
            } catch {
                continue
            }
            if (!Iy(n)) return !1
        }
        return !0
    }
    return Eu.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function i5(t) {
    if (Iy(t)) return t;
    if (Array.isArray(t)) return Object.freeze(t.map(e => Wi(e)));
    if (typeof t == "object") {
        const e = {};
        for (const r in t) {
            const n = t[r];
            n !== void 0 && pe(e, r, Wi(n))
        }
        return e
    }
    return Eu.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function Wi(t) {
    return i5(t)
}
class Ua {
    constructor(e) {
        for (const r in e) this[r] = Wi(e[r])
    }
}
const La = "abi/5.5.0",
    pt = new W(La),
    Ks = {};
let Ry = {
        calldata: !0,
        memory: !0,
        storage: !0
    },
    s5 = {
        calldata: !0,
        memory: !0
    };

function Au(t, e) {
    if (t === "bytes" || t === "string") {
        if (Ry[e]) return !0
    } else if (t === "address") {
        if (e === "payable") return !0
    } else if ((t.indexOf("[") >= 0 || t === "tuple") && s5[e]) return !0;
    return (Ry[e] || e === "payable") && pt.throwArgumentError("invalid modifier", "name", e), !1
}

function o5(t, e) {
    let r = t;

    function n(f) {
        pt.throwArgumentError(`unexpected character at position ${f}`, "param", t)
    }
    t = t.replace(/\s/g, " ");

    function i(f) {
        let l = {
            type: "",
            name: "",
            parent: f,
            state: {
                allowType: !0
            }
        };
        return e && (l.indexed = !1), l
    }
    let s = {
            type: "",
            name: "",
            state: {
                allowType: !0
            }
        },
        o = s;
    for (let f = 0; f < t.length; f++) {
        let l = t[f];
        switch (l) {
            case "(":
                o.state.allowType && o.type === "" ? o.type = "tuple" : o.state.allowParams || n(f), o.state.allowType = !1, o.type = Do(o.type), o.components = [i(o)], o = o.components[0];
                break;
            case ")":
                delete o.state, o.name === "indexed" && (e || n(f), o.indexed = !0, o.name = ""), Au(o.type, o.name) && (o.name = ""), o.type = Do(o.type);
                let d = o;
                o = o.parent, o || n(f), delete d.parent, o.state.allowParams = !1, o.state.allowName = !0, o.state.allowArray = !0;
                break;
            case ",":
                delete o.state, o.name === "indexed" && (e || n(f), o.indexed = !0, o.name = ""), Au(o.type, o.name) && (o.name = ""), o.type = Do(o.type);
                let p = i(o.parent);
                o.parent.components.push(p), delete o.parent, o = p;
                break;
            case " ":
                o.state.allowType && o.type !== "" && (o.type = Do(o.type), delete o.state.allowType, o.state.allowName = !0, o.state.allowParams = !0), o.state.allowName && o.name !== "" && (o.name === "indexed" ? (e || n(f), o.indexed && n(f), o.indexed = !0, o.name = "") : Au(o.type, o.name) ? o.name = "" : o.state.allowName = !1);
                break;
            case "[":
                o.state.allowArray || n(f), o.type += l, o.state.allowArray = !1, o.state.allowName = !1, o.state.readArray = !0;
                break;
            case "]":
                o.state.readArray || n(f), o.type += l, o.state.readArray = !1, o.state.allowArray = !0, o.state.allowName = !0;
                break;
            default:
                o.state.allowType ? (o.type += l, o.state.allowParams = !0, o.state.allowArray = !0) : o.state.allowName ? (o.name += l, delete o.state.allowArray) : o.state.readArray ? o.type += l : n(f)
        }
    }
    return o.parent && pt.throwArgumentError("unexpected eof", "param", t), delete s.state, o.name === "indexed" ? (e || n(r.length - 7), o.indexed && n(r.length - 7), o.indexed = !0, o.name = "") : Au(o.type, o.name) && (o.name = ""), s.type = Do(s.type), s
}

function _u(t, e) {
    for (let r in e) pe(t, r, e[r])
}
const gt = Object.freeze({
        sighash: "sighash",
        minimal: "minimal",
        full: "full",
        json: "json"
    }),
    a5 = new RegExp(/^(.*)\[([0-9]*)\]$/);
class rr {
    constructor(e, r) {
        e !== Ks && pt.throwError("use fromString", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
        }), _u(this, r);
        let n = this.type.match(a5);
        n ? _u(this, {
            arrayLength: parseInt(n[2] || "-1"),
            arrayChildren: rr.fromObject({
                type: n[1],
                components: this.components
            }),
            baseType: "array"
        }) : _u(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
        }), this._isParamType = !0, Object.freeze(this)
    }
    format(e) {
        if (e || (e = gt.sighash), gt[e] || pt.throwArgumentError("invalid format type", "format", e), e === gt.json) {
            let n = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || void 0
            };
            return typeof this.indexed == "boolean" && (n.indexed = this.indexed), this.components && (n.components = this.components.map(i => JSON.parse(i.format(e)))), JSON.stringify(n)
        }
        let r = "";
        return this.baseType === "array" ? (r += this.arrayChildren.format(e), r += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== gt.sighash && (r += this.type), r += "(" + this.components.map(n => n.format(e)).join(e === gt.full ? ", " : ",") + ")") : r += this.type, e !== gt.sighash && (this.indexed === !0 && (r += " indexed"), e === gt.full && this.name && (r += " " + this.name)), r
    }
    static from(e, r) {
        return typeof e == "string" ? rr.fromString(e, r) : rr.fromObject(e)
    }
    static fromObject(e) {
        return rr.isParamType(e) ? e : new rr(Ks, {
            name: e.name || null,
            type: Do(e.type),
            indexed: e.indexed == null ? null : !!e.indexed,
            components: e.components ? e.components.map(rr.fromObject) : null
        })
    }
    static fromString(e, r) {
        function n(i) {
            return rr.fromObject({
                name: i.name,
                type: i.type,
                indexed: i.indexed,
                components: i.components
            })
        }
        return n(o5(e, !!r))
    }
    static isParamType(e) {
        return !!(e != null && e._isParamType)
    }
}

function Ba(t, e) {
    return u5(t).map(r => rr.fromString(r, e))
}
class Vi {
    constructor(e, r) {
        e !== Ks && pt.throwError("use a static from method", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
        }), _u(this, r), this._isFragment = !0, Object.freeze(this)
    }
    static from(e) {
        return Vi.isFragment(e) ? e : typeof e == "string" ? Vi.fromString(e) : Vi.fromObject(e)
    }
    static fromObject(e) {
        if (Vi.isFragment(e)) return e;
        switch (e.type) {
            case "function":
                return pi.fromObject(e);
            case "event":
                return Ki.fromObject(e);
            case "constructor":
                return di.fromObject(e);
            case "error":
                return xs.fromObject(e);
            case "fallback":
            case "receive":
                return null
        }
        return pt.throwArgumentError("invalid fragment object", "value", e)
    }
    static fromString(e) {
        return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? Ki.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? pi.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? di.fromString(e.trim()) : e.split(" ")[0] === "error" ? xs.fromString(e.substring(5).trim()) : pt.throwArgumentError("unsupported fragment", "value", e)
    }
    static isFragment(e) {
        return !!(e && e._isFragment)
    }
}
class Ki extends Vi {
    format(e) {
        if (e || (e = gt.sighash), gt[e] || pt.throwArgumentError("invalid format type", "format", e), e === gt.json) return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(n => JSON.parse(n.format(e)))
        });
        let r = "";
        return e !== gt.sighash && (r += "event "), r += this.name + "(" + this.inputs.map(n => n.format(e)).join(e === gt.full ? ", " : ",") + ") ", e !== gt.sighash && this.anonymous && (r += "anonymous "), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? Ki.fromString(e) : Ki.fromObject(e)
    }
    static fromObject(e) {
        if (Ki.isEventFragment(e)) return e;
        e.type !== "event" && pt.throwArgumentError("invalid event object", "value", e);
        const r = {
            name: $a(e.name),
            anonymous: e.anonymous,
            inputs: e.inputs ? e.inputs.map(rr.fromObject) : [],
            type: "event"
        };
        return new Ki(Ks, r)
    }
    static fromString(e) {
        let r = e.match(Ga);
        r || pt.throwArgumentError("invalid event string", "value", e);
        let n = !1;
        return r[3].split(" ").forEach(i => {
            switch (i.trim()) {
                case "anonymous":
                    n = !0;
                    break;
                case "":
                    break;
                default:
                    pt.warn("unknown modifier: " + i)
            }
        }), Ki.fromObject({
            name: r[1].trim(),
            anonymous: n,
            inputs: Ba(r[2], !0),
            type: "event"
        })
    }
    static isEventFragment(e) {
        return e && e._isFragment && e.type === "event"
    }
}

function ky(t, e) {
    e.gas = null;
    let r = t.split("@");
    return r.length !== 1 ? (r.length > 2 && pt.throwArgumentError("invalid human-readable ABI signature", "value", t), r[1].match(/^[0-9]+$/) || pt.throwArgumentError("invalid human-readable ABI signature gas", "value", t), e.gas = St.from(r[1]), r[0]) : t
}

function Oy(t, e) {
    e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", t.split(" ").forEach(r => {
        switch (r.trim()) {
            case "constant":
                e.constant = !0;
                break;
            case "payable":
                e.payable = !0, e.stateMutability = "payable";
                break;
            case "nonpayable":
                e.payable = !1, e.stateMutability = "nonpayable";
                break;
            case "pure":
                e.constant = !0, e.stateMutability = "pure";
                break;
            case "view":
                e.constant = !0, e.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + r)
        }
    })
}

function Cy(t) {
    let e = {
        constant: !1,
        payable: !0,
        stateMutability: "payable"
    };
    return t.stateMutability != null ? (e.stateMutability = t.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", t.constant != null && !!t.constant !== e.constant && pt.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t), e.payable = e.stateMutability === "payable", t.payable != null && !!t.payable !== e.payable && pt.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t)) : t.payable != null ? (e.payable = !!t.payable, t.constant == null && !e.payable && t.type !== "constructor" && pt.throwArgumentError("unable to determine stateMutability", "value", t), e.constant = !!t.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && pt.throwArgumentError("cannot have constant payable function", "value", t)) : t.constant != null ? (e.constant = !!t.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : t.type !== "constructor" && pt.throwArgumentError("unable to determine stateMutability", "value", t), e
}
class di extends Vi {
    format(e) {
        if (e || (e = gt.sighash), gt[e] || pt.throwArgumentError("invalid format type", "format", e), e === gt.json) return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(n => JSON.parse(n.format(e)))
        });
        e === gt.sighash && pt.throwError("cannot format a constructor for sighash", W.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
        });
        let r = "constructor(" + this.inputs.map(n => n.format(e)).join(e === gt.full ? ", " : ",") + ") ";
        return this.stateMutability && this.stateMutability !== "nonpayable" && (r += this.stateMutability + " "), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? di.fromString(e) : di.fromObject(e)
    }
    static fromObject(e) {
        if (di.isConstructorFragment(e)) return e;
        e.type !== "constructor" && pt.throwArgumentError("invalid constructor object", "value", e);
        let r = Cy(e);
        r.constant && pt.throwArgumentError("constructor cannot be constant", "value", e);
        const n = {
            name: null,
            type: e.type,
            inputs: e.inputs ? e.inputs.map(rr.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: e.gas ? St.from(e.gas) : null
        };
        return new di(Ks, n)
    }
    static fromString(e) {
        let r = {
            type: "constructor"
        };
        e = ky(e, r);
        let n = e.match(Ga);
        return (!n || n[1].trim() !== "constructor") && pt.throwArgumentError("invalid constructor string", "value", e), r.inputs = Ba(n[2].trim(), !1), Oy(n[3].trim(), r), di.fromObject(r)
    }
    static isConstructorFragment(e) {
        return e && e._isFragment && e.type === "constructor"
    }
}
class pi extends di {
    format(e) {
        if (e || (e = gt.sighash), gt[e] || pt.throwArgumentError("invalid format type", "format", e), e === gt.json) return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(n => JSON.parse(n.format(e))),
            outputs: this.outputs.map(n => JSON.parse(n.format(e)))
        });
        let r = "";
        return e !== gt.sighash && (r += "function "), r += this.name + "(" + this.inputs.map(n => n.format(e)).join(e === gt.full ? ", " : ",") + ") ", e !== gt.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (r += this.stateMutability + " ") : this.constant && (r += "view "), this.outputs && this.outputs.length && (r += "returns (" + this.outputs.map(n => n.format(e)).join(", ") + ") "), this.gas != null && (r += "@" + this.gas.toString() + " ")), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? pi.fromString(e) : pi.fromObject(e)
    }
    static fromObject(e) {
        if (pi.isFunctionFragment(e)) return e;
        e.type !== "function" && pt.throwArgumentError("invalid function object", "value", e);
        let r = Cy(e);
        const n = {
            type: e.type,
            name: $a(e.name),
            constant: r.constant,
            inputs: e.inputs ? e.inputs.map(rr.fromObject) : [],
            outputs: e.outputs ? e.outputs.map(rr.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: e.gas ? St.from(e.gas) : null
        };
        return new pi(Ks, n)
    }
    static fromString(e) {
        let r = {
            type: "function"
        };
        e = ky(e, r);
        let n = e.split(" returns ");
        n.length > 2 && pt.throwArgumentError("invalid function string", "value", e);
        let i = n[0].match(Ga);
        if (i || pt.throwArgumentError("invalid function signature", "value", e), r.name = i[1].trim(), r.name && $a(r.name), r.inputs = Ba(i[2], !1), Oy(i[3].trim(), r), n.length > 1) {
            let s = n[1].match(Ga);
            (s[1].trim() != "" || s[3].trim() != "") && pt.throwArgumentError("unexpected tokens", "value", e), r.outputs = Ba(s[2], !1)
        } else r.outputs = [];
        return pi.fromObject(r)
    }
    static isFunctionFragment(e) {
        return e && e._isFragment && e.type === "function"
    }
}

function Fy(t) {
    const e = t.format();
    return (e === "Error(string)" || e === "Panic(uint256)") && pt.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", t), t
}
class xs extends Vi {
    format(e) {
        if (e || (e = gt.sighash), gt[e] || pt.throwArgumentError("invalid format type", "format", e), e === gt.json) return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(n => JSON.parse(n.format(e)))
        });
        let r = "";
        return e !== gt.sighash && (r += "error "), r += this.name + "(" + this.inputs.map(n => n.format(e)).join(e === gt.full ? ", " : ",") + ") ", r.trim()
    }
    static from(e) {
        return typeof e == "string" ? xs.fromString(e) : xs.fromObject(e)
    }
    static fromObject(e) {
        if (xs.isErrorFragment(e)) return e;
        e.type !== "error" && pt.throwArgumentError("invalid error object", "value", e);
        const r = {
            type: e.type,
            name: $a(e.name),
            inputs: e.inputs ? e.inputs.map(rr.fromObject) : []
        };
        return Fy(new xs(Ks, r))
    }
    static fromString(e) {
        let r = {
                type: "error"
            },
            n = e.match(Ga);
        return n || pt.throwArgumentError("invalid error signature", "value", e), r.name = n[1].trim(), r.name && $a(r.name), r.inputs = Ba(n[2], !1), Fy(xs.fromObject(r))
    }
    static isErrorFragment(e) {
        return e && e._isFragment && e.type === "error"
    }
}

function Do(t) {
    return t.match(/^uint($|[^1-9])/) ? t = "uint256" + t.substring(4) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t
}
const f5 = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

function $a(t) {
    return (!t || !t.match(f5)) && pt.throwArgumentError(`invalid identifier "${t}"`, "value", t), t
}
const Ga = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

function u5(t) {
    t = t.trim();
    let e = [],
        r = "",
        n = 0;
    for (let i = 0; i < t.length; i++) {
        let s = t[i];
        s === "," && n === 0 ? (e.push(r), r = "") : (r += s, s === "(" ? n++ : s === ")" && (n--, n === -1 && pt.throwArgumentError("unbalanced parenthesis", "value", t)))
    }
    return r && e.push(r), e
}
const vc = new W(La);

function l5(t) {
    const e = [],
        r = function(n, i) {
            if (!!Array.isArray(i))
                for (let s in i) {
                    const o = n.slice();
                    o.push(s);
                    try {
                        r(o, i[s])
                    } catch (f) {
                        e.push({
                            path: o,
                            error: f
                        })
                    }
                }
        };
    return r([], t), e
}
class Xi {
    constructor(e, r, n, i) {
        this.name = e, this.type = r, this.localName = n, this.dynamic = i
    }
    _throwError(e, r) {
        vc.throwArgumentError(e, this.localName, r)
    }
}
class wc {
    constructor(e) {
        pe(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e)
    }
    get data() {
        return Y3(this._data)
    }
    get length() {
        return this._dataLength
    }
    _writeData(e) {
        return this._data.push(e), this._dataLength += e.length, e.length
    }
    appendWriter(e) {
        return this._writeData(Fo(e._data))
    }
    writeBytes(e) {
        let r = $n(e);
        const n = r.length % this.wordSize;
        return n && (r = Fo([r, this._padding.slice(n)])), this._writeData(r)
    }
    _getValue(e) {
        let r = $n(St.from(e));
        return r.length > this.wordSize && vc.throwError("value out-of-bounds", W.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: r.length
        }), r.length % this.wordSize && (r = Fo([this._padding.slice(r.length % this.wordSize), r])), r
    }
    writeValue(e) {
        return this._writeData(this._getValue(e))
    }
    writeUpdatableValue() {
        const e = this._data.length;
        return this._data.push(this._padding), this._dataLength += this.wordSize, r => {
            this._data[e] = this._getValue(r)
        }
    }
}
class Tu {
    constructor(e, r, n, i) {
        pe(this, "_data", $n(e)), pe(this, "wordSize", r || 32), pe(this, "_coerceFunc", n), pe(this, "allowLoose", i), this._offset = 0
    }
    get data() {
        return tr(this._data)
    }
    get consumed() {
        return this._offset
    }
    static coerce(e, r) {
        let n = e.match("^u?int([0-9]+)$");
        return n && parseInt(n[1]) <= 48 && (r = r.toNumber()), r
    }
    coerce(e, r) {
        return this._coerceFunc ? this._coerceFunc(e, r) : Tu.coerce(e, r)
    }
    _peekBytes(e, r, n) {
        let i = Math.ceil(r / this.wordSize) * this.wordSize;
        return this._offset + i > this._data.length && (this.allowLoose && n && this._offset + r <= this._data.length ? i = r : vc.throwError("data out-of-bounds", W.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + i
        })), this._data.slice(this._offset, this._offset + i)
    }
    subReader(e) {
        return new Tu(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose)
    }
    readBytes(e, r) {
        let n = this._peekBytes(0, e, !!r);
        return this._offset += n.length, n.slice(0, e)
    }
    readValue() {
        return St.from(this.readBytes(this.wordSize))
    }
}
const c5 = "bytes/5.5.0",
    Xs = new W(c5);

function Dy(t) {
    return !!t.toHexString
}

function Mu(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Mu(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function Uy(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function Ec(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !Uy(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!Uy(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Ac(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Xs.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Mu(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Dy(t) && (t = t.toHexString()), Uo(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Xs.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Mu(new Uint8Array(n))
    }
    return Ec(t) ? Mu(new Uint8Array(t)) : Xs.throwArgumentError("invalid arrayify value", "value", t)
}

function h5(t) {
    let e = Ac(t);
    if (e.length === 0) return e;
    let r = 0;
    for (; r < e.length && e[r] === 0;) r++;
    return r && (e = e.slice(r)), e
}

function Uo(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const _c = "0123456789abcdef";

function Ly(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Xs.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = _c[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Dy(t)) return t.toHexString();
    if (Uo(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Xs.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (Ec(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += _c[(i & 240) >> 4] + _c[i & 15]
        }
        return r
    }
    return Xs.throwArgumentError("invalid hexlify value", "value", t)
}

function d5(t, e, r) {
    return typeof t != "string" ? t = Ly(t) : (!Uo(t) || t.length % 2) && Xs.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
}
const p5 = "bignumber/5.5.0";
var Nu = He.BN;
const mi = new W(p5),
    Tc = {},
    By = 9007199254740991;
let $y = !1;
class Nr {
    constructor(e, r) {
        mi.checkNew(new.target, Nr), e !== Tc && mi.throwError("cannot call constructor directly; use BigNumber.from", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Cr(ot(this).fromTwos(e))
    }
    toTwos(e) {
        return Cr(ot(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? Nr.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Cr(ot(this).add(ot(e)))
    }
    sub(e) {
        return Cr(ot(this).sub(ot(e)))
    }
    div(e) {
        return Nr.from(e).isZero() && on("division by zero", "div"), Cr(ot(this).div(ot(e)))
    }
    mul(e) {
        return Cr(ot(this).mul(ot(e)))
    }
    mod(e) {
        const r = ot(e);
        return r.isNeg() && on("cannot modulo negative values", "mod"), Cr(ot(this).umod(r))
    }
    pow(e) {
        const r = ot(e);
        return r.isNeg() && on("cannot raise to negative values", "pow"), Cr(ot(this).pow(r))
    }
    and(e) {
        const r = ot(e);
        return (this.isNegative() || r.isNeg()) && on("cannot 'and' negative values", "and"), Cr(ot(this).and(r))
    }
    or(e) {
        const r = ot(e);
        return (this.isNegative() || r.isNeg()) && on("cannot 'or' negative values", "or"), Cr(ot(this).or(r))
    }
    xor(e) {
        const r = ot(e);
        return (this.isNegative() || r.isNeg()) && on("cannot 'xor' negative values", "xor"), Cr(ot(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && on("cannot mask negative values", "mask"), Cr(ot(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && on("cannot shift negative values", "shl"), Cr(ot(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && on("cannot shift negative values", "shr"), Cr(ot(this).shrn(e))
    }
    eq(e) {
        return ot(this).eq(ot(e))
    }
    lt(e) {
        return ot(this).lt(ot(e))
    }
    lte(e) {
        return ot(this).lte(ot(e))
    }
    gt(e) {
        return ot(this).gt(ot(e))
    }
    gte(e) {
        return ot(this).gte(ot(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return ot(this).isZero()
    }
    toNumber() {
        try {
            return ot(this).toNumber()
        } catch {
            on("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return mi.throwError("this platform does not support BigInt", W.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? $y || ($y = !0, mi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? mi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", W.errors.UNEXPECTED_ARGUMENT, {}) : mi.throwError("BigNumber.toString does not accept parameters", W.errors.UNEXPECTED_ARGUMENT, {})), ot(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof Nr) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new Nr(Tc, za(e)) : e.match(/^-?[0-9]+$/) ? new Nr(Tc, za(new Nu(e))) : mi.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && on("underflow", "BigNumber.from", e), (e >= By || e <= -By) && on("overflow", "BigNumber.from", e), Nr.from(String(e));
        const r = e;
        if (typeof r == "bigint") return Nr.from(r.toString());
        if (Ec(r)) return Nr.from(Ly(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return Nr.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Uo(n) || n[0] === "-" && Uo(n.substring(1)))) return Nr.from(n)
            }
        return mi.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function za(t) {
    if (typeof t != "string") return za(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && mi.throwArgumentError("invalid hex", "value", t), t = za(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Cr(t) {
    return Nr.from(za(t))
}

function ot(t) {
    const e = Nr.from(t).toHexString();
    return e[0] === "-" ? new Nu("-" + e.substring(3), 16) : new Nu(e.substring(2), 16)
}

function on(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), mi.throwError(t, W.errors.NUMERIC_FAULT, n)
}

function m5(t) {
    return new Nu(t, 36).toString(16)
}
var Gy = {
    exports: {}
};
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
    (function() {
        var e = "input is invalid type",
            r = "finalize already called",
            n = typeof window == "object",
            i = n ? window : {};
        i.JS_SHA3_NO_WINDOW && (n = !1);
        var s = !n && typeof self == "object",
            o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
        o ? i = vu : s && (i = self);
        var f = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports,
            l = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined",
            d = "0123456789abcdef".split(""),
            p = [31, 7936, 2031616, 520093696],
            A = [4, 1024, 262144, 67108864],
            T = [1, 256, 65536, 16777216],
            N = [6, 1536, 393216, 100663296],
            P = [0, 8, 16, 24],
            C = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
            S = [224, 256, 384, 512],
            k = [128, 256],
            I = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            U = {
                "128": 168,
                "256": 136
            };
        (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(E) {
            return Object.prototype.toString.call(E) === "[object Array]"
        }), l && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(E) {
            return typeof E == "object" && E.buffer && E.buffer.constructor === ArrayBuffer
        });
        for (var M = function(E, R, G) {
                return function(z) {
                    return new u(E, R, E).update(z)[G]()
                }
            }, F = function(E, R, G) {
                return function(z, j) {
                    return new u(E, R, j).update(z)[G]()
                }
            }, D = function(E, R, G) {
                return function(z, j, re, ee) {
                    return a["cshake" + E].update(z, j, re, ee)[G]()
                }
            }, q = function(E, R, G) {
                return function(z, j, re, ee) {
                    return a["kmac" + E].update(z, j, re, ee)[G]()
                }
            }, V = function(E, R, G, z) {
                for (var j = 0; j < I.length; ++j) {
                    var re = I[j];
                    E[re] = R(G, z, re)
                }
                return E
            }, Q = function(E, R) {
                var G = M(E, R, "hex");
                return G.create = function() {
                    return new u(E, R, E)
                }, G.update = function(z) {
                    return G.create().update(z)
                }, V(G, M, E, R)
            }, ce = function(E, R) {
                var G = F(E, R, "hex");
                return G.create = function(z) {
                    return new u(E, R, z)
                }, G.update = function(z, j) {
                    return G.create(j).update(z)
                }, V(G, F, E, R)
            }, O = function(E, R) {
                var G = U[E],
                    z = D(E, R, "hex");
                return z.create = function(j, re, ee) {
                    return !re && !ee ? a["shake" + E].create(j) : new u(E, R, j).bytepad([re, ee], G)
                }, z.update = function(j, re, ee, K) {
                    return z.create(re, ee, K).update(j)
                }, V(z, D, E, R)
            }, w = function(E, R) {
                var G = U[E],
                    z = q(E, R, "hex");
                return z.create = function(j, re, ee) {
                    return new _(E, R, re).bytepad(["KMAC", ee], G).bytepad([j], G)
                }, z.update = function(j, re, ee, K) {
                    return z.create(j, ee, K).update(re)
                }, V(z, q, E, R)
            }, m = [{
                name: "keccak",
                padding: T,
                bits: S,
                createMethod: Q
            }, {
                name: "sha3",
                padding: N,
                bits: S,
                createMethod: Q
            }, {
                name: "shake",
                padding: p,
                bits: k,
                createMethod: ce
            }, {
                name: "cshake",
                padding: A,
                bits: k,
                createMethod: O
            }, {
                name: "kmac",
                padding: A,
                bits: k,
                createMethod: w
            }], a = {}, c = [], g = 0; g < m.length; ++g)
            for (var v = m[g], x = v.bits, b = 0; b < x.length; ++b) {
                var y = v.name + "_" + x[b];
                if (c.push(y), a[y] = v.createMethod(x[b], v.padding), v.name !== "sha3") {
                    var h = v.name + x[b];
                    c.push(h), a[h] = a[y]
                }
            }

        function u(E, R, G) {
            this.blocks = [], this.s = [], this.padding = R, this.outputBits = G, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (E << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = G >> 5, this.extraBytes = (G & 31) >> 3;
            for (var z = 0; z < 50; ++z) this.s[z] = 0
        }
        u.prototype.update = function(E) {
            if (this.finalized) throw new Error(r);
            var R, G = typeof E;
            if (G !== "string") {
                if (G === "object") {
                    if (E === null) throw new Error(e);
                    if (l && E.constructor === ArrayBuffer) E = new Uint8Array(E);
                    else if (!Array.isArray(E) && (!l || !ArrayBuffer.isView(E))) throw new Error(e)
                } else throw new Error(e);
                R = !0
            }
            for (var z = this.blocks, j = this.byteCount, re = E.length, ee = this.blockCount, K = 0, B = this.s, $, H; K < re;) {
                if (this.reset)
                    for (this.reset = !1, z[0] = this.block, $ = 1; $ < ee + 1; ++$) z[$] = 0;
                if (R)
                    for ($ = this.start; K < re && $ < j; ++K) z[$ >> 2] |= E[K] << P[$++ & 3];
                else
                    for ($ = this.start; K < re && $ < j; ++K) H = E.charCodeAt(K), H < 128 ? z[$ >> 2] |= H << P[$++ & 3] : H < 2048 ? (z[$ >> 2] |= (192 | H >> 6) << P[$++ & 3], z[$ >> 2] |= (128 | H & 63) << P[$++ & 3]) : H < 55296 || H >= 57344 ? (z[$ >> 2] |= (224 | H >> 12) << P[$++ & 3], z[$ >> 2] |= (128 | H >> 6 & 63) << P[$++ & 3], z[$ >> 2] |= (128 | H & 63) << P[$++ & 3]) : (H = 65536 + ((H & 1023) << 10 | E.charCodeAt(++K) & 1023), z[$ >> 2] |= (240 | H >> 18) << P[$++ & 3], z[$ >> 2] |= (128 | H >> 12 & 63) << P[$++ & 3], z[$ >> 2] |= (128 | H >> 6 & 63) << P[$++ & 3], z[$ >> 2] |= (128 | H & 63) << P[$++ & 3]);
                if (this.lastByteIndex = $, $ >= j) {
                    for (this.start = $ - j, this.block = z[ee], $ = 0; $ < ee; ++$) B[$] ^= z[$];
                    L(B), this.reset = !0
                } else this.start = $
            }
            return this
        }, u.prototype.encode = function(E, R) {
            var G = E & 255,
                z = 1,
                j = [G];
            for (E = E >> 8, G = E & 255; G > 0;) j.unshift(G), E = E >> 8, G = E & 255, ++z;
            return R ? j.push(z) : j.unshift(z), this.update(j), j.length
        }, u.prototype.encodeString = function(E) {
            var R, G = typeof E;
            if (G !== "string") {
                if (G === "object") {
                    if (E === null) throw new Error(e);
                    if (l && E.constructor === ArrayBuffer) E = new Uint8Array(E);
                    else if (!Array.isArray(E) && (!l || !ArrayBuffer.isView(E))) throw new Error(e)
                } else throw new Error(e);
                R = !0
            }
            var z = 0,
                j = E.length;
            if (R) z = j;
            else
                for (var re = 0; re < E.length; ++re) {
                    var ee = E.charCodeAt(re);
                    ee < 128 ? z += 1 : ee < 2048 ? z += 2 : ee < 55296 || ee >= 57344 ? z += 3 : (ee = 65536 + ((ee & 1023) << 10 | E.charCodeAt(++re) & 1023), z += 4)
                }
            return z += this.encode(z * 8), this.update(E), z
        }, u.prototype.bytepad = function(E, R) {
            for (var G = this.encode(R), z = 0; z < E.length; ++z) G += this.encodeString(E[z]);
            var j = R - G % R,
                re = [];
            return re.length = j, this.update(re), this
        }, u.prototype.finalize = function() {
            if (!this.finalized) {
                this.finalized = !0;
                var E = this.blocks,
                    R = this.lastByteIndex,
                    G = this.blockCount,
                    z = this.s;
                if (E[R >> 2] |= this.padding[R & 3], this.lastByteIndex === this.byteCount)
                    for (E[0] = E[G], R = 1; R < G + 1; ++R) E[R] = 0;
                for (E[G - 1] |= 2147483648, R = 0; R < G; ++R) z[R] ^= E[R];
                L(z)
            }
        }, u.prototype.toString = u.prototype.hex = function() {
            this.finalize();
            for (var E = this.blockCount, R = this.s, G = this.outputBlocks, z = this.extraBytes, j = 0, re = 0, ee = "", K; re < G;) {
                for (j = 0; j < E && re < G; ++j, ++re) K = R[j], ee += d[K >> 4 & 15] + d[K & 15] + d[K >> 12 & 15] + d[K >> 8 & 15] + d[K >> 20 & 15] + d[K >> 16 & 15] + d[K >> 28 & 15] + d[K >> 24 & 15];
                re % E == 0 && (L(R), j = 0)
            }
            return z && (K = R[j], ee += d[K >> 4 & 15] + d[K & 15], z > 1 && (ee += d[K >> 12 & 15] + d[K >> 8 & 15]), z > 2 && (ee += d[K >> 20 & 15] + d[K >> 16 & 15])), ee
        }, u.prototype.arrayBuffer = function() {
            this.finalize();
            var E = this.blockCount,
                R = this.s,
                G = this.outputBlocks,
                z = this.extraBytes,
                j = 0,
                re = 0,
                ee = this.outputBits >> 3,
                K;
            z ? K = new ArrayBuffer(G + 1 << 2) : K = new ArrayBuffer(ee);
            for (var B = new Uint32Array(K); re < G;) {
                for (j = 0; j < E && re < G; ++j, ++re) B[re] = R[j];
                re % E == 0 && L(R)
            }
            return z && (B[j] = R[j], K = K.slice(0, ee)), K
        }, u.prototype.buffer = u.prototype.arrayBuffer, u.prototype.digest = u.prototype.array = function() {
            this.finalize();
            for (var E = this.blockCount, R = this.s, G = this.outputBlocks, z = this.extraBytes, j = 0, re = 0, ee = [], K, B; re < G;) {
                for (j = 0; j < E && re < G; ++j, ++re) K = re << 2, B = R[j], ee[K] = B & 255, ee[K + 1] = B >> 8 & 255, ee[K + 2] = B >> 16 & 255, ee[K + 3] = B >> 24 & 255;
                re % E == 0 && L(R)
            }
            return z && (K = re << 2, B = R[j], ee[K] = B & 255, z > 1 && (ee[K + 1] = B >> 8 & 255), z > 2 && (ee[K + 2] = B >> 16 & 255)), ee
        };

        function _(E, R, G) {
            u.call(this, E, R, G)
        }
        _.prototype = new u, _.prototype.finalize = function() {
            return this.encode(this.outputBits, !0), u.prototype.finalize.call(this)
        };
        var L = function(E) {
            var R, G, z, j, re, ee, K, B, $, H, ne, J, Y, ue, te, Z, se, fe, ie, me, he, le, Pe, xe, de, je, Ie, be, X, ae, oe, ve, ye, ge, Ve, ke, Ae, et, Oe, we, rt, Fe, Ee, it, Le, _e, bt, Be, Te, vt, $e, Me, wt, Ge, Ne, Et, De, Ue, pr, mr, yr, gr, xr;
            for (z = 0; z < 48; z += 2) j = E[0] ^ E[10] ^ E[20] ^ E[30] ^ E[40], re = E[1] ^ E[11] ^ E[21] ^ E[31] ^ E[41], ee = E[2] ^ E[12] ^ E[22] ^ E[32] ^ E[42], K = E[3] ^ E[13] ^ E[23] ^ E[33] ^ E[43], B = E[4] ^ E[14] ^ E[24] ^ E[34] ^ E[44], $ = E[5] ^ E[15] ^ E[25] ^ E[35] ^ E[45], H = E[6] ^ E[16] ^ E[26] ^ E[36] ^ E[46], ne = E[7] ^ E[17] ^ E[27] ^ E[37] ^ E[47], J = E[8] ^ E[18] ^ E[28] ^ E[38] ^ E[48], Y = E[9] ^ E[19] ^ E[29] ^ E[39] ^ E[49], R = J ^ (ee << 1 | K >>> 31), G = Y ^ (K << 1 | ee >>> 31), E[0] ^= R, E[1] ^= G, E[10] ^= R, E[11] ^= G, E[20] ^= R, E[21] ^= G, E[30] ^= R, E[31] ^= G, E[40] ^= R, E[41] ^= G, R = j ^ (B << 1 | $ >>> 31), G = re ^ ($ << 1 | B >>> 31), E[2] ^= R, E[3] ^= G, E[12] ^= R, E[13] ^= G, E[22] ^= R, E[23] ^= G, E[32] ^= R, E[33] ^= G, E[42] ^= R, E[43] ^= G, R = ee ^ (H << 1 | ne >>> 31), G = K ^ (ne << 1 | H >>> 31), E[4] ^= R, E[5] ^= G, E[14] ^= R, E[15] ^= G, E[24] ^= R, E[25] ^= G, E[34] ^= R, E[35] ^= G, E[44] ^= R, E[45] ^= G, R = B ^ (J << 1 | Y >>> 31), G = $ ^ (Y << 1 | J >>> 31), E[6] ^= R, E[7] ^= G, E[16] ^= R, E[17] ^= G, E[26] ^= R, E[27] ^= G, E[36] ^= R, E[37] ^= G, E[46] ^= R, E[47] ^= G, R = H ^ (j << 1 | re >>> 31), G = ne ^ (re << 1 | j >>> 31), E[8] ^= R, E[9] ^= G, E[18] ^= R, E[19] ^= G, E[28] ^= R, E[29] ^= G, E[38] ^= R, E[39] ^= G, E[48] ^= R, E[49] ^= G, ue = E[0], te = E[1], _e = E[11] << 4 | E[10] >>> 28, bt = E[10] << 4 | E[11] >>> 28, be = E[20] << 3 | E[21] >>> 29, X = E[21] << 3 | E[20] >>> 29, mr = E[31] << 9 | E[30] >>> 23, yr = E[30] << 9 | E[31] >>> 23, Fe = E[40] << 18 | E[41] >>> 14, Ee = E[41] << 18 | E[40] >>> 14, ge = E[2] << 1 | E[3] >>> 31, Ve = E[3] << 1 | E[2] >>> 31, Z = E[13] << 12 | E[12] >>> 20, se = E[12] << 12 | E[13] >>> 20, Be = E[22] << 10 | E[23] >>> 22, Te = E[23] << 10 | E[22] >>> 22, ae = E[33] << 13 | E[32] >>> 19, oe = E[32] << 13 | E[33] >>> 19, gr = E[42] << 2 | E[43] >>> 30, xr = E[43] << 2 | E[42] >>> 30, Ge = E[5] << 30 | E[4] >>> 2, Ne = E[4] << 30 | E[5] >>> 2, ke = E[14] << 6 | E[15] >>> 26, Ae = E[15] << 6 | E[14] >>> 26, fe = E[25] << 11 | E[24] >>> 21, ie = E[24] << 11 | E[25] >>> 21, vt = E[34] << 15 | E[35] >>> 17, $e = E[35] << 15 | E[34] >>> 17, ve = E[45] << 29 | E[44] >>> 3, ye = E[44] << 29 | E[45] >>> 3, xe = E[6] << 28 | E[7] >>> 4, de = E[7] << 28 | E[6] >>> 4, Et = E[17] << 23 | E[16] >>> 9, De = E[16] << 23 | E[17] >>> 9, et = E[26] << 25 | E[27] >>> 7, Oe = E[27] << 25 | E[26] >>> 7, me = E[36] << 21 | E[37] >>> 11, he = E[37] << 21 | E[36] >>> 11, Me = E[47] << 24 | E[46] >>> 8, wt = E[46] << 24 | E[47] >>> 8, it = E[8] << 27 | E[9] >>> 5, Le = E[9] << 27 | E[8] >>> 5, je = E[18] << 20 | E[19] >>> 12, Ie = E[19] << 20 | E[18] >>> 12, Ue = E[29] << 7 | E[28] >>> 25, pr = E[28] << 7 | E[29] >>> 25, we = E[38] << 8 | E[39] >>> 24, rt = E[39] << 8 | E[38] >>> 24, le = E[48] << 14 | E[49] >>> 18, Pe = E[49] << 14 | E[48] >>> 18, E[0] = ue ^ ~Z & fe, E[1] = te ^ ~se & ie, E[10] = xe ^ ~je & be, E[11] = de ^ ~Ie & X, E[20] = ge ^ ~ke & et, E[21] = Ve ^ ~Ae & Oe, E[30] = it ^ ~_e & Be, E[31] = Le ^ ~bt & Te, E[40] = Ge ^ ~Et & Ue, E[41] = Ne ^ ~De & pr, E[2] = Z ^ ~fe & me, E[3] = se ^ ~ie & he, E[12] = je ^ ~be & ae, E[13] = Ie ^ ~X & oe, E[22] = ke ^ ~et & we, E[23] = Ae ^ ~Oe & rt, E[32] = _e ^ ~Be & vt, E[33] = bt ^ ~Te & $e, E[42] = Et ^ ~Ue & mr, E[43] = De ^ ~pr & yr, E[4] = fe ^ ~me & le, E[5] = ie ^ ~he & Pe, E[14] = be ^ ~ae & ve, E[15] = X ^ ~oe & ye, E[24] = et ^ ~we & Fe, E[25] = Oe ^ ~rt & Ee, E[34] = Be ^ ~vt & Me, E[35] = Te ^ ~$e & wt, E[44] = Ue ^ ~mr & gr, E[45] = pr ^ ~yr & xr, E[6] = me ^ ~le & ue, E[7] = he ^ ~Pe & te, E[16] = ae ^ ~ve & xe, E[17] = oe ^ ~ye & de, E[26] = we ^ ~Fe & ge, E[27] = rt ^ ~Ee & Ve, E[36] = vt ^ ~Me & it, E[37] = $e ^ ~wt & Le, E[46] = mr ^ ~gr & Ge, E[47] = yr ^ ~xr & Ne, E[8] = le ^ ~ue & Z, E[9] = Pe ^ ~te & se, E[18] = ve ^ ~xe & je, E[19] = ye ^ ~de & Ie, E[28] = Fe ^ ~ge & ke, E[29] = Ee ^ ~Ve & Ae, E[38] = Me ^ ~it & _e, E[39] = wt ^ ~Le & bt, E[48] = gr ^ ~Ge & Et, E[49] = xr ^ ~Ne & De, E[0] ^= C[z], E[1] ^= C[z + 1]
        };
        if (f) t.exports = a;
        else
            for (g = 0; g < c.length; ++g) i[c[g]] = a[c[g]]
    })()
})(Gy);
var Ha = Gy.exports;
const y5 = "bytes/5.5.0",
    Mc = new W(y5);

function g5(t) {
    return !!t.toHexString
}

function Su(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Su(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function zy(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function x5(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !zy(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!zy(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function b5(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Mc.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Su(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), g5(t) && (t = t.toHexString()), v5(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Mc.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Su(new Uint8Array(n))
    }
    return x5(t) ? Su(new Uint8Array(t)) : Mc.throwArgumentError("invalid arrayify value", "value", t)
}

function v5(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}

function Kt(t) {
    return "0x" + Ha.keccak_256(b5(t))
}
const w5 = "bytes/5.5.0",
    Lo = new W(w5);

function Hy(t) {
    return !!t.toHexString
}

function Pu(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Pu(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function E5(t) {
    return Sc(t) && !(t.length % 2) || Nc(t)
}

function qy(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function Nc(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !qy(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!qy(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function jy(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Lo.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Pu(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Hy(t) && (t = t.toHexString()), Sc(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Lo.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Pu(new Uint8Array(n))
    }
    return Nc(t) ? Pu(new Uint8Array(t)) : Lo.throwArgumentError("invalid arrayify value", "value", t)
}

function Sc(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const Pc = "0123456789abcdef";

function Iu(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Lo.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = Pc[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Hy(t)) return t.toHexString();
    if (Sc(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Lo.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (Nc(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += Pc[(i & 240) >> 4] + Pc[i & 15]
        }
        return r
    }
    return Lo.throwArgumentError("invalid hexlify value", "value", t)
}
const A5 = "rlp/5.5.0",
    yi = new W(A5);

function Wy(t) {
    const e = [];
    for (; t;) e.unshift(t & 255), t >>= 8;
    return e
}

function Vy(t, e, r) {
    let n = 0;
    for (let i = 0; i < r; i++) n = n * 256 + t[e + i];
    return n
}

function Ky(t) {
    if (Array.isArray(t)) {
        let n = [];
        if (t.forEach(function(s) {
                n = n.concat(Ky(s))
            }), n.length <= 55) return n.unshift(192 + n.length), n;
        const i = Wy(n.length);
        return i.unshift(247 + i.length), i.concat(n)
    }
    E5(t) || yi.throwArgumentError("RLP object must be BytesLike", "object", t);
    const e = Array.prototype.slice.call(jy(t));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const r = Wy(e.length);
    return r.unshift(183 + r.length), r.concat(e)
}

function Ru(t) {
    return Iu(Ky(t))
}

function Xy(t, e, r, n) {
    const i = [];
    for (; r < e + 1 + n;) {
        const s = Jy(t, r);
        i.push(s.result), r += s.consumed, r > e + 1 + n && yi.throwError("child data too short", W.errors.BUFFER_OVERRUN, {})
    }
    return {
        consumed: 1 + n,
        result: i
    }
}

function Jy(t, e) {
    if (t.length === 0 && yi.throwError("data too short", W.errors.BUFFER_OVERRUN, {}), t[e] >= 248) {
        const r = t[e] - 247;
        e + 1 + r > t.length && yi.throwError("data short segment too short", W.errors.BUFFER_OVERRUN, {});
        const n = Vy(t, e + 1, r);
        return e + 1 + r + n > t.length && yi.throwError("data long segment too short", W.errors.BUFFER_OVERRUN, {}), Xy(t, e, e + 1 + r, r + n)
    } else if (t[e] >= 192) {
        const r = t[e] - 192;
        return e + 1 + r > t.length && yi.throwError("data array too short", W.errors.BUFFER_OVERRUN, {}), Xy(t, e, e + 1, r)
    } else if (t[e] >= 184) {
        const r = t[e] - 183;
        e + 1 + r > t.length && yi.throwError("data array too short", W.errors.BUFFER_OVERRUN, {});
        const n = Vy(t, e + 1, r);
        e + 1 + r + n > t.length && yi.throwError("data array too short", W.errors.BUFFER_OVERRUN, {});
        const i = Iu(t.slice(e + 1 + r, e + 1 + r + n));
        return {
            consumed: 1 + r + n,
            result: i
        }
    } else if (t[e] >= 128) {
        const r = t[e] - 128;
        e + 1 + r > t.length && yi.throwError("data too short", W.errors.BUFFER_OVERRUN, {});
        const n = Iu(t.slice(e + 1, e + 1 + r));
        return {
            consumed: 1 + r,
            result: n
        }
    }
    return {
        consumed: 1,
        result: Iu(t[e])
    }
}

function Ic(t) {
    const e = jy(t),
        r = Jy(e, 0);
    return r.consumed !== e.length && yi.throwArgumentError("invalid rlp data", "data", t), r.result
}
const _5 = "address/5.5.0",
    Bo = new W(_5);

function Zy(t) {
    Uo(t, 20) || Bo.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        r = new Uint8Array(40);
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
    const n = Ac(Kt(r));
    for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const T5 = 9007199254740991;

function M5(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const Rc = {};
for (let t = 0; t < 10; t++) Rc[String(t)] = String(t);
for (let t = 0; t < 26; t++) Rc[String.fromCharCode(65 + t)] = String(10 + t);
const Yy = Math.floor(M5(T5));

function N5(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(n => Rc[n]).join("");
    for (; e.length >= Yy;) {
        let n = e.substring(0, Yy);
        e = parseInt(n, 10) % 97 + e.substring(n.length)
    }
    let r = String(98 - parseInt(e, 10) % 97);
    for (; r.length < 2;) r = "0" + r;
    return r
}

function nr(t) {
    let e = null;
    if (typeof t != "string" && Bo.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = Zy(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && Bo.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== N5(t) && Bo.throwArgumentError("bad icap checksum", "address", t), e = m5(t.substring(4)); e.length < 40;) e = "0" + e;
        e = Zy("0x" + e)
    } else Bo.throwArgumentError("invalid address", "address", t);
    return e
}

function FS(t) {
    try {
        return nr(t), !0
    } catch {}
    return !1
}

function Qy(t) {
    let e = null;
    try {
        e = nr(t.from)
    } catch {
        Bo.throwArgumentError("missing from address", "transaction", t)
    }
    const r = h5(Ac(Nr.from(t.nonce).toHexString()));
    return nr(d5(Kt(Ru([e, r])), 12))
}
class S5 extends Xi {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, r) {
        try {
            r = nr(r)
        } catch (n) {
            this._throwError(n.message, r)
        }
        return e.writeValue(r)
    }
    decode(e) {
        return nr(Ny(e.readValue().toHexString(), 20))
    }
}
class P5 extends Xi {
    constructor(e) {
        super(e.name, e.type, void 0, e.dynamic);
        this.coder = e
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, r) {
        return this.coder.encode(e, r)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}
const $o = new W(La);

function eg(t, e, r) {
    let n = null;
    if (Array.isArray(r)) n = r;
    else if (r && typeof r == "object") {
        let l = {};
        n = e.map(d => {
            const p = d.localName;
            return p || $o.throwError("cannot encode object for signature with missing names", W.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: d,
                value: r
            }), l[p] && $o.throwError("cannot encode object for signature with duplicate names", W.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: d,
                value: r
            }), l[p] = !0, r[p]
        })
    } else $o.throwArgumentError("invalid tuple value", "tuple", r);
    e.length !== n.length && $o.throwArgumentError("types/value length mismatch", "tuple", r);
    let i = new wc(t.wordSize),
        s = new wc(t.wordSize),
        o = [];
    e.forEach((l, d) => {
        let p = n[d];
        if (l.dynamic) {
            let A = s.length;
            l.encode(s, p);
            let T = i.writeUpdatableValue();
            o.push(N => {
                T(N + A)
            })
        } else l.encode(i, p)
    }), o.forEach(l => {
        l(i.length)
    });
    let f = t.appendWriter(i);
    return f += t.appendWriter(s), f
}

function tg(t, e) {
    let r = [],
        n = t.subReader(0);
    e.forEach(s => {
        let o = null;
        if (s.dynamic) {
            let f = t.readValue(),
                l = n.subReader(f.toNumber());
            try {
                o = s.decode(l)
            } catch (d) {
                if (d.code === W.errors.BUFFER_OVERRUN) throw d;
                o = d, o.baseType = s.name, o.name = s.localName, o.type = s.type
            }
        } else try {
            o = s.decode(t)
        } catch (f) {
            if (f.code === W.errors.BUFFER_OVERRUN) throw f;
            o = f, o.baseType = s.name, o.name = s.localName, o.type = s.type
        }
        o != null && r.push(o)
    });
    const i = e.reduce((s, o) => {
        const f = o.localName;
        return f && (s[f] || (s[f] = 0), s[f]++), s
    }, {});
    e.forEach((s, o) => {
        let f = s.localName;
        if (!f || i[f] !== 1 || (f === "length" && (f = "_length"), r[f] != null)) return;
        const l = r[o];
        l instanceof Error ? Object.defineProperty(r, f, {
            enumerable: !0,
            get: () => {
                throw l
            }
        }) : r[f] = l
    });
    for (let s = 0; s < r.length; s++) {
        const o = r[s];
        o instanceof Error && Object.defineProperty(r, s, {
            enumerable: !0,
            get: () => {
                throw o
            }
        })
    }
    return Object.freeze(r)
}
class I5 extends Xi {
    constructor(e, r, n) {
        const i = e.type + "[" + (r >= 0 ? r : "") + "]",
            s = r === -1 || e.dynamic;
        super("array", i, n, s);
        this.coder = e, this.length = r
    }
    defaultValue() {
        const e = this.coder.defaultValue(),
            r = [];
        for (let n = 0; n < this.length; n++) r.push(e);
        return r
    }
    encode(e, r) {
        Array.isArray(r) || this._throwError("expected array value", r);
        let n = this.length;
        n === -1 && (n = r.length, e.writeValue(r.length)), $o.checkArgumentCount(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
        let i = [];
        for (let s = 0; s < r.length; s++) i.push(this.coder);
        return eg(e, i, r)
    }
    decode(e) {
        let r = this.length;
        r === -1 && (r = e.readValue().toNumber(), r * 32 > e._data.length && $o.throwError("insufficient data length", W.errors.BUFFER_OVERRUN, {
            length: e._data.length,
            count: r
        }));
        let n = [];
        for (let i = 0; i < r; i++) n.push(new P5(this.coder));
        return e.coerce(this.name, tg(e, n))
    }
}
class R5 extends Xi {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, r) {
        return e.writeValue(r ? 1 : 0)
    }
    decode(e) {
        return e.coerce(this.type, !e.readValue().isZero())
    }
}
class rg extends Xi {
    constructor(e, r) {
        super(e, e, r, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, r) {
        r = $n(r);
        let n = e.writeValue(r.length);
        return n += e.writeBytes(r), n
    }
    decode(e) {
        return e.readBytes(e.readValue().toNumber(), !0)
    }
}
class k5 extends rg {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return e.coerce(this.name, tr(super.decode(e)))
    }
}
class O5 extends Xi {
    constructor(e, r) {
        let n = "bytes" + String(e);
        super(n, n, r, !1);
        this.size = e
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, r) {
        let n = $n(r);
        return n.length !== this.size && this._throwError("incorrect data length", r), e.writeBytes(n)
    }
    decode(e) {
        return e.coerce(this.name, tr(e.readBytes(this.size)))
    }
}
class C5 extends Xi {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, r) {
        return r != null && this._throwError("not null", r), e.writeBytes([])
    }
    decode(e) {
        return e.readBytes(0), e.coerce(this.name, null)
    }
}
const F5 = "0x0000000000000000000000000000000000000000",
    D5 = "bytes/5.5.0",
    kc = new W(D5);

function U5(t) {
    return !!t.toHexString
}

function ng(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function ig(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !ng(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!ng(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Oc(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const Cc = "0123456789abcdef";

function L5(t, e) {
    if (e || (e = {}), typeof t == "number") {
        kc.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = Cc[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), U5(t)) return t.toHexString();
    if (Oc(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : kc.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (ig(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += Cc[(i & 240) >> 4] + Cc[i & 15]
        }
        return r
    }
    return kc.throwArgumentError("invalid hexlify value", "value", t)
}
const B5 = "bignumber/5.5.0";
var Fc = He.BN;
const gi = new W(B5),
    Dc = {},
    sg = 9007199254740991;
let og = !1;
class ir {
    constructor(e, r) {
        gi.checkNew(new.target, ir), e !== Dc && gi.throwError("cannot call constructor directly; use BigNumber.from", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Fr(at(this).fromTwos(e))
    }
    toTwos(e) {
        return Fr(at(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? ir.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Fr(at(this).add(at(e)))
    }
    sub(e) {
        return Fr(at(this).sub(at(e)))
    }
    div(e) {
        return ir.from(e).isZero() && an("division by zero", "div"), Fr(at(this).div(at(e)))
    }
    mul(e) {
        return Fr(at(this).mul(at(e)))
    }
    mod(e) {
        const r = at(e);
        return r.isNeg() && an("cannot modulo negative values", "mod"), Fr(at(this).umod(r))
    }
    pow(e) {
        const r = at(e);
        return r.isNeg() && an("cannot raise to negative values", "pow"), Fr(at(this).pow(r))
    }
    and(e) {
        const r = at(e);
        return (this.isNegative() || r.isNeg()) && an("cannot 'and' negative values", "and"), Fr(at(this).and(r))
    }
    or(e) {
        const r = at(e);
        return (this.isNegative() || r.isNeg()) && an("cannot 'or' negative values", "or"), Fr(at(this).or(r))
    }
    xor(e) {
        const r = at(e);
        return (this.isNegative() || r.isNeg()) && an("cannot 'xor' negative values", "xor"), Fr(at(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && an("cannot mask negative values", "mask"), Fr(at(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && an("cannot shift negative values", "shl"), Fr(at(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && an("cannot shift negative values", "shr"), Fr(at(this).shrn(e))
    }
    eq(e) {
        return at(this).eq(at(e))
    }
    lt(e) {
        return at(this).lt(at(e))
    }
    lte(e) {
        return at(this).lte(at(e))
    }
    gt(e) {
        return at(this).gt(at(e))
    }
    gte(e) {
        return at(this).gte(at(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return at(this).isZero()
    }
    toNumber() {
        try {
            return at(this).toNumber()
        } catch {
            an("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return gi.throwError("this platform does not support BigInt", W.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? og || (og = !0, gi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? gi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", W.errors.UNEXPECTED_ARGUMENT, {}) : gi.throwError("BigNumber.toString does not accept parameters", W.errors.UNEXPECTED_ARGUMENT, {})), at(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof ir) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new ir(Dc, qa(e)) : e.match(/^-?[0-9]+$/) ? new ir(Dc, qa(new Fc(e))) : gi.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && an("underflow", "BigNumber.from", e), (e >= sg || e <= -sg) && an("overflow", "BigNumber.from", e), ir.from(String(e));
        const r = e;
        if (typeof r == "bigint") return ir.from(r.toString());
        if (ig(r)) return ir.from(L5(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return ir.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Oc(n) || n[0] === "-" && Oc(n.substring(1)))) return ir.from(n)
            }
        return gi.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function qa(t) {
    if (typeof t != "string") return qa(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && gi.throwArgumentError("invalid hex", "value", t), t = qa(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Fr(t) {
    return ir.from(qa(t))
}

function at(t) {
    const e = ir.from(t).toHexString();
    return e[0] === "-" ? new Fc("-" + e.substring(3), 16) : new Fc(e.substring(2), 16)
}

function an(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), gi.throwError(t, W.errors.NUMERIC_FAULT, n)
}
const $5 = ir.from(-1),
    ag = ir.from(0),
    G5 = ir.from(1),
    z5 = ir.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    H5 = "0x0000000000000000000000000000000000000000000000000000000000000000";
class q5 extends Xi {
    constructor(e, r, n) {
        const i = (r ? "int" : "uint") + e * 8;
        super(i, i, n, !1);
        this.size = e, this.signed = r
    }
    defaultValue() {
        return 0
    }
    encode(e, r) {
        let n = St.from(r),
            i = z5.mask(e.wordSize * 8);
        if (this.signed) {
            let s = i.mask(this.size * 8 - 1);
            (n.gt(s) || n.lt(s.add(G5).mul($5))) && this._throwError("value out-of-bounds", r)
        } else(n.lt(ag) || n.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", r);
        return n = n.toTwos(this.size * 8).mask(this.size * 8), this.signed && (n = n.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(n)
    }
    decode(e) {
        let r = e.readValue().mask(this.size * 8);
        return this.signed && (r = r.fromTwos(this.size * 8)), e.coerce(this.name, r)
    }
}
const j5 = "bytes/5.5.0",
    Uc = new W(j5);

function W5(t) {
    return !!t.toHexString
}

function ku(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return ku(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function fg(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function V5(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !fg(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!fg(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function ug(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Uc.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), ku(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), W5(t) && (t = t.toHexString()), K5(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Uc.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return ku(new Uint8Array(n))
    }
    return V5(t) ? ku(new Uint8Array(t)) : Uc.throwArgumentError("invalid arrayify value", "value", t)
}

function K5(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const X5 = "strings/5.5.0",
    lg = new W(X5);
var Go;
(function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD"
})(Go || (Go = {}));
var Vr;
(function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation"
})(Vr || (Vr = {}));

function J5(t, e, r, n, i) {
    return lg.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
}

function cg(t, e, r, n, i) {
    if (t === Vr.BAD_PREFIX || t === Vr.UNEXPECTED_CONTINUE) {
        let s = 0;
        for (let o = e + 1; o < r.length && r[o] >> 6 == 2; o++) s++;
        return s
    }
    return t === Vr.OVERRUN ? r.length - e - 1 : 0
}

function Z5(t, e, r, n, i) {
    return t === Vr.OVERLONG ? (n.push(i), 0) : (n.push(65533), cg(t, e, r))
}
const Y5 = Object.freeze({
    error: J5,
    ignore: cg,
    replace: Z5
});

function hg(t, e) {
    e == null && (e = Y5.error), t = ug(t);
    const r = [];
    let n = 0;
    for (; n < t.length;) {
        const i = t[n++];
        if (i >> 7 == 0) {
            r.push(i);
            continue
        }
        let s = null,
            o = null;
        if ((i & 224) == 192) s = 1, o = 127;
        else if ((i & 240) == 224) s = 2, o = 2047;
        else if ((i & 248) == 240) s = 3, o = 65535;
        else {
            (i & 192) == 128 ? n += e(Vr.UNEXPECTED_CONTINUE, n - 1, t, r) : n += e(Vr.BAD_PREFIX, n - 1, t, r);
            continue
        }
        if (n - 1 + s >= t.length) {
            n += e(Vr.OVERRUN, n - 1, t, r);
            continue
        }
        let f = i & (1 << 8 - s - 1) - 1;
        for (let l = 0; l < s; l++) {
            let d = t[n];
            if ((d & 192) != 128) {
                n += e(Vr.MISSING_CONTINUE, n, t, r), f = null;
                break
            }
            f = f << 6 | d & 63, n++
        }
        if (f !== null) {
            if (f > 1114111) {
                n += e(Vr.OUT_OF_RANGE, n - 1 - s, t, r, f);
                continue
            }
            if (f >= 55296 && f <= 57343) {
                n += e(Vr.UTF16_SURROGATE, n - 1 - s, t, r, f);
                continue
            }
            if (f <= o) {
                n += e(Vr.OVERLONG, n - 1 - s, t, r, f);
                continue
            }
            r.push(f)
        }
    }
    return r
}

function xi(t, e = Go.current) {
    e != Go.current && (lg.checkNormalize(), t = t.normalize(e));
    let r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t.charCodeAt(n);
        if (i < 128) r.push(i);
        else if (i < 2048) r.push(i >> 6 | 192), r.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            n++;
            const s = t.charCodeAt(n);
            if (n >= t.length || (s & 64512) != 56320) throw new Error("invalid utf-8 string");
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128)
        } else r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128)
    }
    return ug(r)
}

function Lc(t) {
    return t.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}

function zo(t, e) {
    return Lc(hg(t, e))
}

function dg(t, e = Go.current) {
    return hg(xi(t, e))
}

function Q5(t) {
    if (t.length % 4 != 0) throw new Error("bad data");
    let e = [];
    for (let r = 0; r < t.length; r += 4) e.push(parseInt(t.substring(r, r + 4), 16));
    return e
}

function Bc(t, e) {
    e || (e = function(i) {
        return [parseInt(i, 16)]
    });
    let r = 0,
        n = {};
    return t.split(",").forEach(i => {
        let s = i.split(":");
        r += parseInt(s[0], 16), n[r] = e(s[1])
    }), n
}

function pg(t) {
    let e = 0;
    return t.split(",").map(r => {
        let n = r.split("-");
        n.length === 1 ? n[1] = "0" : n[1] === "" && (n[1] = "1");
        let i = e + parseInt(n[0], 16);
        return e = parseInt(n[1], 16), {
            l: i,
            h: e
        }
    })
}

function $c(t, e) {
    let r = 0;
    for (let n = 0; n < e.length; n++) {
        let i = e[n];
        if (r += i.l, t >= r && t <= r + i.h && (t - r) % (i.d || 1) == 0) {
            if (i.e && i.e.indexOf(t - r) !== -1) continue;
            return i
        }
    }
    return null
}
const eE = pg("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"),
    tE = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(t => parseInt(t, 16)),
    rE = [{
        h: 25,
        s: 32,
        l: 65
    }, {
        h: 30,
        s: 32,
        e: [23],
        l: 127
    }, {
        h: 54,
        s: 1,
        e: [48],
        l: 64,
        d: 2
    }, {
        h: 14,
        s: 1,
        l: 57,
        d: 2
    }, {
        h: 44,
        s: 1,
        l: 17,
        d: 2
    }, {
        h: 10,
        s: 1,
        e: [2, 6, 8],
        l: 61,
        d: 2
    }, {
        h: 16,
        s: 1,
        l: 68,
        d: 2
    }, {
        h: 84,
        s: 1,
        e: [18, 24, 66],
        l: 19,
        d: 2
    }, {
        h: 26,
        s: 32,
        e: [17],
        l: 435
    }, {
        h: 22,
        s: 1,
        l: 71,
        d: 2
    }, {
        h: 15,
        s: 80,
        l: 40
    }, {
        h: 31,
        s: 32,
        l: 16
    }, {
        h: 32,
        s: 1,
        l: 80,
        d: 2
    }, {
        h: 52,
        s: 1,
        l: 42,
        d: 2
    }, {
        h: 12,
        s: 1,
        l: 55,
        d: 2
    }, {
        h: 40,
        s: 1,
        e: [38],
        l: 15,
        d: 2
    }, {
        h: 14,
        s: 1,
        l: 48,
        d: 2
    }, {
        h: 37,
        s: 48,
        l: 49
    }, {
        h: 148,
        s: 1,
        l: 6351,
        d: 2
    }, {
        h: 88,
        s: 1,
        l: 160,
        d: 2
    }, {
        h: 15,
        s: 16,
        l: 704
    }, {
        h: 25,
        s: 26,
        l: 854
    }, {
        h: 25,
        s: 32,
        l: 55915
    }, {
        h: 37,
        s: 40,
        l: 1247
    }, {
        h: 25,
        s: -119711,
        l: 53248
    }, {
        h: 25,
        s: -119763,
        l: 52
    }, {
        h: 25,
        s: -119815,
        l: 52
    }, {
        h: 25,
        s: -119867,
        e: [1, 4, 5, 7, 8, 11, 12, 17],
        l: 52
    }, {
        h: 25,
        s: -119919,
        l: 52
    }, {
        h: 24,
        s: -119971,
        e: [2, 7, 8, 17],
        l: 52
    }, {
        h: 24,
        s: -120023,
        e: [2, 7, 13, 15, 16, 17],
        l: 52
    }, {
        h: 25,
        s: -120075,
        l: 52
    }, {
        h: 25,
        s: -120127,
        l: 52
    }, {
        h: 25,
        s: -120179,
        l: 52
    }, {
        h: 25,
        s: -120231,
        l: 52
    }, {
        h: 25,
        s: -120283,
        l: 52
    }, {
        h: 25,
        s: -120335,
        l: 52
    }, {
        h: 24,
        s: -119543,
        e: [17],
        l: 56
    }, {
        h: 24,
        s: -119601,
        e: [17],
        l: 58
    }, {
        h: 24,
        s: -119659,
        e: [17],
        l: 58
    }, {
        h: 24,
        s: -119717,
        e: [17],
        l: 58
    }, {
        h: 24,
        s: -119775,
        e: [17],
        l: 58
    }],
    nE = Bc("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"),
    iE = Bc("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"),
    sE = Bc("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", Q5),
    oE = pg("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

function aE(t) {
    return t.reduce((e, r) => (r.forEach(n => {
        e.push(n)
    }), e), [])
}

function fE(t) {
    return !!$c(t, eE)
}

function uE(t) {
    let e = $c(t, rE);
    if (e) return [t + e.s];
    let r = nE[t];
    if (r) return r;
    let n = iE[t];
    if (n) return [t + n[0]];
    let i = sE[t];
    return i || null
}

function lE(t) {
    return !!$c(t, oE)
}

function cE(t) {
    if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase();
    let e = dg(t);
    e = aE(e.map(n => {
        if (tE.indexOf(n) >= 0) return [];
        if (n >= 65024 && n <= 65039) return [];
        let i = uE(n);
        return i || [n]
    })), e = dg(Lc(e), Go.NFKC), e.forEach(n => {
        if (lE(n)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED")
    }), e.forEach(n => {
        if (fE(n)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")
    });
    let r = Lc(e);
    if (r.substring(0, 1) === "-" || r.substring(2, 4) === "--" || r.substring(r.length - 1) === "-") throw new Error("invalid hyphen");
    if (r.length > 63) throw new Error("too long");
    return r
}
class hE extends rg {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, r) {
        return super.encode(e, xi(r))
    }
    decode(e) {
        return zo(super.decode(e))
    }
}
class Ou extends Xi {
    constructor(e, r) {
        let n = !1;
        const i = [];
        e.forEach(o => {
            o.dynamic && (n = !0), i.push(o.type)
        });
        const s = "tuple(" + i.join(",") + ")";
        super("tuple", s, r, n);
        this.coders = e
    }
    defaultValue() {
        const e = [];
        this.coders.forEach(n => {
            e.push(n.defaultValue())
        });
        const r = this.coders.reduce((n, i) => {
            const s = i.localName;
            return s && (n[s] || (n[s] = 0), n[s]++), n
        }, {});
        return this.coders.forEach((n, i) => {
            let s = n.localName;
            !s || r[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]))
        }), Object.freeze(e)
    }
    encode(e, r) {
        return eg(e, this.coders, r)
    }
    decode(e) {
        return e.coerce(this.name, tg(e, this.coders))
    }
}
const ja = new W(La),
    dE = new RegExp(/^bytes([0-9]*)$/),
    pE = new RegExp(/^(u?int)([0-9]*)$/);
class Gc {
    constructor(e) {
        ja.checkNew(new.target, Gc), pe(this, "coerceFunc", e || null)
    }
    _getCoder(e) {
        switch (e.baseType) {
            case "address":
                return new S5(e.name);
            case "bool":
                return new R5(e.name);
            case "string":
                return new hE(e.name);
            case "bytes":
                return new k5(e.name);
            case "array":
                return new I5(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
            case "tuple":
                return new Ou((e.components || []).map(n => this._getCoder(n)), e.name);
            case "":
                return new C5(e.name)
        }
        let r = e.type.match(pE);
        if (r) {
            let n = parseInt(r[2] || "256");
            return (n === 0 || n > 256 || n % 8 != 0) && ja.throwArgumentError("invalid " + r[1] + " bit length", "param", e), new q5(n / 8, r[1] === "int", e.name)
        }
        if (r = e.type.match(dE), r) {
            let n = parseInt(r[1]);
            return (n === 0 || n > 32) && ja.throwArgumentError("invalid bytes length", "param", e), new O5(n, e.name)
        }
        return ja.throwArgumentError("invalid type", "type", e.type)
    }
    _getWordSize() {
        return 32
    }
    _getReader(e, r) {
        return new Tu(e, this._getWordSize(), this.coerceFunc, r)
    }
    _getWriter() {
        return new wc(this._getWordSize())
    }
    getDefaultValue(e) {
        const r = e.map(i => this._getCoder(rr.from(i)));
        return new Ou(r, "_").defaultValue()
    }
    encode(e, r) {
        e.length !== r.length && ja.throwError("types/values length mismatch", W.errors.INVALID_ARGUMENT, {
            count: {
                types: e.length,
                values: r.length
            },
            value: {
                types: e,
                values: r
            }
        });
        const n = e.map(o => this._getCoder(rr.from(o))),
            i = new Ou(n, "_"),
            s = this._getWriter();
        return i.encode(s, r), s.data
    }
    decode(e, r, n) {
        const i = e.map(o => this._getCoder(rr.from(o)));
        return new Ou(i, "_").decode(this._getReader($n(r), n))
    }
}
const mE = new Gc;

function Cu(t) {
    return Kt(xi(t))
}
const Ot = new W(La);
class yE extends Ua {}
class gE extends Ua {}
class xE extends Ua {}
class zc extends Ua {
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const bE = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: !0
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"]
    }
};

function mg(t, e) {
    const r = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
    return r.error = e, r
}
class Fu {
    constructor(e) {
        Ot.checkNew(new.target, Fu);
        let r = [];
        typeof e == "string" ? r = JSON.parse(e) : r = e, pe(this, "fragments", r.map(n => Vi.from(n)).filter(n => n != null)), pe(this, "_abiCoder", hi(new.target, "getAbiCoder")()), pe(this, "functions", {}), pe(this, "errors", {}), pe(this, "events", {}), pe(this, "structs", {}), this.fragments.forEach(n => {
            let i = null;
            switch (n.type) {
                case "constructor":
                    if (this.deploy) {
                        Ot.warn("duplicate definition - constructor");
                        return
                    }
                    pe(this, "deploy", n);
                    return;
                case "function":
                    i = this.functions;
                    break;
                case "event":
                    i = this.events;
                    break;
                case "error":
                    i = this.errors;
                    break;
                default:
                    return
            }
            let s = n.format();
            if (i[s]) {
                Ot.warn("duplicate definition - " + s);
                return
            }
            i[s] = n
        }), this.deploy || pe(this, "deploy", di.from({
            payable: !1,
            type: "constructor"
        })), pe(this, "_isInterface", !0)
    }
    format(e) {
        e || (e = gt.full), e === gt.sighash && Ot.throwArgumentError("interface does not support formatting sighash", "format", e);
        const r = this.fragments.map(n => n.format(e));
        return e === gt.json ? JSON.stringify(r.map(n => JSON.parse(n))) : r
    }
    static getAbiCoder() {
        return mE
    }
    static getAddress(e) {
        return nr(e)
    }
    static getSighash(e) {
        return Z3(Cu(e.format()), 0, 4)
    }
    static getEventTopic(e) {
        return Cu(e.format())
    }
    getFunction(e) {
        if (Gn(e)) {
            for (const n in this.functions)
                if (e === this.getSighash(n)) return this.functions[n];
            Ot.throwArgumentError("no matching function", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.functions).filter(s => s.split("(")[0] === n);
            return i.length === 0 ? Ot.throwArgumentError("no matching function", "name", n) : i.length > 1 && Ot.throwArgumentError("multiple matching functions", "name", n), this.functions[i[0]]
        }
        const r = this.functions[pi.fromString(e).format()];
        return r || Ot.throwArgumentError("no matching function", "signature", e), r
    }
    getEvent(e) {
        if (Gn(e)) {
            const n = e.toLowerCase();
            for (const i in this.events)
                if (n === this.getEventTopic(i)) return this.events[i];
            Ot.throwArgumentError("no matching event", "topichash", n)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.events).filter(s => s.split("(")[0] === n);
            return i.length === 0 ? Ot.throwArgumentError("no matching event", "name", n) : i.length > 1 && Ot.throwArgumentError("multiple matching events", "name", n), this.events[i[0]]
        }
        const r = this.events[Ki.fromString(e).format()];
        return r || Ot.throwArgumentError("no matching event", "signature", e), r
    }
    getError(e) {
        if (Gn(e)) {
            const n = hi(this.constructor, "getSighash");
            for (const i in this.errors) {
                const s = this.errors[i];
                if (e === n(s)) return this.errors[i]
            }
            Ot.throwArgumentError("no matching error", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.errors).filter(s => s.split("(")[0] === n);
            return i.length === 0 ? Ot.throwArgumentError("no matching error", "name", n) : i.length > 1 && Ot.throwArgumentError("multiple matching errors", "name", n), this.errors[i[0]]
        }
        const r = this.errors[pi.fromString(e).format()];
        return r || Ot.throwArgumentError("no matching error", "signature", e), r
    }
    getSighash(e) {
        if (typeof e == "string") try {
            e = this.getFunction(e)
        } catch (r) {
            try {
                e = this.getError(e)
            } catch {
                throw r
            }
        }
        return hi(this.constructor, "getSighash")(e)
    }
    getEventTopic(e) {
        return typeof e == "string" && (e = this.getEvent(e)), hi(this.constructor, "getEventTopic")(e)
    }
    _decodeParams(e, r) {
        return this._abiCoder.decode(e, r)
    }
    _encodeParams(e, r) {
        return this._abiCoder.encode(e, r)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, r) {
        typeof e == "string" && (e = this.getError(e));
        const n = $n(r);
        return tr(n.slice(0, 4)) !== this.getSighash(e) && Ot.throwArgumentError(`data signature does not match error ${e.name}.`, "data", tr(n)), this._decodeParams(e.inputs, n.slice(4))
    }
    encodeErrorResult(e, r) {
        return typeof e == "string" && (e = this.getError(e)), tr(Fo([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    }
    decodeFunctionData(e, r) {
        typeof e == "string" && (e = this.getFunction(e));
        const n = $n(r);
        return tr(n.slice(0, 4)) !== this.getSighash(e) && Ot.throwArgumentError(`data signature does not match function ${e.name}.`, "data", tr(n)), this._decodeParams(e.inputs, n.slice(4))
    }
    encodeFunctionData(e, r) {
        return typeof e == "string" && (e = this.getFunction(e)), tr(Fo([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    }
    decodeFunctionResult(e, r) {
        typeof e == "string" && (e = this.getFunction(e));
        let n = $n(r),
            i = null,
            s = null,
            o = null,
            f = null;
        switch (n.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(e.outputs, n)
                } catch {}
                break;
            case 4:
                {
                    const l = tr(n.slice(0, 4)),
                        d = bE[l];
                    if (d) s = this._abiCoder.decode(d.inputs, n.slice(4)),
                    o = d.name,
                    f = d.signature,
                    d.reason && (i = s[0]);
                    else try {
                        const p = this.getError(l);
                        s = this._abiCoder.decode(p.inputs, n.slice(4)), o = p.name, f = p.format()
                    } catch (p) {
                        console.log(p)
                    }
                    break
                }
        }
        return Ot.throwError("call revert exception", W.errors.CALL_EXCEPTION, {
            method: e.format(),
            errorArgs: s,
            errorName: o,
            errorSignature: f,
            reason: i
        })
    }
    encodeFunctionResult(e, r) {
        return typeof e == "string" && (e = this.getFunction(e)), tr(this._abiCoder.encode(e.outputs, r || []))
    }
    encodeFilterTopics(e, r) {
        typeof e == "string" && (e = this.getEvent(e)), r.length > e.inputs.length && Ot.throwError("too many arguments for " + e.format(), W.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: r
        });
        let n = [];
        e.anonymous || n.push(this.getEventTopic(e));
        const i = (s, o) => s.type === "string" ? Cu(o) : s.type === "bytes" ? Kt(tr(o)) : (s.type === "address" && this._abiCoder.encode(["address"], [o]), Ny(tr(o), 32));
        for (r.forEach((s, o) => {
                let f = e.inputs[o];
                if (!f.indexed) {
                    s != null && Ot.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + f.name, s);
                    return
                }
                s == null ? n.push(null) : f.baseType === "array" || f.baseType === "tuple" ? Ot.throwArgumentError("filtering with tuples or arrays not supported", "contract." + f.name, s) : Array.isArray(s) ? n.push(s.map(l => i(f, l))) : n.push(i(f, s))
            }); n.length && n[n.length - 1] === null;) n.pop();
        return n
    }
    encodeEventLog(e, r) {
        typeof e == "string" && (e = this.getEvent(e));
        const n = [],
            i = [],
            s = [];
        return e.anonymous || n.push(this.getEventTopic(e)), r.length !== e.inputs.length && Ot.throwArgumentError("event arguments/values mismatch", "values", r), e.inputs.forEach((o, f) => {
            const l = r[f];
            if (o.indexed)
                if (o.type === "string") n.push(Cu(l));
                else if (o.type === "bytes") n.push(Kt(l));
            else {
                if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
                n.push(this._abiCoder.encode([o.type], [l]))
            } else i.push(o), s.push(l)
        }), {
            data: this._abiCoder.encode(i, s),
            topics: n
        }
    }
    decodeEventLog(e, r, n) {
        if (typeof e == "string" && (e = this.getEvent(e)), n != null && !e.anonymous) {
            let T = this.getEventTopic(e);
            (!Gn(n[0], 32) || n[0].toLowerCase() !== T) && Ot.throwError("fragment/topic mismatch", W.errors.INVALID_ARGUMENT, {
                argument: "topics[0]",
                expected: T,
                value: n[0]
            }), n = n.slice(1)
        }
        let i = [],
            s = [],
            o = [];
        e.inputs.forEach((T, N) => {
            T.indexed ? T.type === "string" || T.type === "bytes" || T.baseType === "tuple" || T.baseType === "array" ? (i.push(rr.fromObject({
                type: "bytes32",
                name: T.name
            })), o.push(!0)) : (i.push(T), o.push(!1)) : (s.push(T), o.push(!1))
        });
        let f = n != null ? this._abiCoder.decode(i, Fo(n)) : null,
            l = this._abiCoder.decode(s, r, !0),
            d = [],
            p = 0,
            A = 0;
        e.inputs.forEach((T, N) => {
            if (T.indexed)
                if (f == null) d[N] = new zc({
                    _isIndexed: !0,
                    hash: null
                });
                else if (o[N]) d[N] = new zc({
                _isIndexed: !0,
                hash: f[A++]
            });
            else try {
                d[N] = f[A++]
            } catch (P) {
                d[N] = P
            } else try {
                d[N] = l[p++]
            } catch (P) {
                d[N] = P
            }
            if (T.name && d[T.name] == null) {
                const P = d[N];
                P instanceof Error ? Object.defineProperty(d, T.name, {
                    enumerable: !0,
                    get: () => {
                        throw mg(`property ${JSON.stringify(T.name)}`, P)
                    }
                }) : d[T.name] = P
            }
        });
        for (let T = 0; T < d.length; T++) {
            const N = d[T];
            N instanceof Error && Object.defineProperty(d, T, {
                enumerable: !0,
                get: () => {
                    throw mg(`index ${T}`, N)
                }
            })
        }
        return Object.freeze(d)
    }
    parseTransaction(e) {
        let r = this.getFunction(e.data.substring(0, 10).toLowerCase());
        return r ? new gE({
            args: this._abiCoder.decode(r.inputs, "0x" + e.data.substring(10)),
            functionFragment: r,
            name: r.name,
            signature: r.format(),
            sighash: this.getSighash(r),
            value: St.from(e.value || "0")
        }) : null
    }
    parseLog(e) {
        let r = this.getEvent(e.topics[0]);
        return !r || r.anonymous ? null : new yE({
            eventFragment: r,
            name: r.name,
            signature: r.format(),
            topic: this.getEventTopic(r),
            args: this.decodeEventLog(r, e.data, e.topics)
        })
    }
    parseError(e) {
        const r = tr(e);
        let n = this.getError(r.substring(0, 10).toLowerCase());
        return n ? new xE({
            args: this._abiCoder.decode(n.inputs, "0x" + r.substring(10)),
            errorFragment: n,
            name: n.name,
            signature: n.format(),
            sighash: this.getSighash(n)
        }) : null
    }
    static isInterface(e) {
        return !!(e && e._isInterface)
    }
}
const vE = "bytes/5.5.0",
    Hc = new W(vE);

function wE(t) {
    return !!t.toHexString
}

function yg(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function gg(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !yg(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!yg(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function qc(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const jc = "0123456789abcdef";

function EE(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Hc.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = jc[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), wE(t)) return t.toHexString();
    if (qc(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Hc.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (gg(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += jc[(i & 240) >> 4] + jc[i & 15]
        }
        return r
    }
    return Hc.throwArgumentError("invalid hexlify value", "value", t)
}
const AE = "bignumber/5.5.0";
var Wc = He.BN;
const bi = new W(AE),
    Vc = {},
    xg = 9007199254740991;
let bg = !1;
class Sr {
    constructor(e, r) {
        bi.checkNew(new.target, Sr), e !== Vc && bi.throwError("cannot call constructor directly; use BigNumber.from", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Dr(ft(this).fromTwos(e))
    }
    toTwos(e) {
        return Dr(ft(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? Sr.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Dr(ft(this).add(ft(e)))
    }
    sub(e) {
        return Dr(ft(this).sub(ft(e)))
    }
    div(e) {
        return Sr.from(e).isZero() && fn("division by zero", "div"), Dr(ft(this).div(ft(e)))
    }
    mul(e) {
        return Dr(ft(this).mul(ft(e)))
    }
    mod(e) {
        const r = ft(e);
        return r.isNeg() && fn("cannot modulo negative values", "mod"), Dr(ft(this).umod(r))
    }
    pow(e) {
        const r = ft(e);
        return r.isNeg() && fn("cannot raise to negative values", "pow"), Dr(ft(this).pow(r))
    }
    and(e) {
        const r = ft(e);
        return (this.isNegative() || r.isNeg()) && fn("cannot 'and' negative values", "and"), Dr(ft(this).and(r))
    }
    or(e) {
        const r = ft(e);
        return (this.isNegative() || r.isNeg()) && fn("cannot 'or' negative values", "or"), Dr(ft(this).or(r))
    }
    xor(e) {
        const r = ft(e);
        return (this.isNegative() || r.isNeg()) && fn("cannot 'xor' negative values", "xor"), Dr(ft(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && fn("cannot mask negative values", "mask"), Dr(ft(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && fn("cannot shift negative values", "shl"), Dr(ft(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && fn("cannot shift negative values", "shr"), Dr(ft(this).shrn(e))
    }
    eq(e) {
        return ft(this).eq(ft(e))
    }
    lt(e) {
        return ft(this).lt(ft(e))
    }
    lte(e) {
        return ft(this).lte(ft(e))
    }
    gt(e) {
        return ft(this).gt(ft(e))
    }
    gte(e) {
        return ft(this).gte(ft(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return ft(this).isZero()
    }
    toNumber() {
        try {
            return ft(this).toNumber()
        } catch {
            fn("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return bi.throwError("this platform does not support BigInt", W.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? bg || (bg = !0, bi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? bi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", W.errors.UNEXPECTED_ARGUMENT, {}) : bi.throwError("BigNumber.toString does not accept parameters", W.errors.UNEXPECTED_ARGUMENT, {})), ft(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof Sr) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new Sr(Vc, Wa(e)) : e.match(/^-?[0-9]+$/) ? new Sr(Vc, Wa(new Wc(e))) : bi.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && fn("underflow", "BigNumber.from", e), (e >= xg || e <= -xg) && fn("overflow", "BigNumber.from", e), Sr.from(String(e));
        const r = e;
        if (typeof r == "bigint") return Sr.from(r.toString());
        if (gg(r)) return Sr.from(EE(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return Sr.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (qc(n) || n[0] === "-" && qc(n.substring(1)))) return Sr.from(n)
            }
        return bi.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function Wa(t) {
    if (typeof t != "string") return Wa(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && bi.throwArgumentError("invalid hex", "value", t), t = Wa(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Dr(t) {
    return Sr.from(Wa(t))
}

function ft(t) {
    const e = Sr.from(t).toHexString();
    return e[0] === "-" ? new Wc("-" + e.substring(3), 16) : new Wc(e.substring(2), 16)
}

function fn(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), bi.throwError(t, W.errors.NUMERIC_FAULT, n)
}
const _E = "abstract-provider/5.5.1";
var TE = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const ME = new W(_E);
class NE extends Ua {
    static isForkEvent(e) {
        return !!(e && e._isForkEvent)
    }
}
class Va {
    constructor() {
        ME.checkAbstract(new.target, Va), pe(this, "_isProvider", !0)
    }
    getFeeData() {
        return TE(this, void 0, void 0, function*() {
            const {
                block: e,
                gasPrice: r
            } = yield kt({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch(s => null)
            });
            let n = null,
                i = null;
            return e && e.baseFeePerGas && (i = Sr.from("2500000000"), n = e.baseFeePerGas.mul(2).add(i)), {
                maxFeePerGas: n,
                maxPriorityFeePerGas: i,
                gasPrice: r
            }
        })
    }
    addListener(e, r) {
        return this.on(e, r)
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
    static isProvider(e) {
        return !!(e && e._isProvider)
    }
}
const SE = "abstract-signer/5.5.0";
var zn = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Kr = new W(SE),
    PE = ["accessList", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
    IE = [W.errors.INSUFFICIENT_FUNDS, W.errors.NONCE_EXPIRED, W.errors.REPLACEMENT_UNDERPRICED];
class Du {
    constructor() {
        Kr.checkAbstract(new.target, Du), pe(this, "_isSigner", !0)
    }
    getBalance(e) {
        return zn(this, void 0, void 0, function*() {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return zn(this, void 0, void 0, function*() {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return zn(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const r = yield kt(this.checkTransaction(e));
            return yield this.provider.estimateGas(r)
        })
    }
    call(e, r) {
        return zn(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const n = yield kt(this.checkTransaction(e));
            return yield this.provider.call(n, r)
        })
    }
    sendTransaction(e) {
        return zn(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const r = yield this.populateTransaction(e), n = yield this.signTransaction(r);
            return yield this.provider.sendTransaction(n)
        })
    }
    getChainId() {
        return zn(this, void 0, void 0, function*() {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return zn(this, void 0, void 0, function*() {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return zn(this, void 0, void 0, function*() {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return zn(this, void 0, void 0, function*() {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const n in e) PE.indexOf(n) === -1 && Kr.throwArgumentError("invalid transaction key: " + n, "transaction", e);
        const r = Yt(e);
        return r.from == null ? r.from = this.getAddress() : r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(n => (n[0].toLowerCase() !== n[1].toLowerCase() && Kr.throwArgumentError("from address mismatch", "transaction", e), n[0])), r
    }
    populateTransaction(e) {
        return zn(this, void 0, void 0, function*() {
            const r = yield kt(this.checkTransaction(e));
            r.to != null && (r.to = Promise.resolve(r.to).then(i => zn(this, void 0, void 0, function*() {
                if (i == null) return null;
                const s = yield this.resolveName(i);
                return s == null && Kr.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
            })), r.to.catch(i => {}));
            const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
            if (r.gasPrice != null && (r.type === 2 || n) ? Kr.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (r.type === 0 || r.type === 1) && n && Kr.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
            else if (r.type === 0 || r.type === 1) r.gasPrice == null && (r.gasPrice = this.getGasPrice());
            else {
                const i = yield this.getFeeData();
                if (r.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (r.type = 2, r.gasPrice != null) {
                            const s = r.gasPrice;
                            delete r.gasPrice, r.maxFeePerGas = s, r.maxPriorityFeePerGas = s
                        } else r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
                else i.gasPrice != null ? (n && Kr.throwError("network does not support EIP-1559", W.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : Kr.throwError("failed to get consistent fee data", W.errors.UNSUPPORTED_OPERATION, {
                    operation: "signer.getFeeData"
                });
                else r.type === 2 && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return r.nonce == null && (r.nonce = this.getTransactionCount("pending")), r.gasLimit == null && (r.gasLimit = this.estimateGas(r).catch(i => {
                if (IE.indexOf(i.code) >= 0) throw i;
                return Kr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", W.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: i,
                    tx: r
                })
            })), r.chainId == null ? r.chainId = this.getChainId() : r.chainId = Promise.all([Promise.resolve(r.chainId), this.getChainId()]).then(i => (i[1] !== 0 && i[0] !== i[1] && Kr.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield kt(r)
        })
    }
    _checkProvider(e) {
        this.provider || Kr.throwError("missing provider", W.errors.UNSUPPORTED_OPERATION, {
            operation: e || "_checkProvider"
        })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}
class Uu extends Du {
    constructor(e, r) {
        Kr.checkNew(new.target, Uu);
        super();
        pe(this, "address", e), pe(this, "provider", r || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(e, r) {
        return Promise.resolve().then(() => {
            Kr.throwError(e, W.errors.UNSUPPORTED_OPERATION, {
                operation: r
            })
        })
    }
    signMessage(e) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(e) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(e, r, n) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(e) {
        return new Uu(this.address, e)
    }
}
const RE = "bytes/5.5.0",
    Gt = new W(RE);

function vg(t) {
    return !!t.toHexString
}

function Ka(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Ka(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function kE(t) {
    return Hn(t) && !(t.length % 2) || Lu(t)
}

function wg(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function Lu(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !wg(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!wg(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Js(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Gt.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Ka(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), vg(t) && (t = t.toHexString()), Hn(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Gt.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Ka(new Uint8Array(n))
    }
    return Lu(t) ? Ka(new Uint8Array(t)) : Gt.throwArgumentError("invalid arrayify value", "value", t)
}

function Xa(t) {
    let e = Js(t);
    if (e.length === 0) return e;
    let r = 0;
    for (; r < e.length && e[r] === 0;) r++;
    return r && (e = e.slice(r)), e
}

function OE(t, e) {
    t = Js(t), t.length > e && Gt.throwArgumentError("value out of range", "value", arguments[0]);
    const r = new Uint8Array(e);
    return r.set(t, e - t.length), Ka(r)
}

function Hn(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const Kc = "0123456789abcdef";

function Er(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Gt.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = Kc[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), vg(t)) return t.toHexString();
    if (Hn(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Gt.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (Lu(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += Kc[(i & 240) >> 4] + Kc[i & 15]
        }
        return r
    }
    return Gt.throwArgumentError("invalid hexlify value", "value", t)
}

function CE(t) {
    if (typeof t != "string") t = Er(t);
    else if (!Hn(t) || t.length % 2) return null;
    return (t.length - 2) / 2
}

function Eg(t, e, r) {
    return typeof t != "string" ? t = Er(t) : (!Hn(t) || t.length % 2) && Gt.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
}

function Ag(t) {
    let e = "0x";
    return t.forEach(r => {
        e += Er(r).substring(2)
    }), e
}

function Zs(t, e) {
    for (typeof t != "string" ? t = Er(t) : Hn(t) || Gt.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && Gt.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;) t = "0x0" + t.substring(2);
    return t
}

function _g(t) {
    const e = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0
    };
    if (kE(t)) {
        const r = Js(t);
        r.length !== 65 && Gt.throwArgumentError("invalid signature string; must be 65 bytes", "signature", t), e.r = Er(r.slice(0, 32)), e.s = Er(r.slice(32, 64)), e.v = r[64], e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : Gt.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Er(r.slice(32, 64))
    } else {
        if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
            const i = OE(Js(e._vs), 32);
            e._vs = Er(i);
            const s = i[0] >= 128 ? 1 : 0;
            e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && Gt.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
            const o = Er(i);
            e.s == null ? e.s = o : e.s !== o && Gt.throwArgumentError("signature v mismatch _vs", "signature", t)
        }
        if (e.recoveryParam == null) e.v == null ? Gt.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
        else if (e.v == null) e.v = 27 + e.recoveryParam;
        else {
            const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
            e.recoveryParam !== i && Gt.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
        }
        e.r == null || !Hn(e.r) ? Gt.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = Zs(e.r, 32), e.s == null || !Hn(e.s) ? Gt.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = Zs(e.s, 32);
        const r = Js(e.s);
        r[0] >= 128 && Gt.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
        const n = Er(r);
        e._vs && (Hn(e._vs) || Gt.throwArgumentError("signature invalid _vs", "signature", t), e._vs = Zs(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && Gt.throwArgumentError("signature _vs mismatch v and s", "signature", t)
    }
    return e
}
const FE = "bignumber/5.5.0";
var Xc = He.BN;
const vi = new W(FE),
    Jc = {},
    Tg = 9007199254740991;
let Mg = !1;
class zt {
    constructor(e, r) {
        vi.checkNew(new.target, zt), e !== Jc && vi.throwError("cannot call constructor directly; use BigNumber.from", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Ur(ut(this).fromTwos(e))
    }
    toTwos(e) {
        return Ur(ut(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? zt.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Ur(ut(this).add(ut(e)))
    }
    sub(e) {
        return Ur(ut(this).sub(ut(e)))
    }
    div(e) {
        return zt.from(e).isZero() && un("division by zero", "div"), Ur(ut(this).div(ut(e)))
    }
    mul(e) {
        return Ur(ut(this).mul(ut(e)))
    }
    mod(e) {
        const r = ut(e);
        return r.isNeg() && un("cannot modulo negative values", "mod"), Ur(ut(this).umod(r))
    }
    pow(e) {
        const r = ut(e);
        return r.isNeg() && un("cannot raise to negative values", "pow"), Ur(ut(this).pow(r))
    }
    and(e) {
        const r = ut(e);
        return (this.isNegative() || r.isNeg()) && un("cannot 'and' negative values", "and"), Ur(ut(this).and(r))
    }
    or(e) {
        const r = ut(e);
        return (this.isNegative() || r.isNeg()) && un("cannot 'or' negative values", "or"), Ur(ut(this).or(r))
    }
    xor(e) {
        const r = ut(e);
        return (this.isNegative() || r.isNeg()) && un("cannot 'xor' negative values", "xor"), Ur(ut(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && un("cannot mask negative values", "mask"), Ur(ut(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && un("cannot shift negative values", "shl"), Ur(ut(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && un("cannot shift negative values", "shr"), Ur(ut(this).shrn(e))
    }
    eq(e) {
        return ut(this).eq(ut(e))
    }
    lt(e) {
        return ut(this).lt(ut(e))
    }
    lte(e) {
        return ut(this).lte(ut(e))
    }
    gt(e) {
        return ut(this).gt(ut(e))
    }
    gte(e) {
        return ut(this).gte(ut(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return ut(this).isZero()
    }
    toNumber() {
        try {
            return ut(this).toNumber()
        } catch {
            un("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return vi.throwError("this platform does not support BigInt", W.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? Mg || (Mg = !0, vi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? vi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", W.errors.UNEXPECTED_ARGUMENT, {}) : vi.throwError("BigNumber.toString does not accept parameters", W.errors.UNEXPECTED_ARGUMENT, {})), ut(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof zt) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new zt(Jc, Ja(e)) : e.match(/^-?[0-9]+$/) ? new zt(Jc, Ja(new Xc(e))) : vi.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && un("underflow", "BigNumber.from", e), (e >= Tg || e <= -Tg) && un("overflow", "BigNumber.from", e), zt.from(String(e));
        const r = e;
        if (typeof r == "bigint") return zt.from(r.toString());
        if (Lu(r)) return zt.from(Er(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return zt.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Hn(n) || n[0] === "-" && Hn(n.substring(1)))) return zt.from(n)
            }
        return vi.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function Ja(t) {
    if (typeof t != "string") return Ja(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && vi.throwArgumentError("invalid hex", "value", t), t = Ja(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Ur(t) {
    return zt.from(Ja(t))
}

function ut(t) {
    const e = zt.from(t).toHexString();
    return e[0] === "-" ? new Xc("-" + e.substring(3), 16) : new Xc(e.substring(2), 16)
}

function un(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), vi.throwError(t, W.errors.NUMERIC_FAULT, n)
}
var Ng = {},
    lt = {},
    Za = Sg;

function Sg(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
Sg.equal = function(e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var Zc = {
    exports: {}
};
typeof Object.create == "function" ? Zc.exports = function(e, r) {
    r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
        constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }))
} : Zc.exports = function(e, r) {
    if (r) {
        e.super_ = r;
        var n = function() {};
        n.prototype = r.prototype, e.prototype = new n, e.prototype.constructor = e
    }
};
var DE = Za,
    UE = Zc.exports;
lt.inherits = UE;

function LE(t, e) {
    return (t.charCodeAt(e) & 64512) != 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) == 56320
}

function BE(t, e) {
    if (Array.isArray(t)) return t.slice();
    if (!t) return [];
    var r = [];
    if (typeof t == "string")
        if (e) {
            if (e === "hex")
                for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 != 0 && (t = "0" + t), i = 0; i < t.length; i += 2) r.push(parseInt(t[i] + t[i + 1], 16))
        } else
            for (var n = 0, i = 0; i < t.length; i++) {
                var s = t.charCodeAt(i);
                s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : LE(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128)
            } else
                for (i = 0; i < t.length; i++) r[i] = t[i] | 0;
    return r
}
lt.toArray = BE;

function $E(t) {
    for (var e = "", r = 0; r < t.length; r++) e += Ig(t[r].toString(16));
    return e
}
lt.toHex = $E;

function Pg(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0
}
lt.htonl = Pg;

function GE(t, e) {
    for (var r = "", n = 0; n < t.length; n++) {
        var i = t[n];
        e === "little" && (i = Pg(i)), r += Rg(i.toString(16))
    }
    return r
}
lt.toHex32 = GE;

function Ig(t) {
    return t.length === 1 ? "0" + t : t
}
lt.zero2 = Ig;

function Rg(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t
}
lt.zero8 = Rg;

function zE(t, e, r, n) {
    var i = r - e;
    DE(i % 4 == 0);
    for (var s = new Array(i / 4), o = 0, f = e; o < s.length; o++, f += 4) {
        var l;
        n === "big" ? l = t[f] << 24 | t[f + 1] << 16 | t[f + 2] << 8 | t[f + 3] : l = t[f + 3] << 24 | t[f + 2] << 16 | t[f + 1] << 8 | t[f], s[o] = l >>> 0
    }
    return s
}
lt.join32 = zE;

function HE(t, e) {
    for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
        var s = t[n];
        e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255)
    }
    return r
}
lt.split32 = HE;

function qE(t, e) {
    return t >>> e | t << 32 - e
}
lt.rotr32 = qE;

function jE(t, e) {
    return t << e | t >>> 32 - e
}
lt.rotl32 = jE;

function WE(t, e) {
    return t + e >>> 0
}
lt.sum32 = WE;

function VE(t, e, r) {
    return t + e + r >>> 0
}
lt.sum32_3 = VE;

function KE(t, e, r, n) {
    return t + e + r + n >>> 0
}
lt.sum32_4 = KE;

function XE(t, e, r, n, i) {
    return t + e + r + n + i >>> 0
}
lt.sum32_5 = XE;

function JE(t, e, r, n) {
    var i = t[e],
        s = t[e + 1],
        o = n + s >>> 0,
        f = (o < n ? 1 : 0) + r + i;
    t[e] = f >>> 0, t[e + 1] = o
}
lt.sum64 = JE;

function ZE(t, e, r, n) {
    var i = e + n >>> 0,
        s = (i < e ? 1 : 0) + t + r;
    return s >>> 0
}
lt.sum64_hi = ZE;

function YE(t, e, r, n) {
    var i = e + n;
    return i >>> 0
}
lt.sum64_lo = YE;

function QE(t, e, r, n, i, s, o, f) {
    var l = 0,
        d = e;
    d = d + n >>> 0, l += d < e ? 1 : 0, d = d + s >>> 0, l += d < s ? 1 : 0, d = d + f >>> 0, l += d < f ? 1 : 0;
    var p = t + r + i + o + l;
    return p >>> 0
}
lt.sum64_4_hi = QE;

function eA(t, e, r, n, i, s, o, f) {
    var l = e + n + s + f;
    return l >>> 0
}
lt.sum64_4_lo = eA;

function tA(t, e, r, n, i, s, o, f, l, d) {
    var p = 0,
        A = e;
    A = A + n >>> 0, p += A < e ? 1 : 0, A = A + s >>> 0, p += A < s ? 1 : 0, A = A + f >>> 0, p += A < f ? 1 : 0, A = A + d >>> 0, p += A < d ? 1 : 0;
    var T = t + r + i + o + l + p;
    return T >>> 0
}
lt.sum64_5_hi = tA;

function rA(t, e, r, n, i, s, o, f, l, d) {
    var p = e + n + s + f + d;
    return p >>> 0
}
lt.sum64_5_lo = rA;

function nA(t, e, r) {
    var n = e << 32 - r | t >>> r;
    return n >>> 0
}
lt.rotr64_hi = nA;

function iA(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}
lt.rotr64_lo = iA;

function sA(t, e, r) {
    return t >>> r
}
lt.shr64_hi = sA;

function oA(t, e, r) {
    var n = t << 32 - r | e >>> r;
    return n >>> 0
}
lt.shr64_lo = oA;
var Ho = {},
    kg = lt,
    aA = Za;

function Bu() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
}
Ho.BlockHash = Bu;
Bu.prototype.update = function(e, r) {
    if (e = kg.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var n = e.length % this._delta8;
        this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = kg.join32(e, 0, e.length - n, this.endian);
        for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
    }
    return this
};
Bu.prototype.digest = function(e) {
    return this.update(this._pad()), aA(this.pending === null), this._digest(e)
};
Bu.prototype._pad = function() {
    var e = this.pendingTotal,
        r = this._delta8,
        n = r - (e + this.padLength) % r,
        i = new Array(n + this.padLength);
    i[0] = 128;
    for (var s = 1; s < n; s++) i[s] = 0;
    if (e <<= 3, this.endian === "big") {
        for (var o = 8; o < this.padLength; o++) i[s++] = 0;
        i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255
    } else
        for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++) i[s++] = 0;
    return i
};
var qo = {},
    wi = {},
    fA = lt,
    Ei = fA.rotr32;

function uA(t, e, r, n) {
    if (t === 0) return Og(e, r, n);
    if (t === 1 || t === 3) return Fg(e, r, n);
    if (t === 2) return Cg(e, r, n)
}
wi.ft_1 = uA;

function Og(t, e, r) {
    return t & e ^ ~t & r
}
wi.ch32 = Og;

function Cg(t, e, r) {
    return t & e ^ t & r ^ e & r
}
wi.maj32 = Cg;

function Fg(t, e, r) {
    return t ^ e ^ r
}
wi.p32 = Fg;

function lA(t) {
    return Ei(t, 2) ^ Ei(t, 13) ^ Ei(t, 22)
}
wi.s0_256 = lA;

function cA(t) {
    return Ei(t, 6) ^ Ei(t, 11) ^ Ei(t, 25)
}
wi.s1_256 = cA;

function hA(t) {
    return Ei(t, 7) ^ Ei(t, 18) ^ t >>> 3
}
wi.g0_256 = hA;

function dA(t) {
    return Ei(t, 17) ^ Ei(t, 19) ^ t >>> 10
}
wi.g1_256 = dA;
var jo = lt,
    pA = Ho,
    mA = wi,
    Yc = jo.rotl32,
    Ya = jo.sum32,
    yA = jo.sum32_5,
    gA = mA.ft_1,
    Dg = pA.BlockHash,
    xA = [1518500249, 1859775393, 2400959708, 3395469782];

function Ai() {
    if (!(this instanceof Ai)) return new Ai;
    Dg.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
}
jo.inherits(Ai, Dg);
var bA = Ai;
Ai.blockSize = 512;
Ai.outSize = 160;
Ai.hmacStrength = 80;
Ai.padLength = 64;
Ai.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = Yc(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
    var s = this.h[0],
        o = this.h[1],
        f = this.h[2],
        l = this.h[3],
        d = this.h[4];
    for (i = 0; i < n.length; i++) {
        var p = ~~(i / 20),
            A = yA(Yc(s, 5), gA(p, o, f, l), d, n[i], xA[p]);
        d = l, l = f, f = Yc(o, 30), o = s, s = A
    }
    this.h[0] = Ya(this.h[0], s), this.h[1] = Ya(this.h[1], o), this.h[2] = Ya(this.h[2], f), this.h[3] = Ya(this.h[3], l), this.h[4] = Ya(this.h[4], d)
};
Ai.prototype._digest = function(e) {
    return e === "hex" ? jo.toHex32(this.h, "big") : jo.split32(this.h, "big")
};
var Wo = lt,
    vA = Ho,
    Vo = wi,
    wA = Za,
    qn = Wo.sum32,
    EA = Wo.sum32_4,
    AA = Wo.sum32_5,
    _A = Vo.ch32,
    TA = Vo.maj32,
    MA = Vo.s0_256,
    NA = Vo.s1_256,
    SA = Vo.g0_256,
    PA = Vo.g1_256,
    Ug = vA.BlockHash,
    IA = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

function _i() {
    if (!(this instanceof _i)) return new _i;
    Ug.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = IA, this.W = new Array(64)
}
Wo.inherits(_i, Ug);
var Lg = _i;
_i.blockSize = 512;
_i.outSize = 256;
_i.hmacStrength = 192;
_i.padLength = 64;
_i.prototype._update = function(e, r) {
    for (var n = this.W, i = 0; i < 16; i++) n[i] = e[r + i];
    for (; i < n.length; i++) n[i] = EA(PA(n[i - 2]), n[i - 7], SA(n[i - 15]), n[i - 16]);
    var s = this.h[0],
        o = this.h[1],
        f = this.h[2],
        l = this.h[3],
        d = this.h[4],
        p = this.h[5],
        A = this.h[6],
        T = this.h[7];
    for (wA(this.k.length === n.length), i = 0; i < n.length; i++) {
        var N = AA(T, NA(d), _A(d, p, A), this.k[i], n[i]),
            P = qn(MA(s), TA(s, o, f));
        T = A, A = p, p = d, d = qn(l, N), l = f, f = o, o = s, s = qn(N, P)
    }
    this.h[0] = qn(this.h[0], s), this.h[1] = qn(this.h[1], o), this.h[2] = qn(this.h[2], f), this.h[3] = qn(this.h[3], l), this.h[4] = qn(this.h[4], d), this.h[5] = qn(this.h[5], p), this.h[6] = qn(this.h[6], A), this.h[7] = qn(this.h[7], T)
};
_i.prototype._digest = function(e) {
    return e === "hex" ? Wo.toHex32(this.h, "big") : Wo.split32(this.h, "big")
};
var Qc = lt,
    Bg = Lg;

function Ji() {
    if (!(this instanceof Ji)) return new Ji;
    Bg.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
}
Qc.inherits(Ji, Bg);
var RA = Ji;
Ji.blockSize = 512;
Ji.outSize = 224;
Ji.hmacStrength = 192;
Ji.padLength = 64;
Ji.prototype._digest = function(e) {
    return e === "hex" ? Qc.toHex32(this.h.slice(0, 7), "big") : Qc.split32(this.h.slice(0, 7), "big")
};
var Lr = lt,
    kA = Ho,
    OA = Za,
    Ti = Lr.rotr64_hi,
    Mi = Lr.rotr64_lo,
    $g = Lr.shr64_hi,
    Gg = Lr.shr64_lo,
    bs = Lr.sum64,
    eh = Lr.sum64_hi,
    th = Lr.sum64_lo,
    CA = Lr.sum64_4_hi,
    FA = Lr.sum64_4_lo,
    DA = Lr.sum64_5_hi,
    UA = Lr.sum64_5_lo,
    zg = kA.BlockHash,
    LA = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

function jn() {
    if (!(this instanceof jn)) return new jn;
    zg.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = LA, this.W = new Array(160)
}
Lr.inherits(jn, zg);
var Hg = jn;
jn.blockSize = 1024;
jn.outSize = 512;
jn.hmacStrength = 192;
jn.padLength = 128;
jn.prototype._prepareBlock = function(e, r) {
    for (var n = this.W, i = 0; i < 32; i++) n[i] = e[r + i];
    for (; i < n.length; i += 2) {
        var s = XA(n[i - 4], n[i - 3]),
            o = JA(n[i - 4], n[i - 3]),
            f = n[i - 14],
            l = n[i - 13],
            d = VA(n[i - 30], n[i - 29]),
            p = KA(n[i - 30], n[i - 29]),
            A = n[i - 32],
            T = n[i - 31];
        n[i] = CA(s, o, f, l, d, p, A, T), n[i + 1] = FA(s, o, f, l, d, p, A, T)
    }
};
jn.prototype._update = function(e, r) {
    this._prepareBlock(e, r);
    var n = this.W,
        i = this.h[0],
        s = this.h[1],
        o = this.h[2],
        f = this.h[3],
        l = this.h[4],
        d = this.h[5],
        p = this.h[6],
        A = this.h[7],
        T = this.h[8],
        N = this.h[9],
        P = this.h[10],
        C = this.h[11],
        S = this.h[12],
        k = this.h[13],
        I = this.h[14],
        U = this.h[15];
    OA(this.k.length === n.length);
    for (var M = 0; M < n.length; M += 2) {
        var F = I,
            D = U,
            q = jA(T, N),
            V = WA(T, N),
            Q = BA(T, N, P, C, S),
            ce = $A(T, N, P, C, S, k),
            O = this.k[M],
            w = this.k[M + 1],
            m = n[M],
            a = n[M + 1],
            c = DA(F, D, q, V, Q, ce, O, w, m, a),
            g = UA(F, D, q, V, Q, ce, O, w, m, a);
        F = HA(i, s), D = qA(i, s), q = GA(i, s, o, f, l), V = zA(i, s, o, f, l, d);
        var v = eh(F, D, q, V),
            x = th(F, D, q, V);
        I = S, U = k, S = P, k = C, P = T, C = N, T = eh(p, A, c, g), N = th(A, A, c, g), p = l, A = d, l = o, d = f, o = i, f = s, i = eh(c, g, v, x), s = th(c, g, v, x)
    }
    bs(this.h, 0, i, s), bs(this.h, 2, o, f), bs(this.h, 4, l, d), bs(this.h, 6, p, A), bs(this.h, 8, T, N), bs(this.h, 10, P, C), bs(this.h, 12, S, k), bs(this.h, 14, I, U)
};
jn.prototype._digest = function(e) {
    return e === "hex" ? Lr.toHex32(this.h, "big") : Lr.split32(this.h, "big")
};

function BA(t, e, r, n, i) {
    var s = t & r ^ ~t & i;
    return s < 0 && (s += 4294967296), s
}

function $A(t, e, r, n, i, s) {
    var o = e & n ^ ~e & s;
    return o < 0 && (o += 4294967296), o
}

function GA(t, e, r, n, i) {
    var s = t & r ^ t & i ^ r & i;
    return s < 0 && (s += 4294967296), s
}

function zA(t, e, r, n, i, s) {
    var o = e & n ^ e & s ^ n & s;
    return o < 0 && (o += 4294967296), o
}

function HA(t, e) {
    var r = Ti(t, e, 28),
        n = Ti(e, t, 2),
        i = Ti(e, t, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function qA(t, e) {
    var r = Mi(t, e, 28),
        n = Mi(e, t, 2),
        i = Mi(e, t, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function jA(t, e) {
    var r = Ti(t, e, 14),
        n = Ti(t, e, 18),
        i = Ti(e, t, 9),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function WA(t, e) {
    var r = Mi(t, e, 14),
        n = Mi(t, e, 18),
        i = Mi(e, t, 9),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function VA(t, e) {
    var r = Ti(t, e, 1),
        n = Ti(t, e, 8),
        i = $g(t, e, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function KA(t, e) {
    var r = Mi(t, e, 1),
        n = Mi(t, e, 8),
        i = Gg(t, e, 7),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function XA(t, e) {
    var r = Ti(t, e, 19),
        n = Ti(e, t, 29),
        i = $g(t, e, 6),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}

function JA(t, e) {
    var r = Mi(t, e, 19),
        n = Mi(e, t, 29),
        i = Gg(t, e, 6),
        s = r ^ n ^ i;
    return s < 0 && (s += 4294967296), s
}
var rh = lt,
    qg = Hg;

function Zi() {
    if (!(this instanceof Zi)) return new Zi;
    qg.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
}
rh.inherits(Zi, qg);
var ZA = Zi;
Zi.blockSize = 1024;
Zi.outSize = 384;
Zi.hmacStrength = 192;
Zi.padLength = 128;
Zi.prototype._digest = function(e) {
    return e === "hex" ? rh.toHex32(this.h.slice(0, 12), "big") : rh.split32(this.h.slice(0, 12), "big")
};
qo.sha1 = bA;
qo.sha224 = RA;
qo.sha256 = Lg;
qo.sha384 = ZA;
qo.sha512 = Hg;
var jg = {},
    Ys = lt,
    YA = Ho,
    $u = Ys.rotl32,
    Wg = Ys.sum32,
    Qa = Ys.sum32_3,
    Vg = Ys.sum32_4,
    Kg = YA.BlockHash;

function Ni() {
    if (!(this instanceof Ni)) return new Ni;
    Kg.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
}
Ys.inherits(Ni, Kg);
jg.ripemd160 = Ni;
Ni.blockSize = 512;
Ni.outSize = 160;
Ni.hmacStrength = 192;
Ni.padLength = 64;
Ni.prototype._update = function(e, r) {
    for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], f = this.h[4], l = n, d = i, p = s, A = o, T = f, N = 0; N < 80; N++) {
        var P = Wg($u(Vg(n, Xg(N, i, s, o), e[t4[N] + r], QA(N)), n4[N]), f);
        n = f, f = o, o = $u(s, 10), s = i, i = P, P = Wg($u(Vg(l, Xg(79 - N, d, p, A), e[r4[N] + r], e4(N)), i4[N]), T), l = T, T = A, A = $u(p, 10), p = d, d = P
    }
    P = Qa(this.h[1], s, A), this.h[1] = Qa(this.h[2], o, T), this.h[2] = Qa(this.h[3], f, l), this.h[3] = Qa(this.h[4], n, d), this.h[4] = Qa(this.h[0], i, p), this.h[0] = P
};
Ni.prototype._digest = function(e) {
    return e === "hex" ? Ys.toHex32(this.h, "little") : Ys.split32(this.h, "little")
};

function Xg(t, e, r, n) {
    return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n)
}

function QA(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
}

function e4(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
}
var t4 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    r4 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
    n4 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
    i4 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
    s4 = lt,
    o4 = Za;

function Ko(t, e, r) {
    if (!(this instanceof Ko)) return new Ko(t, e, r);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(s4.toArray(e, r))
}
var a4 = Ko;
Ko.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), o4(e.length <= this.blockSize);
    for (var r = e.length; r < this.blockSize; r++) e.push(0);
    for (r = 0; r < e.length; r++) e[r] ^= 54;
    for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++) e[r] ^= 106;
    this.outer = new this.Hash().update(e)
};
Ko.prototype.update = function(e, r) {
    return this.inner.update(e, r), this
};
Ko.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
};
(function(t) {
    var e = t;
    e.utils = lt, e.common = Ho, e.sha = qo, e.ripemd = jg, e.hmac = a4, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160
})(Ng);
var Qt = Ng;

function Xo(t, e, r) {
    return r = {
        path: e,
        exports: {},
        require: function(n, i) {
            return f4(n, i == null ? r.path : i)
        }
    }, t(r, r.exports), r.exports
}

function f4() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var nh = Jg;

function Jg(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
Jg.equal = function(e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var Wn = Xo(function(t, e) {
        var r = e;

        function n(o, f) {
            if (Array.isArray(o)) return o.slice();
            if (!o) return [];
            var l = [];
            if (typeof o != "string") {
                for (var d = 0; d < o.length; d++) l[d] = o[d] | 0;
                return l
            }
            if (f === "hex") {
                o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 != 0 && (o = "0" + o);
                for (var d = 0; d < o.length; d += 2) l.push(parseInt(o[d] + o[d + 1], 16))
            } else
                for (var d = 0; d < o.length; d++) {
                    var p = o.charCodeAt(d),
                        A = p >> 8,
                        T = p & 255;
                    A ? l.push(A, T) : l.push(T)
                }
            return l
        }
        r.toArray = n;

        function i(o) {
            return o.length === 1 ? "0" + o : o
        }
        r.zero2 = i;

        function s(o) {
            for (var f = "", l = 0; l < o.length; l++) f += i(o[l].toString(16));
            return f
        }
        r.toHex = s, r.encode = function(f, l) {
            return l === "hex" ? s(f) : f
        }
    }),
    Xr = Xo(function(t, e) {
        var r = e;
        r.assert = nh, r.toArray = Wn.toArray, r.zero2 = Wn.zero2, r.toHex = Wn.toHex, r.encode = Wn.encode;

        function n(l, d, p) {
            var A = new Array(Math.max(l.bitLength(), p) + 1);
            A.fill(0);
            for (var T = 1 << d + 1, N = l.clone(), P = 0; P < A.length; P++) {
                var C, S = N.andln(T - 1);
                N.isOdd() ? (S > (T >> 1) - 1 ? C = (T >> 1) - S : C = S, N.isubn(C)) : C = 0, A[P] = C, N.iushrn(1)
            }
            return A
        }
        r.getNAF = n;

        function i(l, d) {
            var p = [
                [],
                []
            ];
            l = l.clone(), d = d.clone();
            for (var A = 0, T = 0, N; l.cmpn(-A) > 0 || d.cmpn(-T) > 0;) {
                var P = l.andln(3) + A & 3,
                    C = d.andln(3) + T & 3;
                P === 3 && (P = -1), C === 3 && (C = -1);
                var S;
                (P & 1) == 0 ? S = 0 : (N = l.andln(7) + A & 7, (N === 3 || N === 5) && C === 2 ? S = -P : S = P), p[0].push(S);
                var k;
                (C & 1) == 0 ? k = 0 : (N = d.andln(7) + T & 7, (N === 3 || N === 5) && P === 2 ? k = -C : k = C), p[1].push(k), 2 * A === S + 1 && (A = 1 - A), 2 * T === k + 1 && (T = 1 - T), l.iushrn(1), d.iushrn(1)
            }
            return p
        }
        r.getJSF = i;

        function s(l, d, p) {
            var A = "_" + d;
            l.prototype[d] = function() {
                return this[A] !== void 0 ? this[A] : this[A] = p.call(this)
            }
        }
        r.cachedProperty = s;

        function o(l) {
            return typeof l == "string" ? r.toArray(l, "hex") : l
        }
        r.parseBytes = o;

        function f(l) {
            return new He(l, "hex", "le")
        }
        r.intFromLE = f
    }),
    Gu = Xr.getNAF,
    u4 = Xr.getJSF,
    zu = Xr.assert;

function vs(t, e) {
    this.type = t, this.p = new He(e.p, 16), this.red = e.prime ? He.red(e.prime) : He.mont(this.p), this.zero = new He(0).toRed(this.red), this.one = new He(1).toRed(this.red), this.two = new He(2).toRed(this.red), this.n = e.n && new He(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
}
var Qs = vs;
vs.prototype.point = function() {
    throw new Error("Not implemented")
};
vs.prototype.validate = function() {
    throw new Error("Not implemented")
};
vs.prototype._fixedNafMul = function(e, r) {
    zu(e.precomputed);
    var n = e._getDoubles(),
        i = Gu(r, 1, this._bitLength),
        s = (1 << n.step + 1) - (n.step % 2 == 0 ? 2 : 1);
    s /= 3;
    var o = [],
        f, l;
    for (f = 0; f < i.length; f += n.step) {
        l = 0;
        for (var d = f + n.step - 1; d >= f; d--) l = (l << 1) + i[d];
        o.push(l)
    }
    for (var p = this.jpoint(null, null, null), A = this.jpoint(null, null, null), T = s; T > 0; T--) {
        for (f = 0; f < o.length; f++) l = o[f], l === T ? A = A.mixedAdd(n.points[f]) : l === -T && (A = A.mixedAdd(n.points[f].neg()));
        p = p.add(A)
    }
    return p.toP()
};
vs.prototype._wnafMul = function(e, r) {
    var n = 4,
        i = e._getNAFPoints(n);
    n = i.wnd;
    for (var s = i.points, o = Gu(r, n, this._bitLength), f = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
        for (var d = 0; l >= 0 && o[l] === 0; l--) d++;
        if (l >= 0 && d++, f = f.dblp(d), l < 0) break;
        var p = o[l];
        zu(p !== 0), e.type === "affine" ? p > 0 ? f = f.mixedAdd(s[p - 1 >> 1]) : f = f.mixedAdd(s[-p - 1 >> 1].neg()) : p > 0 ? f = f.add(s[p - 1 >> 1]) : f = f.add(s[-p - 1 >> 1].neg())
    }
    return e.type === "affine" ? f.toP() : f
};
vs.prototype._wnafMulAdd = function(e, r, n, i, s) {
    var o = this._wnafT1,
        f = this._wnafT2,
        l = this._wnafT3,
        d = 0,
        p, A, T;
    for (p = 0; p < i; p++) {
        T = r[p];
        var N = T._getNAFPoints(e);
        o[p] = N.wnd, f[p] = N.points
    }
    for (p = i - 1; p >= 1; p -= 2) {
        var P = p - 1,
            C = p;
        if (o[P] !== 1 || o[C] !== 1) {
            l[P] = Gu(n[P], o[P], this._bitLength), l[C] = Gu(n[C], o[C], this._bitLength), d = Math.max(l[P].length, d), d = Math.max(l[C].length, d);
            continue
        }
        var S = [r[P], null, null, r[C]];
        r[P].y.cmp(r[C].y) === 0 ? (S[1] = r[P].add(r[C]), S[2] = r[P].toJ().mixedAdd(r[C].neg())) : r[P].y.cmp(r[C].y.redNeg()) === 0 ? (S[1] = r[P].toJ().mixedAdd(r[C]), S[2] = r[P].add(r[C].neg())) : (S[1] = r[P].toJ().mixedAdd(r[C]), S[2] = r[P].toJ().mixedAdd(r[C].neg()));
        var k = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            I = u4(n[P], n[C]);
        for (d = Math.max(I[0].length, d), l[P] = new Array(d), l[C] = new Array(d), A = 0; A < d; A++) {
            var U = I[0][A] | 0,
                M = I[1][A] | 0;
            l[P][A] = k[(U + 1) * 3 + (M + 1)], l[C][A] = 0, f[P] = S
        }
    }
    var F = this.jpoint(null, null, null),
        D = this._wnafT4;
    for (p = d; p >= 0; p--) {
        for (var q = 0; p >= 0;) {
            var V = !0;
            for (A = 0; A < i; A++) D[A] = l[A][p] | 0, D[A] !== 0 && (V = !1);
            if (!V) break;
            q++, p--
        }
        if (p >= 0 && q++, F = F.dblp(q), p < 0) break;
        for (A = 0; A < i; A++) {
            var Q = D[A];
            Q !== 0 && (Q > 0 ? T = f[A][Q - 1 >> 1] : Q < 0 && (T = f[A][-Q - 1 >> 1].neg()), T.type === "affine" ? F = F.mixedAdd(T) : F = F.add(T))
        }
    }
    for (p = 0; p < i; p++) f[p] = null;
    return s ? F : F.toP()
};

function ln(t, e) {
    this.curve = t, this.type = e, this.precomputed = null
}
vs.BasePoint = ln;
ln.prototype.eq = function() {
    throw new Error("Not implemented")
};
ln.prototype.validate = function() {
    return this.curve.validate(this)
};
vs.prototype.decodePoint = function(e, r) {
    e = Xr.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 == 2 * n) {
        e[0] === 6 ? zu(e[e.length - 1] % 2 == 0) : e[0] === 7 && zu(e[e.length - 1] % 2 == 1);
        var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format")
};
ln.prototype.encodeCompressed = function(e) {
    return this.encode(e, !0)
};
ln.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(),
        n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
};
ln.prototype.encode = function(e, r) {
    return Xr.encode(this._encode(r), e)
};
ln.prototype.precompute = function(e) {
    if (this.precomputed) return this;
    var r = {
        doubles: null,
        naf: null,
        beta: null
    };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this
};
ln.prototype._hasDoubles = function(e) {
    if (!this.precomputed) return !1;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1
};
ln.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var n = [this], i = this, s = 0; s < r; s += e) {
        for (var o = 0; o < e; o++) i = i.dbl();
        n.push(i)
    }
    return {
        step: e,
        points: n
    }
};
ln.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++) r[s] = r[s - 1].add(i);
    return {
        wnd: e,
        points: r
    }
};
ln.prototype._getBeta = function() {
    return null
};
ln.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++) r = r.dbl();
    return r
};
var ih = Xo(function(t) {
        typeof Object.create == "function" ? t.exports = function(r, n) {
            n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }))
        } : t.exports = function(r, n) {
            if (n) {
                r.super_ = n;
                var i = function() {};
                i.prototype = n.prototype, r.prototype = new i, r.prototype.constructor = r
            }
        }
    }),
    l4 = Xr.assert;

function cn(t) {
    Qs.call(this, "short", t), this.a = new He(t.a, 16).toRed(this.red), this.b = new He(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
}
ih(cn, Qs);
var c4 = cn;
cn.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n;
        if (e.beta) r = new He(e.beta, 16).toRed(this.red);
        else {
            var i = this._getEndoRoots(this.p);
            r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red)
        }
        if (e.lambda) n = new He(e.lambda, 16);
        else {
            var s = this._getEndoRoots(this.n);
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], l4(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var o;
        return e.basis ? o = e.basis.map(function(f) {
            return {
                a: new He(f.a, 16),
                b: new He(f.b, 16)
            }
        }) : o = this._getEndoBasis(n), {
            beta: r,
            lambda: n,
            basis: o
        }
    }
};
cn.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : He.mont(e),
        n = new He(2).toRed(r).redInvm(),
        i = n.redNeg(),
        s = new He(3).toRed(r).redNeg().redSqrt().redMul(n),
        o = i.redAdd(s).fromRed(),
        f = i.redSub(s).fromRed();
    return [o, f]
};
cn.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new He(1), o = new He(0), f = new He(0), l = new He(1), d, p, A, T, N, P, C, S = 0, k, I; n.cmpn(0) !== 0;) {
        var U = i.div(n);
        k = i.sub(U.mul(n)), I = f.sub(U.mul(s));
        var M = l.sub(U.mul(o));
        if (!A && k.cmp(r) < 0) d = C.neg(), p = s, A = k.neg(), T = I;
        else if (A && ++S == 2) break;
        C = k, i = n, n = k, f = s, s = I, l = o, o = M
    }
    N = k.neg(), P = I;
    var F = A.sqr().add(T.sqr()),
        D = N.sqr().add(P.sqr());
    return D.cmp(F) >= 0 && (N = d, P = p), A.negative && (A = A.neg(), T = T.neg()), N.negative && (N = N.neg(), P = P.neg()), [{
        a: A,
        b: T
    }, {
        a: N,
        b: P
    }]
};
cn.prototype._endoSplit = function(e) {
    var r = this.endo.basis,
        n = r[0],
        i = r[1],
        s = i.b.mul(e).divRound(this.n),
        o = n.b.neg().mul(e).divRound(this.n),
        f = s.mul(n.a),
        l = o.mul(i.a),
        d = s.mul(n.b),
        p = o.mul(i.b),
        A = e.sub(f).sub(l),
        T = d.add(p).neg();
    return {
        k1: A,
        k2: T
    }
};
cn.prototype.pointFromX = function(e, r) {
    e = new He(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point");
    var s = i.fromRed().isOdd();
    return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i)
};
cn.prototype.validate = function(e) {
    if (e.inf) return !0;
    var r = e.x,
        n = e.y,
        i = this.a.redMul(r),
        s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(s).cmpn(0) === 0
};
cn.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
        var f = this._endoSplit(r[o]),
            l = e[o],
            d = l._getBeta();
        f.k1.negative && (f.k1.ineg(), l = l.neg(!0)), f.k2.negative && (f.k2.ineg(), d = d.neg(!0)), i[o * 2] = l, i[o * 2 + 1] = d, s[o * 2] = f.k1, s[o * 2 + 1] = f.k2
    }
    for (var p = this._wnafMulAdd(1, i, s, o * 2, n), A = 0; A < o * 2; A++) i[A] = null, s[A] = null;
    return p
};

function sr(t, e, r, n) {
    Qs.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new He(e, 16), this.y = new He(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
}
ih(sr, Qs.BasePoint);
cn.prototype.point = function(e, r, n) {
    return new sr(this, e, r, n)
};
cn.prototype.pointFromJSON = function(e, r) {
    return sr.fromJSON(this, e, r)
};
sr.prototype._getBeta = function() {
    if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta) return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
            var n = this.curve,
                i = function(s) {
                    return n.point(s.x.redMul(n.endo.beta), s.y)
                };
            e.beta = r, r.precomputed = {
                beta: null,
                naf: e.naf && {
                    wnd: e.naf.wnd,
                    points: e.naf.points.map(i)
                },
                doubles: e.doubles && {
                    step: e.doubles.step,
                    points: e.doubles.points.map(i)
                }
            }
        }
        return r
    }
};
sr.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
        }
    }] : [this.x, this.y]
};
sr.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2]) return i;

    function s(f) {
        return e.point(f[0], f[1], n)
    }
    var o = r[2];
    return i.precomputed = {
        beta: null,
        doubles: o.doubles && {
            step: o.doubles.step,
            points: [i].concat(o.doubles.points.map(s))
        },
        naf: o.naf && {
            wnd: o.naf.wnd,
            points: [i].concat(o.naf.points.map(s))
        }
    }, i
};
sr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
};
sr.prototype.isInfinity = function() {
    return this.inf
};
sr.prototype.add = function(e) {
    if (this.inf) return e;
    if (e.inf) return this;
    if (this.eq(e)) return this.dbl();
    if (this.neg().eq(e)) return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x),
        i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i)
};
sr.prototype.dbl = function() {
    if (this.inf) return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0) return this.curve.point(null, null);
    var r = this.curve.a,
        n = this.x.redSqr(),
        i = e.redInvm(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        o = s.redSqr().redISub(this.x.redAdd(this.x)),
        f = s.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, f)
};
sr.prototype.getX = function() {
    return this.x.fromRed()
};
sr.prototype.getY = function() {
    return this.y.fromRed()
};
sr.prototype.mul = function(e) {
    return e = new He(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
};
sr.prototype.mulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
};
sr.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
};
sr.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
};
sr.prototype.neg = function(e) {
    if (this.inf) return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
        var n = this.precomputed,
            i = function(s) {
                return s.neg()
            };
        r.precomputed = {
            naf: n.naf && {
                wnd: n.naf.wnd,
                points: n.naf.points.map(i)
            },
            doubles: n.doubles && {
                step: n.doubles.step,
                points: n.doubles.points.map(i)
            }
        }
    }
    return r
};
sr.prototype.toJ = function() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e
};

function lr(t, e, r, n) {
    Qs.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new He(0)) : (this.x = new He(e, 16), this.y = new He(r, 16), this.z = new He(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
}
ih(lr, Qs.BasePoint);
cn.prototype.jpoint = function(e, r, n) {
    return new lr(this, e, r, n)
};
lr.prototype.toP = function() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var e = this.z.redInvm(),
        r = e.redSqr(),
        n = this.x.redMul(r),
        i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i)
};
lr.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
};
lr.prototype.add = function(e) {
    if (this.isInfinity()) return e;
    if (e.isInfinity()) return this;
    var r = e.z.redSqr(),
        n = this.z.redSqr(),
        i = this.x.redMul(r),
        s = e.x.redMul(n),
        o = this.y.redMul(r.redMul(e.z)),
        f = e.y.redMul(n.redMul(this.z)),
        l = i.redSub(s),
        d = o.redSub(f);
    if (l.cmpn(0) === 0) return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var p = l.redSqr(),
        A = p.redMul(l),
        T = i.redMul(p),
        N = d.redSqr().redIAdd(A).redISub(T).redISub(T),
        P = d.redMul(T.redISub(N)).redISub(o.redMul(A)),
        C = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(N, P, C)
};
lr.prototype.mixedAdd = function(e) {
    if (this.isInfinity()) return e.toJ();
    if (e.isInfinity()) return this;
    var r = this.z.redSqr(),
        n = this.x,
        i = e.x.redMul(r),
        s = this.y,
        o = e.y.redMul(r).redMul(this.z),
        f = n.redSub(i),
        l = s.redSub(o);
    if (f.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var d = f.redSqr(),
        p = d.redMul(f),
        A = n.redMul(d),
        T = l.redSqr().redIAdd(p).redISub(A).redISub(A),
        N = l.redMul(A.redISub(T)).redISub(s.redMul(p)),
        P = this.z.redMul(f);
    return this.curve.jpoint(T, N, P)
};
lr.prototype.dblp = function(e) {
    if (e === 0) return this;
    if (this.isInfinity()) return this;
    if (!e) return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this;
        for (r = 0; r < e; r++) n = n.dbl();
        return n
    }
    var i = this.curve.a,
        s = this.curve.tinv,
        o = this.x,
        f = this.y,
        l = this.z,
        d = l.redSqr().redSqr(),
        p = f.redAdd(f);
    for (r = 0; r < e; r++) {
        var A = o.redSqr(),
            T = p.redSqr(),
            N = T.redSqr(),
            P = A.redAdd(A).redIAdd(A).redIAdd(i.redMul(d)),
            C = o.redMul(T),
            S = P.redSqr().redISub(C.redAdd(C)),
            k = C.redISub(S),
            I = P.redMul(k);
        I = I.redIAdd(I).redISub(N);
        var U = p.redMul(l);
        r + 1 < e && (d = d.redMul(N)), o = S, l = U, p = I
    }
    return this.curve.jpoint(o, p.redMul(s), l)
};
lr.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
};
lr.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            f = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        f = f.redIAdd(f);
        var l = i.redAdd(i).redIAdd(i),
            d = l.redSqr().redISub(f).redISub(f),
            p = o.redIAdd(o);
        p = p.redIAdd(p), p = p.redIAdd(p), e = d, r = l.redMul(f.redISub(d)).redISub(p), n = this.y.redAdd(this.y)
    } else {
        var A = this.x.redSqr(),
            T = this.y.redSqr(),
            N = T.redSqr(),
            P = this.x.redAdd(T).redSqr().redISub(A).redISub(N);
        P = P.redIAdd(P);
        var C = A.redAdd(A).redIAdd(A),
            S = C.redSqr(),
            k = N.redIAdd(N);
        k = k.redIAdd(k), k = k.redIAdd(k), e = S.redISub(P).redISub(P), r = C.redMul(P.redISub(e)).redISub(k), n = this.y.redMul(this.z), n = n.redIAdd(n)
    }
    return this.curve.jpoint(e, r, n)
};
lr.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            f = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        f = f.redIAdd(f);
        var l = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
            d = l.redSqr().redISub(f).redISub(f);
        e = d;
        var p = o.redIAdd(o);
        p = p.redIAdd(p), p = p.redIAdd(p), r = l.redMul(f.redISub(d)).redISub(p), n = this.y.redAdd(this.y)
    } else {
        var A = this.z.redSqr(),
            T = this.y.redSqr(),
            N = this.x.redMul(T),
            P = this.x.redSub(A).redMul(this.x.redAdd(A));
        P = P.redAdd(P).redIAdd(P);
        var C = N.redIAdd(N);
        C = C.redIAdd(C);
        var S = C.redAdd(C);
        e = P.redSqr().redISub(S), n = this.y.redAdd(this.z).redSqr().redISub(T).redISub(A);
        var k = T.redSqr();
        k = k.redIAdd(k), k = k.redIAdd(k), k = k.redIAdd(k), r = P.redMul(C.redISub(e)).redISub(k)
    }
    return this.curve.jpoint(e, r, n)
};
lr.prototype._dbl = function() {
    var e = this.curve.a,
        r = this.x,
        n = this.y,
        i = this.z,
        s = i.redSqr().redSqr(),
        o = r.redSqr(),
        f = n.redSqr(),
        l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)),
        d = r.redAdd(r);
    d = d.redIAdd(d);
    var p = d.redMul(f),
        A = l.redSqr().redISub(p.redAdd(p)),
        T = p.redISub(A),
        N = f.redSqr();
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var P = l.redMul(T).redISub(N),
        C = n.redAdd(n).redMul(i);
    return this.curve.jpoint(A, P, C)
};
lr.prototype.trpl = function() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var e = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr(),
        i = r.redSqr(),
        s = e.redAdd(e).redIAdd(e),
        o = s.redSqr(),
        f = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    f = f.redIAdd(f), f = f.redAdd(f).redIAdd(f), f = f.redISub(o);
    var l = f.redSqr(),
        d = i.redIAdd(i);
    d = d.redIAdd(d), d = d.redIAdd(d), d = d.redIAdd(d);
    var p = s.redIAdd(f).redSqr().redISub(o).redISub(l).redISub(d),
        A = r.redMul(p);
    A = A.redIAdd(A), A = A.redIAdd(A);
    var T = this.x.redMul(l).redISub(A);
    T = T.redIAdd(T), T = T.redIAdd(T);
    var N = this.y.redMul(p.redMul(d.redISub(p)).redISub(f.redMul(l)));
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var P = this.z.redAdd(f).redSqr().redISub(n).redISub(l);
    return this.curve.jpoint(T, N, P)
};
lr.prototype.mul = function(e, r) {
    return e = new He(e, r), this.curve._wnafMul(this, e)
};
lr.prototype.eq = function(e) {
    if (e.type === "affine") return this.eq(e.toJ());
    if (this === e) return !0;
    var r = this.z.redSqr(),
        n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1;
    var i = r.redMul(this.z),
        s = n.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0
};
lr.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(),
        n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0) return !0;
    for (var i = e.clone(), s = this.curve.redN.redMul(r);;) {
        if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
        if (n.redIAdd(s), this.x.cmp(n) === 0) return !0
    }
};
lr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
};
lr.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0
};
var Hu = Xo(function(t, e) {
        var r = e;
        r.base = Qs, r.short = c4, r.mont = null, r.edwards = null
    }),
    qu = Xo(function(t, e) {
        var r = e,
            n = Xr.assert;

        function i(f) {
            f.type === "short" ? this.curve = new Hu.short(f) : f.type === "edwards" ? this.curve = new Hu.edwards(f) : this.curve = new Hu.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        r.PresetCurve = i;

        function s(f, l) {
            Object.defineProperty(r, f, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var d = new i(l);
                    return Object.defineProperty(r, f, {
                        configurable: !0,
                        enumerable: !0,
                        value: d
                    }), d
                }
            })
        }
        s("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: Qt.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }), s("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: Qt.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }), s("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: Qt.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }), s("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: Qt.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }), s("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: Qt.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }), s("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: Qt.sha256,
            gRed: !1,
            g: ["9"]
        }), s("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: Qt.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var o;
        try {
            o = null.crash()
        } catch {
            o = void 0
        }
        s("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: Qt.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", o]
        })
    });

function ws(t) {
    if (!(this instanceof ws)) return new ws(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = Wn.toArray(t.entropy, t.entropyEnc || "hex"),
        r = Wn.toArray(t.nonce, t.nonceEnc || "hex"),
        n = Wn.toArray(t.pers, t.persEnc || "hex");
    nh(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
}
var Zg = ws;
ws.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
};
ws.prototype._hmac = function() {
    return new Qt.hmac(this.hash, this.K)
};
ws.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), !!e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
};
ws.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = Wn.toArray(e, r), n = Wn.toArray(n, i), nh(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
};
ws.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = Wn.toArray(n, i || "hex"), this._update(n));
    for (var s = []; s.length < e;) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
    var o = s.slice(0, e);
    return this._update(n), this._reseed++, Wn.encode(o, r)
};
var sh = Xr.assert;

function Ar(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
}
var oh = Ar;
Ar.fromPublic = function(e, r, n) {
    return r instanceof Ar ? r : new Ar(e, {
        pub: r,
        pubEnc: n
    })
};
Ar.fromPrivate = function(e, r, n) {
    return r instanceof Ar ? r : new Ar(e, {
        priv: r,
        privEnc: n
    })
};
Ar.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
    } : {
        result: !1,
        reason: "Public key * N != O"
    } : {
        result: !1,
        reason: "Public key is not a point"
    }
};
Ar.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub
};
Ar.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
};
Ar.prototype._importPrivate = function(e, r) {
    this.priv = new He(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n)
};
Ar.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont" ? sh(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && sh(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return
    }
    this.pub = this.ec.curve.decodePoint(e, r)
};
Ar.prototype.derive = function(e) {
    return e.validate() || sh(e.validate(), "public point not validated"), e.mul(this.priv).getX()
};
Ar.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n)
};
Ar.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this)
};
Ar.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
};
var h4 = Xr.assert;

function ju(t, e) {
    if (t instanceof ju) return t;
    this._importDER(t, e) || (h4(t.r && t.s, "Signature without r or s"), this.r = new He(t.r, 16), this.s = new He(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
}
var Wu = ju;

function d4() {
    this.place = 0
}

function ah(t, e) {
    var r = t[e.place++];
    if (!(r & 128)) return r;
    var n = r & 15;
    if (n === 0 || n > 4) return !1;
    for (var i = 0, s = 0, o = e.place; s < n; s++, o++) i <<= 8, i |= t[o], i >>>= 0;
    return i <= 127 ? !1 : (e.place = o, i)
}

function Yg(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r;) e++;
    return e === 0 ? t : t.slice(e)
}
ju.prototype._importDER = function(e, r) {
    e = Xr.toArray(e, r);
    var n = new d4;
    if (e[n.place++] !== 48) return !1;
    var i = ah(e, n);
    if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
    var s = ah(e, n);
    if (s === !1) return !1;
    var o = e.slice(n.place, s + n.place);
    if (n.place += s, e[n.place++] !== 2) return !1;
    var f = ah(e, n);
    if (f === !1 || e.length !== f + n.place) return !1;
    var l = e.slice(n.place, f + n.place);
    if (o[0] === 0)
        if (o[1] & 128) o = o.slice(1);
        else return !1;
    if (l[0] === 0)
        if (l[1] & 128) l = l.slice(1);
        else return !1;
    return this.r = new He(o), this.s = new He(l), this.recoveryParam = null, !0
};

function fh(t, e) {
    if (e < 128) {
        t.push(e);
        return
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r;) t.push(e >>> (r << 3) & 255);
    t.push(e)
}
ju.prototype.toDER = function(e) {
    var r = this.r.toArray(),
        n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Yg(r), n = Yg(n); !n[0] && !(n[1] & 128);) n = n.slice(1);
    var i = [2];
    fh(i, r.length), i = i.concat(r), i.push(2), fh(i, n.length);
    var s = i.concat(n),
        o = [48];
    return fh(o, s.length), o = o.concat(s), Xr.encode(o, e)
};
var p4 = function() {
        throw new Error("unsupported")
    },
    Qg = Xr.assert;

function hn(t) {
    if (!(this instanceof hn)) return new hn(t);
    typeof t == "string" && (Qg(Object.prototype.hasOwnProperty.call(qu, t), "Unknown curve " + t), t = qu[t]), t instanceof qu.PresetCurve && (t = {
        curve: t
    }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash
}
var m4 = hn;
hn.prototype.keyPair = function(e) {
    return new oh(this, e)
};
hn.prototype.keyFromPrivate = function(e, r) {
    return oh.fromPrivate(this, e, r)
};
hn.prototype.keyFromPublic = function(e, r) {
    return oh.fromPublic(this, e, r)
};
hn.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new Zg({
            hash: this.hash,
            pers: e.pers,
            persEnc: e.persEnc || "utf8",
            entropy: e.entropy || p4(this.hash.hmacStrength),
            entropyEnc: e.entropy && e.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), n = this.n.byteLength(), i = this.n.sub(new He(2));;) {
        var s = new He(r.generate(n));
        if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
    }
};
hn.prototype._truncateToN = function(e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength();
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
};
hn.prototype.sign = function(e, r, n, i) {
    typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new He(e, 16));
    for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), f = e.toArray("be", s), l = new Zg({
            hash: this.hash,
            entropy: o,
            nonce: f,
            pers: i.pers,
            persEnc: i.persEnc || "utf8"
        }), d = this.n.sub(new He(1)), p = 0;; p++) {
        var A = i.k ? i.k(p) : new He(l.generate(this.n.byteLength()));
        if (A = this._truncateToN(A, !0), !(A.cmpn(1) <= 0 || A.cmp(d) >= 0)) {
            var T = this.g.mul(A);
            if (!T.isInfinity()) {
                var N = T.getX(),
                    P = N.umod(this.n);
                if (P.cmpn(0) !== 0) {
                    var C = A.invm(this.n).mul(P.mul(r.getPrivate()).iadd(e));
                    if (C = C.umod(this.n), C.cmpn(0) !== 0) {
                        var S = (T.getY().isOdd() ? 1 : 0) | (N.cmp(P) !== 0 ? 2 : 0);
                        return i.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), S ^= 1), new Wu({
                            r: P,
                            s: C,
                            recoveryParam: S
                        })
                    }
                }
            }
        }
    }
};
hn.prototype.verify = function(e, r, n, i) {
    e = this._truncateToN(new He(e, 16)), n = this.keyFromPublic(n, i), r = new Wu(r, "hex");
    var s = r.r,
        o = r.s;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
    var f = o.invm(this.n),
        l = f.mul(e).umod(this.n),
        d = f.mul(s).umod(this.n),
        p;
    return this.curve._maxwellTrick ? (p = this.g.jmulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.eqXToP(s)) : (p = this.g.mulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(s) === 0)
};
hn.prototype.recoverPubKey = function(t, e, r, n) {
    Qg((3 & r) === r, "The recovery param is more than two bits"), e = new Wu(e, n);
    var i = this.n,
        s = new He(t),
        o = e.r,
        f = e.s,
        l = r & 1,
        d = r >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d) throw new Error("Unable to find sencond key candinate");
    d ? o = this.curve.pointFromX(o.add(this.curve.n), l) : o = this.curve.pointFromX(o, l);
    var p = e.r.invm(i),
        A = i.sub(s).mul(p).umod(i),
        T = f.mul(p).umod(i);
    return this.g.mulAdd(A, o, T)
};
hn.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new Wu(e, n), e.recoveryParam !== null) return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
        var s;
        try {
            s = this.recoverPubKey(t, e, i)
        } catch {
            continue
        }
        if (s.eq(r)) return i
    }
    throw new Error("Unable to find valid recovery factor")
};
var y4 = Xo(function(t, e) {
        var r = e;
        r.version = "6.5.4", r.utils = Xr, r.rand = function() {
            throw new Error("unsupported")
        }, r.curve = Hu, r.curves = qu, r.ec = m4, r.eddsa = null
    }),
    g4 = y4.ec;
const x4 = "bytes/5.5.0",
    Xt = new W(x4);

function ex(t) {
    return !!t.toHexString
}

function ef(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return ef(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function b4(t) {
    return eo(t) && !(t.length % 2) || uh(t)
}

function tx(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function uh(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !tx(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!tx(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Pr(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Xt.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), ef(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), ex(t) && (t = t.toHexString()), eo(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Xt.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return ef(new Uint8Array(n))
    }
    return uh(t) ? ef(new Uint8Array(t)) : Xt.throwArgumentError("invalid arrayify value", "value", t)
}

function v4(t, e) {
    t = Pr(t), t.length > e && Xt.throwArgumentError("value out of range", "value", arguments[0]);
    const r = new Uint8Array(e);
    return r.set(t, e - t.length), ef(r)
}

function eo(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const lh = "0123456789abcdef";

function Si(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Xt.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = lh[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), ex(t)) return t.toHexString();
    if (eo(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Xt.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (uh(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += lh[(i & 240) >> 4] + lh[i & 15]
        }
        return r
    }
    return Xt.throwArgumentError("invalid hexlify value", "value", t)
}

function Jo(t, e) {
    for (typeof t != "string" ? t = Si(t) : eo(t) || Xt.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && Xt.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;) t = "0x0" + t.substring(2);
    return t
}

function rx(t) {
    const e = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0
    };
    if (b4(t)) {
        const r = Pr(t);
        r.length !== 65 && Xt.throwArgumentError("invalid signature string; must be 65 bytes", "signature", t), e.r = Si(r.slice(0, 32)), e.s = Si(r.slice(32, 64)), e.v = r[64], e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : Xt.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Si(r.slice(32, 64))
    } else {
        if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
            const i = v4(Pr(e._vs), 32);
            e._vs = Si(i);
            const s = i[0] >= 128 ? 1 : 0;
            e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && Xt.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
            const o = Si(i);
            e.s == null ? e.s = o : e.s !== o && Xt.throwArgumentError("signature v mismatch _vs", "signature", t)
        }
        if (e.recoveryParam == null) e.v == null ? Xt.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
        else if (e.v == null) e.v = 27 + e.recoveryParam;
        else {
            const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
            e.recoveryParam !== i && Xt.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
        }
        e.r == null || !eo(e.r) ? Xt.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = Jo(e.r, 32), e.s == null || !eo(e.s) ? Xt.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = Jo(e.s, 32);
        const r = Pr(e.s);
        r[0] >= 128 && Xt.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
        const n = Si(r);
        e._vs && (eo(e._vs) || Xt.throwArgumentError("signature invalid _vs", "signature", t), e._vs = Jo(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && Xt.throwArgumentError("signature _vs mismatch v and s", "signature", t)
    }
    return e
}
const w4 = "signing-key/5.5.0",
    nx = new W(w4);
let ch = null;

function Pi() {
    return ch || (ch = new g4("secp256k1")), ch
}
class E4 {
    constructor(e) {
        pe(this, "curve", "secp256k1"), pe(this, "privateKey", Si(e));
        const r = Pi().keyFromPrivate(Pr(this.privateKey));
        pe(this, "publicKey", "0x" + r.getPublic(!1, "hex")), pe(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), pe(this, "_isSigningKey", !0)
    }
    _addPoint(e) {
        const r = Pi().keyFromPublic(Pr(this.publicKey)),
            n = Pi().keyFromPublic(Pr(e));
        return "0x" + r.pub.add(n.pub).encodeCompressed("hex")
    }
    signDigest(e) {
        const r = Pi().keyFromPrivate(Pr(this.privateKey)),
            n = Pr(e);
        n.length !== 32 && nx.throwArgumentError("bad digest length", "digest", e);
        const i = r.sign(n, {
            canonical: !0
        });
        return rx({
            recoveryParam: i.recoveryParam,
            r: Jo("0x" + i.r.toString(16), 32),
            s: Jo("0x" + i.s.toString(16), 32)
        })
    }
    computeSharedSecret(e) {
        const r = Pi().keyFromPrivate(Pr(this.privateKey)),
            n = Pi().keyFromPublic(Pr(ix(e)));
        return Jo("0x" + r.derive(n.getPublic()).toString(16), 32)
    }
    static isSigningKey(e) {
        return !!(e && e._isSigningKey)
    }
}

function A4(t, e) {
    const r = rx(e),
        n = {
            r: Pr(r.r),
            s: Pr(r.s)
        };
    return "0x" + Pi().recoverPubKey(Pr(t), n, r.recoveryParam).encode("hex", !1)
}

function ix(t, e) {
    const r = Pr(t);
    if (r.length === 32) {
        const n = new E4(r);
        return e ? "0x" + Pi().keyFromPrivate(r).getPublic(!0, "hex") : n.publicKey
    } else {
        if (r.length === 33) return e ? Si(r) : "0x" + Pi().keyFromPublic(r).getPublic(!1, "hex");
        if (r.length === 65) return e ? "0x" + Pi().keyFromPublic(r).getPublic(!0, "hex") : Si(r)
    }
    return nx.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const _4 = "transactions/5.5.0",
    Yi = new W(_4);
var sx;
(function(t) {
    t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559"
})(sx || (sx = {}));

function hh(t) {
    return t === "0x" ? null : nr(t)
}

function _r(t) {
    return t === "0x" ? ag : zt.from(t)
}

function T4(t) {
    const e = ix(t);
    return nr(Eg(Kt(Eg(e, 1)), 12))
}

function ox(t, e) {
    return T4(A4(Js(t), e))
}

function Jr(t, e) {
    const r = Xa(zt.from(t).toHexString());
    return r.length > 32 && Yi.throwArgumentError("invalid length for " + e, "transaction:" + e, t), r
}

function dh(t, e) {
    return {
        address: nr(t),
        storageKeys: (e || []).map((r, n) => (CE(r) !== 32 && Yi.throwArgumentError("invalid access list storageKey", `accessList[${t}:${n}]`, r), r.toLowerCase()))
    }
}

function Zo(t) {
    if (Array.isArray(t)) return t.map((r, n) => Array.isArray(r) ? (r.length > 2 && Yi.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${n}]`, r), dh(r[0], r[1])) : dh(r.address, r.storageKeys));
    const e = Object.keys(t).map(r => {
        const n = t[r].reduce((i, s) => (i[s] = !0, i), {});
        return dh(r, Object.keys(n).sort())
    });
    return e.sort((r, n) => r.address.localeCompare(n.address)), e
}

function ax(t) {
    return Zo(t).map(e => [e.address, e.storageKeys])
}

function M4(t, e) {
    if (t.gasPrice != null) {
        const n = zt.from(t.gasPrice),
            i = zt.from(t.maxFeePerGas || 0);
        n.eq(i) || Yi.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice: n,
            maxFeePerGas: i
        })
    }
    const r = [Jr(t.chainId || 0, "chainId"), Jr(t.nonce || 0, "nonce"), Jr(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), Jr(t.maxFeePerGas || 0, "maxFeePerGas"), Jr(t.gasLimit || 0, "gasLimit"), t.to != null ? nr(t.to) : "0x", Jr(t.value || 0, "value"), t.data || "0x", ax(t.accessList || [])];
    if (e) {
        const n = _g(e);
        r.push(Jr(n.recoveryParam, "recoveryParam")), r.push(Xa(n.r)), r.push(Xa(n.s))
    }
    return Ag(["0x02", Ru(r)])
}

function N4(t, e) {
    const r = [Jr(t.chainId || 0, "chainId"), Jr(t.nonce || 0, "nonce"), Jr(t.gasPrice || 0, "gasPrice"), Jr(t.gasLimit || 0, "gasLimit"), t.to != null ? nr(t.to) : "0x", Jr(t.value || 0, "value"), t.data || "0x", ax(t.accessList || [])];
    if (e) {
        const n = _g(e);
        r.push(Jr(n.recoveryParam, "recoveryParam")), r.push(Xa(n.r)), r.push(Xa(n.s))
    }
    return Ag(["0x01", Ru(r)])
}

function fx(t, e, r) {
    try {
        const n = _r(e[0]).toNumber();
        if (n !== 0 && n !== 1) throw new Error("bad recid");
        t.v = n
    } catch {
        Yi.throwArgumentError("invalid v for transaction type: 1", "v", e[0])
    }
    t.r = Zs(e[1], 32), t.s = Zs(e[2], 32);
    try {
        const n = Kt(r(t));
        t.from = ox(n, {
            r: t.r,
            s: t.s,
            recoveryParam: t.v
        })
    } catch (n) {
        console.log(n)
    }
}

function S4(t) {
    const e = Ic(t.slice(1));
    e.length !== 9 && e.length !== 12 && Yi.throwArgumentError("invalid component count for transaction type: 2", "payload", Er(t));
    const r = _r(e[2]),
        n = _r(e[3]),
        i = {
            type: 2,
            chainId: _r(e[0]).toNumber(),
            nonce: _r(e[1]).toNumber(),
            maxPriorityFeePerGas: r,
            maxFeePerGas: n,
            gasPrice: null,
            gasLimit: _r(e[4]),
            to: hh(e[5]),
            value: _r(e[6]),
            data: e[7],
            accessList: Zo(e[8])
        };
    return e.length === 9 || (i.hash = Kt(t), fx(i, e.slice(9), M4)), i
}

function P4(t) {
    const e = Ic(t.slice(1));
    e.length !== 8 && e.length !== 11 && Yi.throwArgumentError("invalid component count for transaction type: 1", "payload", Er(t));
    const r = {
        type: 1,
        chainId: _r(e[0]).toNumber(),
        nonce: _r(e[1]).toNumber(),
        gasPrice: _r(e[2]),
        gasLimit: _r(e[3]),
        to: hh(e[4]),
        value: _r(e[5]),
        data: e[6],
        accessList: Zo(e[7])
    };
    return e.length === 8 || (r.hash = Kt(t), fx(r, e.slice(8), N4)), r
}

function I4(t) {
    const e = Ic(t);
    e.length !== 9 && e.length !== 6 && Yi.throwArgumentError("invalid raw transaction", "rawTransaction", t);
    const r = {
        nonce: _r(e[0]).toNumber(),
        gasPrice: _r(e[1]),
        gasLimit: _r(e[2]),
        to: hh(e[3]),
        value: _r(e[4]),
        data: e[5],
        chainId: 0
    };
    if (e.length === 6) return r;
    try {
        r.v = zt.from(e[6]).toNumber()
    } catch (n) {
        return console.log(n), r
    }
    if (r.r = Zs(e[7], 32), r.s = Zs(e[8], 32), zt.from(r.r).isZero() && zt.from(r.s).isZero()) r.chainId = r.v, r.v = 0;
    else {
        r.chainId = Math.floor((r.v - 35) / 2), r.chainId < 0 && (r.chainId = 0);
        let n = r.v - 27;
        const i = e.slice(0, 6);
        r.chainId !== 0 && (i.push(Er(r.chainId)), i.push("0x"), i.push("0x"), n -= r.chainId * 2 + 8);
        const s = Kt(Ru(i));
        try {
            r.from = ox(s, {
                r: Er(r.r),
                s: Er(r.s),
                recoveryParam: n
            })
        } catch (o) {
            console.log(o)
        }
        r.hash = Kt(t)
    }
    return r.type = null, r
}

function R4(t) {
    const e = Js(t);
    if (e[0] > 127) return I4(e);
    switch (e[0]) {
        case 1:
            return P4(e);
        case 2:
            return S4(e)
    }
    return Yi.throwError(`unsupported transaction type: ${e[0]}`, W.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: e[0]
    })
}
const k4 = "contracts/5.5.0";
var to = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Lt = new W(k4);

function Vu(t, e) {
    return to(this, void 0, void 0, function*() {
        const r = yield e;
        typeof r != "string" && Lt.throwArgumentError("invalid address or ENS name", "name", r);
        try {
            return nr(r)
        } catch {}
        t || Lt.throwError("a provider or signer is needed to resolve ENS names", W.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName"
        });
        const n = yield t.resolveName(r);
        return n == null && Lt.throwArgumentError("resolver or addr is not configured for ENS name", "name", r), n
    })
}

function Ku(t, e, r) {
    return to(this, void 0, void 0, function*() {
        return Array.isArray(r) ? yield Promise.all(r.map((n, i) => Ku(t, Array.isArray(e) ? e[i] : e[n.name], n))): r.type === "address" ? yield Vu(t, e): r.type === "tuple" ? yield Ku(t, e, r.components): r.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map(n => Ku(t, n, r.arrayChildren))): Promise.reject(Lt.makeError("invalid value for array", W.errors.INVALID_ARGUMENT, {
            argument: "value",
            value: e
        })): e
    })
}

function Xu(t, e, r) {
    return to(this, void 0, void 0, function*() {
        let n = {};
        r.length === e.inputs.length + 1 && typeof r[r.length - 1] == "object" && (n = Yt(r.pop())), Lt.checkArgumentCount(r.length, e.inputs.length, "passed to contract"), t.signer ? n.from ? n.from = kt({
            override: Vu(t.signer, n.from),
            signer: t.signer.getAddress()
        }).then(d => to(this, void 0, void 0, function*() {
            return nr(d.signer) !== d.override && Lt.throwError("Contract with a Signer cannot override from", W.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.from"
            }), d.override
        })) : n.from = t.signer.getAddress() : n.from && (n.from = Vu(t.provider, n.from));
        const i = yield kt({
            args: Ku(t.signer || t.provider, r, e.inputs),
            address: t.resolvedAddress,
            overrides: kt(n) || {}
        }), s = t.interface.encodeFunctionData(e, i.args), o = {
            data: s,
            to: i.address
        }, f = i.overrides;
        if (f.nonce != null && (o.nonce = St.from(f.nonce).toNumber()), f.gasLimit != null && (o.gasLimit = St.from(f.gasLimit)), f.gasPrice != null && (o.gasPrice = St.from(f.gasPrice)), f.maxFeePerGas != null && (o.maxFeePerGas = St.from(f.maxFeePerGas)), f.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = St.from(f.maxPriorityFeePerGas)), f.from != null && (o.from = f.from), f.type != null && (o.type = f.type), f.accessList != null && (o.accessList = Zo(f.accessList)), o.gasLimit == null && e.gas != null) {
            let d = 21e3;
            const p = $n(s);
            for (let A = 0; A < p.length; A++) d += 4, p[A] && (d += 64);
            o.gasLimit = St.from(e.gas).add(d)
        }
        if (f.value) {
            const d = St.from(f.value);
            !d.isZero() && !e.payable && Lt.throwError("non-payable method cannot override value", W.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: n.value
            }), o.value = d
        }
        f.customData && (o.customData = Yt(f.customData)), delete n.nonce, delete n.gasLimit, delete n.gasPrice, delete n.from, delete n.value, delete n.type, delete n.accessList, delete n.maxFeePerGas, delete n.maxPriorityFeePerGas, delete n.customData;
        const l = Object.keys(n).filter(d => n[d] != null);
        return l.length && Lt.throwError(`cannot override ${l.map(d=>JSON.stringify(d)).join(",")}`, W.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides",
            overrides: l
        }), o
    })
}

function O4(t, e) {
    return function(...r) {
        return Xu(t, e, r)
    }
}

function C4(t, e) {
    const r = t.signer || t.provider;
    return function(...n) {
        return to(this, void 0, void 0, function*() {
            r || Lt.throwError("estimate require a provider or signer", W.errors.UNSUPPORTED_OPERATION, {
                operation: "estimateGas"
            });
            const i = yield Xu(t, e, n);
            return yield r.estimateGas(i)
        })
    }
}

function F4(t, e) {
    const r = e.wait.bind(e);
    e.wait = n => r(n).then(i => (i.events = i.logs.map(s => {
        let o = Wi(s),
            f = null;
        try {
            f = t.interface.parseLog(s)
        } catch {}
        return f && (o.args = f.args, o.decode = (l, d) => t.interface.decodeEventLog(f.eventFragment, l, d), o.event = f.name, o.eventSignature = f.signature), o.removeListener = () => t.provider, o.getBlock = () => t.provider.getBlock(i.blockHash), o.getTransaction = () => t.provider.getTransaction(i.transactionHash), o.getTransactionReceipt = () => Promise.resolve(i), o
    }), i))
}

function ux(t, e, r) {
    const n = t.signer || t.provider;
    return function(...i) {
        return to(this, void 0, void 0, function*() {
            let s;
            if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
                const l = Yt(i.pop());
                l.blockTag != null && (s = yield l.blockTag), delete l.blockTag, i.push(l)
            }
            t.deployTransaction != null && (yield t._deployed(s));
            const o = yield Xu(t, e, i), f = yield n.call(o, s);
            try {
                let l = t.interface.decodeFunctionResult(e, f);
                return r && e.outputs.length === 1 && (l = l[0]), l
            } catch (l) {
                throw l.code === W.errors.CALL_EXCEPTION && (l.address = t.address, l.args = i, l.transaction = o), l
            }
        })
    }
}

function D4(t, e) {
    return function(...r) {
        return to(this, void 0, void 0, function*() {
            t.signer || Lt.throwError("sending a transaction requires a signer", W.errors.UNSUPPORTED_OPERATION, {
                operation: "sendTransaction"
            }), t.deployTransaction != null && (yield t._deployed());
            const n = yield Xu(t, e, r), i = yield t.signer.sendTransaction(n);
            return F4(t, i), i
        })
    }
}

function lx(t, e, r) {
    return e.constant ? ux(t, e, r) : D4(t, e)
}

function cx(t) {
    return t.address && (t.topics == null || t.topics.length === 0) ? "*" : (t.address || "*") + "@" + (t.topics ? t.topics.map(e => Array.isArray(e) ? e.join("|") : e).join(":") : "")
}
class tf {
    constructor(e, r) {
        pe(this, "tag", e), pe(this, "filter", r), this._listeners = []
    }
    addListener(e, r) {
        this._listeners.push({
            listener: e,
            once: r
        })
    }
    removeListener(e) {
        let r = !1;
        this._listeners = this._listeners.filter(n => r || n.listener !== e ? !0 : (r = !0, !1))
    }
    removeAllListeners() {
        this._listeners = []
    }
    listeners() {
        return this._listeners.map(e => e.listener)
    }
    listenerCount() {
        return this._listeners.length
    }
    run(e) {
        const r = this.listenerCount();
        return this._listeners = this._listeners.filter(n => {
            const i = e.slice();
            return setTimeout(() => {
                n.listener.apply(this, i)
            }, 0), !n.once
        }), r
    }
    prepareEvent(e) {}
    getEmit(e) {
        return [e]
    }
}
class U4 extends tf {
    constructor() {
        super("error", null)
    }
}
class hx extends tf {
    constructor(e, r, n, i) {
        const s = {
            address: e
        };
        let o = r.getEventTopic(n);
        i ? (o !== i[0] && Lt.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [o];
        super(cx(s), s);
        pe(this, "address", e), pe(this, "interface", r), pe(this, "fragment", n)
    }
    prepareEvent(e) {
        super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (r, n) => this.interface.decodeEventLog(this.fragment, r, n);
        try {
            e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics)
        } catch (r) {
            e.args = null, e.decodeError = r
        }
    }
    getEmit(e) {
        const r = l5(e.args);
        if (r.length) throw r[0].error;
        const n = (e.args || []).slice();
        return n.push(e), n
    }
}
class dx extends tf {
    constructor(e, r) {
        super("*", {
            address: e
        });
        pe(this, "address", e), pe(this, "interface", r)
    }
    prepareEvent(e) {
        super.prepareEvent(e);
        try {
            const r = this.interface.parseLog(e);
            e.event = r.name, e.eventSignature = r.signature, e.decode = (n, i) => this.interface.decodeEventLog(r.eventFragment, n, i), e.args = r.args
        } catch {}
    }
}
class L4 {
    constructor(e, r, n) {
        Lt.checkNew(new.target, B4), pe(this, "interface", hi(new.target, "getInterface")(r)), n == null ? (pe(this, "provider", null), pe(this, "signer", null)) : Du.isSigner(n) ? (pe(this, "provider", n.provider || null), pe(this, "signer", n)) : Va.isProvider(n) ? (pe(this, "provider", n), pe(this, "signer", null)) : Lt.throwArgumentError("invalid signer or provider", "signerOrProvider", n), pe(this, "callStatic", {}), pe(this, "estimateGas", {}), pe(this, "functions", {}), pe(this, "populateTransaction", {}), pe(this, "filters", {}); {
            const o = {};
            Object.keys(this.interface.events).forEach(f => {
                const l = this.interface.events[f];
                pe(this.filters, f, (...d) => ({
                    address: this.address,
                    topics: this.interface.encodeFilterTopics(l, d)
                })), o[l.name] || (o[l.name] = []), o[l.name].push(f)
            }), Object.keys(o).forEach(f => {
                const l = o[f];
                l.length === 1 ? pe(this.filters, f, this.filters[l[0]]) : Lt.warn(`Duplicate definition of ${f} (${l.join(", ")})`)
            })
        }
        if (pe(this, "_runningEvents", {}), pe(this, "_wrappedEmits", {}), e == null && Lt.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), pe(this, "address", e), this.provider) pe(this, "resolvedAddress", Vu(this.provider, e));
        else try {
            pe(this, "resolvedAddress", Promise.resolve(nr(e)))
        } catch {
            Lt.throwError("provider is required to use ENS name as contract address", W.errors.UNSUPPORTED_OPERATION, {
                operation: "new Contract"
            })
        }
        const i = {},
            s = {};
        Object.keys(this.interface.functions).forEach(o => {
            const f = this.interface.functions[o];
            if (s[o]) {
                Lt.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`);
                return
            }
            s[o] = !0; {
                const l = f.name;
                i[`%${l}`] || (i[`%${l}`] = []), i[`%${l}`].push(o)
            }
            this[o] == null && pe(this, o, lx(this, f, !0)), this.functions[o] == null && pe(this.functions, o, lx(this, f, !1)), this.callStatic[o] == null && pe(this.callStatic, o, ux(this, f, !0)), this.populateTransaction[o] == null && pe(this.populateTransaction, o, O4(this, f)), this.estimateGas[o] == null && pe(this.estimateGas, o, C4(this, f))
        }), Object.keys(i).forEach(o => {
            const f = i[o];
            if (f.length > 1) return;
            o = o.substring(1);
            const l = f[0];
            try {
                this[o] == null && pe(this, o, this[l])
            } catch {}
            this.functions[o] == null && pe(this.functions, o, this.functions[l]), this.callStatic[o] == null && pe(this.callStatic, o, this.callStatic[l]), this.populateTransaction[o] == null && pe(this.populateTransaction, o, this.populateTransaction[l]), this.estimateGas[o] == null && pe(this.estimateGas, o, this.estimateGas[l])
        })
    }
    static getContractAddress(e) {
        return Qy(e)
    }
    static getInterface(e) {
        return Fu.isInterface(e) ? e : new Fu(e)
    }
    deployed() {
        return this._deployed()
    }
    _deployed(e) {
        return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, e).then(r => (r === "0x" && Lt.throwError("contract not deployed", W.errors.UNSUPPORTED_OPERATION, {
            contractAddress: this.address,
            operation: "getDeployed"
        }), this))), this._deployedPromise
    }
    fallback(e) {
        this.signer || Lt.throwError("sending a transactions require a signer", W.errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction(fallback)"
        });
        const r = Yt(e || {});
        return ["from", "to"].forEach(function(n) {
            r[n] != null && Lt.throwError("cannot override " + n, W.errors.UNSUPPORTED_OPERATION, {
                operation: n
            })
        }), r.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(r))
    }
    connect(e) {
        typeof e == "string" && (e = new Uu(e, this.provider));
        const r = new this.constructor(this.address, this.interface, e);
        return this.deployTransaction && pe(r, "deployTransaction", this.deployTransaction), r
    }
    attach(e) {
        return new this.constructor(e, this.interface, this.signer || this.provider)
    }
    static isIndexed(e) {
        return zc.isIndexed(e)
    }
    _normalizeRunningEvent(e) {
        return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e
    }
    _getRunningEvent(e) {
        if (typeof e == "string") {
            if (e === "error") return this._normalizeRunningEvent(new U4);
            if (e === "event") return this._normalizeRunningEvent(new tf("event", null));
            if (e === "*") return this._normalizeRunningEvent(new dx(this.address, this.interface));
            const r = this.interface.getEvent(e);
            return this._normalizeRunningEvent(new hx(this.address, this.interface, r))
        }
        if (e.topics && e.topics.length > 0) {
            try {
                const n = e.topics[0];
                if (typeof n != "string") throw new Error("invalid topic");
                const i = this.interface.getEvent(n);
                return this._normalizeRunningEvent(new hx(this.address, this.interface, i, e.topics))
            } catch {}
            const r = {
                address: this.address,
                topics: e.topics
            };
            return this._normalizeRunningEvent(new tf(cx(r), r))
        }
        return this._normalizeRunningEvent(new dx(this.address, this.interface))
    }
    _checkRunningEvents(e) {
        if (e.listenerCount() === 0) {
            delete this._runningEvents[e.tag];
            const r = this._wrappedEmits[e.tag];
            r && e.filter && (this.provider.off(e.filter, r), delete this._wrappedEmits[e.tag])
        }
    }
    _wrapEvent(e, r, n) {
        const i = Wi(r);
        return i.removeListener = () => {
            !n || (e.removeListener(n), this._checkRunningEvents(e))
        }, i.getBlock = () => this.provider.getBlock(r.blockHash), i.getTransaction = () => this.provider.getTransaction(r.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(r.transactionHash), e.prepareEvent(i), i
    }
    _addEventListener(e, r, n) {
        if (this.provider || Lt.throwError("events require a provider or a signer with a provider", W.errors.UNSUPPORTED_OPERATION, {
                operation: "once"
            }), e.addListener(r, n), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
            const i = s => {
                let o = this._wrapEvent(e, s, r);
                if (o.decodeError == null) try {
                    const f = e.getEmit(o);
                    this.emit(e.filter, ...f)
                } catch (f) {
                    o.decodeError = f.error
                }
                e.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o)
            };
            this._wrappedEmits[e.tag] = i, e.filter != null && this.provider.on(e.filter, i)
        }
    }
    queryFilter(e, r, n) {
        const i = this._getRunningEvent(e),
            s = Yt(i.filter);
        return typeof r == "string" && Gn(r, 32) ? (n != null && Lt.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), s.blockHash = r) : (s.fromBlock = r != null ? r : 0, s.toBlock = n != null ? n : "latest"), this.provider.getLogs(s).then(o => o.map(f => this._wrapEvent(i, f, null)))
    }
    on(e, r) {
        return this._addEventListener(this._getRunningEvent(e), r, !1), this
    }
    once(e, r) {
        return this._addEventListener(this._getRunningEvent(e), r, !0), this
    }
    emit(e, ...r) {
        if (!this.provider) return !1;
        const n = this._getRunningEvent(e),
            i = n.run(r) > 0;
        return this._checkRunningEvents(n), i
    }
    listenerCount(e) {
        return this.provider ? e == null ? Object.keys(this._runningEvents).reduce((r, n) => r + this._runningEvents[n].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0
    }
    listeners(e) {
        if (!this.provider) return [];
        if (e == null) {
            const r = [];
            for (let n in this._runningEvents) this._runningEvents[n].listeners().forEach(i => {
                r.push(i)
            });
            return r
        }
        return this._getRunningEvent(e).listeners()
    }
    removeAllListeners(e) {
        if (!this.provider) return this;
        if (e == null) {
            for (const n in this._runningEvents) {
                const i = this._runningEvents[n];
                i.removeAllListeners(), this._checkRunningEvents(i)
            }
            return this
        }
        const r = this._getRunningEvent(e);
        return r.removeAllListeners(), this._checkRunningEvents(r), this
    }
    off(e, r) {
        if (!this.provider) return this;
        const n = this._getRunningEvent(e);
        return n.removeListener(r), this._checkRunningEvents(n), this
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
}
class B4 extends L4 {}
const $4 = "bytes/5.5.0",
    Ii = new W($4);

function px(t) {
    return !!t.toHexString
}

function rf(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return rf(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function mx(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function ph(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !mx(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!mx(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function ro(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Ii.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), rf(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), px(t) && (t = t.toHexString()), Ht(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Ii.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return rf(new Uint8Array(n))
    }
    return ph(t) ? rf(new Uint8Array(t)) : Ii.throwArgumentError("invalid arrayify value", "value", t)
}

function Yo(t) {
    const e = t.map(i => ro(i)),
        r = e.reduce((i, s) => i + s.length, 0),
        n = new Uint8Array(r);
    return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), rf(n)
}

function Ht(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const mh = "0123456789abcdef";

function Jt(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Ii.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = mh[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), px(t)) return t.toHexString();
    if (Ht(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : Ii.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (ph(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += mh[(i & 240) >> 4] + mh[i & 15]
        }
        return r
    }
    return Ii.throwArgumentError("invalid hexlify value", "value", t)
}

function Ju(t) {
    if (typeof t != "string") t = Jt(t);
    else if (!Ht(t) || t.length % 2) return null;
    return (t.length - 2) / 2
}

function nf(t, e, r) {
    return typeof t != "string" ? t = Jt(t) : (!Ht(t) || t.length % 2) && Ii.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
}

function Es(t) {
    let e = "0x";
    return t.forEach(r => {
        e += Jt(r).substring(2)
    }), e
}

function yh(t) {
    const e = G4(Jt(t, {
        hexPad: "left"
    }));
    return e === "0x" ? "0x0" : e
}

function G4(t) {
    typeof t != "string" && (t = Jt(t)), Ht(t) || Ii.throwArgumentError("invalid hex string", "value", t), t = t.substring(2);
    let e = 0;
    for (; e < t.length && t[e] === "0";) e++;
    return "0x" + t.substring(e)
}

function Qi(t, e) {
    for (typeof t != "string" ? t = Jt(t) : Ht(t) || Ii.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && Ii.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;) t = "0x0" + t.substring(2);
    return t
}
const z4 = "bignumber/5.5.0";
var gh = He.BN;
const Ri = new W(z4),
    xh = {},
    yx = 9007199254740991;
let gx = !1;
class We {
    constructor(e, r) {
        Ri.checkNew(new.target, We), e !== xh && Ri.throwError("cannot call constructor directly; use BigNumber.from", W.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return Br(ct(this).fromTwos(e))
    }
    toTwos(e) {
        return Br(ct(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? We.from(this._hex.substring(1)) : this
    }
    add(e) {
        return Br(ct(this).add(ct(e)))
    }
    sub(e) {
        return Br(ct(this).sub(ct(e)))
    }
    div(e) {
        return We.from(e).isZero() && dn("division by zero", "div"), Br(ct(this).div(ct(e)))
    }
    mul(e) {
        return Br(ct(this).mul(ct(e)))
    }
    mod(e) {
        const r = ct(e);
        return r.isNeg() && dn("cannot modulo negative values", "mod"), Br(ct(this).umod(r))
    }
    pow(e) {
        const r = ct(e);
        return r.isNeg() && dn("cannot raise to negative values", "pow"), Br(ct(this).pow(r))
    }
    and(e) {
        const r = ct(e);
        return (this.isNegative() || r.isNeg()) && dn("cannot 'and' negative values", "and"), Br(ct(this).and(r))
    }
    or(e) {
        const r = ct(e);
        return (this.isNegative() || r.isNeg()) && dn("cannot 'or' negative values", "or"), Br(ct(this).or(r))
    }
    xor(e) {
        const r = ct(e);
        return (this.isNegative() || r.isNeg()) && dn("cannot 'xor' negative values", "xor"), Br(ct(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && dn("cannot mask negative values", "mask"), Br(ct(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && dn("cannot shift negative values", "shl"), Br(ct(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && dn("cannot shift negative values", "shr"), Br(ct(this).shrn(e))
    }
    eq(e) {
        return ct(this).eq(ct(e))
    }
    lt(e) {
        return ct(this).lt(ct(e))
    }
    lte(e) {
        return ct(this).lte(ct(e))
    }
    gt(e) {
        return ct(this).gt(ct(e))
    }
    gte(e) {
        return ct(this).gte(ct(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return ct(this).isZero()
    }
    toNumber() {
        try {
            return ct(this).toNumber()
        } catch {
            dn("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return Ri.throwError("this platform does not support BigInt", W.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? gx || (gx = !0, Ri.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? Ri.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", W.errors.UNEXPECTED_ARGUMENT, {}) : Ri.throwError("BigNumber.toString does not accept parameters", W.errors.UNEXPECTED_ARGUMENT, {})), ct(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof We) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new We(xh, sf(e)) : e.match(/^-?[0-9]+$/) ? new We(xh, sf(new gh(e))) : Ri.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && dn("underflow", "BigNumber.from", e), (e >= yx || e <= -yx) && dn("overflow", "BigNumber.from", e), We.from(String(e));
        const r = e;
        if (typeof r == "bigint") return We.from(r.toString());
        if (ph(r)) return We.from(Jt(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return We.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && (Ht(n) || n[0] === "-" && Ht(n.substring(1)))) return We.from(n)
            }
        return Ri.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function sf(t) {
    if (typeof t != "string") return sf(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && Ri.throwArgumentError("invalid hex", "value", t), t = sf(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function Br(t) {
    return We.from(sf(t))
}

function ct(t) {
    const e = We.from(t).toHexString();
    return e[0] === "-" ? new gh("-" + e.substring(3), 16) : new gh(e.substring(2), 16)
}

function dn(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), Ri.throwError(t, W.errors.NUMERIC_FAULT, n)
}
const H4 = "abstract-signer/5.5.0";
var Vn = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Kn = new W(H4),
    q4 = ["accessList", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
    j4 = [W.errors.INSUFFICIENT_FUNDS, W.errors.NONCE_EXPIRED, W.errors.REPLACEMENT_UNDERPRICED];
class bh {
    constructor() {
        Kn.checkAbstract(new.target, bh), pe(this, "_isSigner", !0)
    }
    getBalance(e) {
        return Vn(this, void 0, void 0, function*() {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return Vn(this, void 0, void 0, function*() {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return Vn(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const r = yield kt(this.checkTransaction(e));
            return yield this.provider.estimateGas(r)
        })
    }
    call(e, r) {
        return Vn(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const n = yield kt(this.checkTransaction(e));
            return yield this.provider.call(n, r)
        })
    }
    sendTransaction(e) {
        return Vn(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const r = yield this.populateTransaction(e), n = yield this.signTransaction(r);
            return yield this.provider.sendTransaction(n)
        })
    }
    getChainId() {
        return Vn(this, void 0, void 0, function*() {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return Vn(this, void 0, void 0, function*() {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return Vn(this, void 0, void 0, function*() {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return Vn(this, void 0, void 0, function*() {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const n in e) q4.indexOf(n) === -1 && Kn.throwArgumentError("invalid transaction key: " + n, "transaction", e);
        const r = Yt(e);
        return r.from == null ? r.from = this.getAddress() : r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(n => (n[0].toLowerCase() !== n[1].toLowerCase() && Kn.throwArgumentError("from address mismatch", "transaction", e), n[0])), r
    }
    populateTransaction(e) {
        return Vn(this, void 0, void 0, function*() {
            const r = yield kt(this.checkTransaction(e));
            r.to != null && (r.to = Promise.resolve(r.to).then(i => Vn(this, void 0, void 0, function*() {
                if (i == null) return null;
                const s = yield this.resolveName(i);
                return s == null && Kn.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
            })), r.to.catch(i => {}));
            const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
            if (r.gasPrice != null && (r.type === 2 || n) ? Kn.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (r.type === 0 || r.type === 1) && n && Kn.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
            else if (r.type === 0 || r.type === 1) r.gasPrice == null && (r.gasPrice = this.getGasPrice());
            else {
                const i = yield this.getFeeData();
                if (r.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (r.type = 2, r.gasPrice != null) {
                            const s = r.gasPrice;
                            delete r.gasPrice, r.maxFeePerGas = s, r.maxPriorityFeePerGas = s
                        } else r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
                else i.gasPrice != null ? (n && Kn.throwError("network does not support EIP-1559", W.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : Kn.throwError("failed to get consistent fee data", W.errors.UNSUPPORTED_OPERATION, {
                    operation: "signer.getFeeData"
                });
                else r.type === 2 && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return r.nonce == null && (r.nonce = this.getTransactionCount("pending")), r.gasLimit == null && (r.gasLimit = this.estimateGas(r).catch(i => {
                if (j4.indexOf(i.code) >= 0) throw i;
                return Kn.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", W.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: i,
                    tx: r
                })
            })), r.chainId == null ? r.chainId = this.getChainId() : r.chainId = Promise.all([Promise.resolve(r.chainId), this.getChainId()]).then(i => (i[1] !== 0 && i[0] !== i[1] && Kn.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield kt(r)
        })
    }
    _checkProvider(e) {
        this.provider || Kn.throwError("missing provider", W.errors.UNSUPPORTED_OPERATION, {
            operation: e || "_checkProvider"
        })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}

function xx(t) {
    return Kt(xi(t))
}
const bx = "hash/5.5.0",
    vx = new W(bx),
    wx = new Uint8Array(32);
wx.fill(0);
const W4 = new RegExp("^((.*)\\.)?([^.]+)$");

function Zu(t) {
    typeof t != "string" && vx.throwArgumentError("invalid ENS name; not a string", "name", t);
    let e = t,
        r = wx;
    for (; e.length;) {
        const n = e.match(W4);
        (n == null || n[2] === "") && vx.throwArgumentError("invalid ENS address; missing component", "name", t);
        const i = xi(cE(n[3]));
        r = Kt(Yo([r, Kt(i)])), e = n[2] || ""
    }
    return Jt(r)
}
var V4 = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Ct = new W(bx),
    Ex = new Uint8Array(32);
Ex.fill(0);
const K4 = We.from(-1),
    Ax = We.from(0),
    _x = We.from(1),
    X4 = We.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function J4(t) {
    const e = ro(t),
        r = e.length % 32;
    return r ? Es([e, Ex.slice(r)]) : Jt(e)
}
const Z4 = Qi(_x.toHexString(), 32),
    Y4 = Qi(Ax.toHexString(), 32),
    Tx = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
    },
    vh = ["name", "version", "chainId", "verifyingContract", "salt"];

function Mx(t) {
    return function(e) {
        return typeof e != "string" && Ct.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const Q4 = {
    name: Mx("name"),
    version: Mx("version"),
    chainId: function(t) {
        try {
            return We.from(t).toString()
        } catch {}
        return Ct.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t)
    },
    verifyingContract: function(t) {
        try {
            return nr(t).toLowerCase()
        } catch {}
        return Ct.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function(t) {
        try {
            const e = ro(t);
            if (e.length !== 32) throw new Error("bad length");
            return Jt(e)
        } catch {}
        return Ct.throwArgumentError('invalid domain value "salt"', "domain.salt", t)
    }
};

function wh(t) {
    {
        const e = t.match(/^(u?)int(\d*)$/);
        if (e) {
            const r = e[1] === "",
                n = parseInt(e[2] || "256");
            (n % 8 != 0 || n > 256 || e[2] && e[2] !== String(n)) && Ct.throwArgumentError("invalid numeric width", "type", t);
            const i = X4.mask(r ? n - 1 : n),
                s = r ? i.add(_x).mul(K4) : Ax;
            return function(o) {
                const f = We.from(o);
                return (f.lt(s) || f.gt(i)) && Ct.throwArgumentError(`value out-of-bounds for ${t}`, "value", o), Qi(f.toTwos(256).toHexString(), 32)
            }
        }
    } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
            const r = parseInt(e[1]);
            return (r === 0 || r > 32 || e[1] !== String(r)) && Ct.throwArgumentError("invalid bytes width", "type", t),
                function(n) {
                    return ro(n).length !== r && Ct.throwArgumentError(`invalid length for ${t}`, "value", n), J4(n)
                }
        }
    }
    switch (t) {
        case "address":
            return function(e) {
                return Qi(nr(e), 32)
            };
        case "bool":
            return function(e) {
                return e ? Z4 : Y4
            };
        case "bytes":
            return function(e) {
                return Kt(e)
            };
        case "string":
            return function(e) {
                return xx(e)
            }
    }
    return null
}

function Nx(t, e) {
    return `${t}(${e.map(({name:r,type:n})=>n+" "+r).join(",")})`
}
class Zr {
    constructor(e) {
        pe(this, "types", Object.freeze(Wi(e))), pe(this, "_encoderCache", {}), pe(this, "_types", {});
        const r = {},
            n = {},
            i = {};
        Object.keys(e).forEach(f => {
            r[f] = {}, n[f] = [], i[f] = {}
        });
        for (const f in e) {
            const l = {};
            e[f].forEach(d => {
                l[d.name] && Ct.throwArgumentError(`duplicate variable name ${JSON.stringify(d.name)} in ${JSON.stringify(f)}`, "types", e), l[d.name] = !0;
                const p = d.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                p === f && Ct.throwArgumentError(`circular type reference to ${JSON.stringify(p)}`, "types", e), !wh(p) && (n[p] || Ct.throwArgumentError(`unknown type ${JSON.stringify(p)}`, "types", e), n[p].push(f), r[f][p] = !0)
            })
        }
        const s = Object.keys(n).filter(f => n[f].length === 0);
        s.length === 0 ? Ct.throwArgumentError("missing primary type", "types", e) : s.length > 1 && Ct.throwArgumentError(`ambiguous primary types or unused types: ${s.map(f=>JSON.stringify(f)).join(", ")}`, "types", e), pe(this, "primaryType", s[0]);

        function o(f, l) {
            l[f] && Ct.throwArgumentError(`circular type reference to ${JSON.stringify(f)}`, "types", e), l[f] = !0, Object.keys(r[f]).forEach(d => {
                !n[d] || (o(d, l), Object.keys(l).forEach(p => {
                    i[p][d] = !0
                }))
            }), delete l[f]
        }
        o(this.primaryType, {});
        for (const f in i) {
            const l = Object.keys(i[f]);
            l.sort(), this._types[f] = Nx(f, e[f]) + l.map(d => Nx(d, e[d])).join("")
        }
    }
    getEncoder(e) {
        let r = this._encoderCache[e];
        return r || (r = this._encoderCache[e] = this._getEncoder(e)), r
    }
    _getEncoder(e) {
        {
            const i = wh(e);
            if (i) return i
        }
        const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (r) {
            const i = r[1],
                s = this.getEncoder(i),
                o = parseInt(r[3]);
            return f => {
                o >= 0 && f.length !== o && Ct.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", f);
                let l = f.map(s);
                return this._types[i] && (l = l.map(Kt)), Kt(Es(l))
            }
        }
        const n = this.types[e];
        if (n) {
            const i = xx(this._types[e]);
            return s => {
                const o = n.map(({
                    name: f,
                    type: l
                }) => {
                    const d = this.getEncoder(l)(s[f]);
                    return this._types[l] ? Kt(d) : d
                });
                return o.unshift(i), Es(o)
            }
        }
        return Ct.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const r = this._types[e];
        return r || Ct.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), r
    }
    encodeData(e, r) {
        return this.getEncoder(e)(r)
    }
    hashStruct(e, r) {
        return Kt(this.encodeData(e, r))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, r, n) {
        if (wh(e)) return n(e, r);
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (i) {
            const o = i[1],
                f = parseInt(i[3]);
            return f >= 0 && r.length !== f && Ct.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", r), r.map(l => this._visit(o, l, n))
        }
        const s = this.types[e];
        return s ? s.reduce((o, {
            name: f,
            type: l
        }) => (o[f] = this._visit(l, r[f], n), o), {}) : Ct.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    visit(e, r) {
        return this._visit(this.primaryType, e, r)
    }
    static from(e) {
        return new Zr(e)
    }
    static getPrimaryType(e) {
        return Zr.from(e).primaryType
    }
    static hashStruct(e, r, n) {
        return Zr.from(r).hashStruct(e, n)
    }
    static hashDomain(e) {
        const r = [];
        for (const n in e) {
            const i = Tx[n];
            i || Ct.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), r.push({
                name: n,
                type: i
            })
        }
        return r.sort((n, i) => vh.indexOf(n.name) - vh.indexOf(i.name)), Zr.hashStruct("EIP712Domain", {
            EIP712Domain: r
        }, e)
    }
    static encode(e, r, n) {
        return Es(["0x1901", Zr.hashDomain(e), Zr.from(r).hash(n)])
    }
    static hash(e, r, n) {
        return Kt(Zr.encode(e, r, n))
    }
    static resolveNames(e, r, n, i) {
        return V4(this, void 0, void 0, function*() {
            e = Yt(e);
            const s = {};
            e.verifyingContract && !Ht(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
            const o = Zr.from(r);
            o.visit(n, (f, l) => (f === "address" && !Ht(l, 20) && (s[l] = "0x"), l));
            for (const f in s) s[f] = yield i(f);
            return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), n = o.visit(n, (f, l) => f === "address" && s[l] ? s[l] : l), {
                domain: e,
                value: n
            }
        })
    }
    static getPayload(e, r, n) {
        Zr.hashDomain(e);
        const i = {},
            s = [];
        vh.forEach(l => {
            const d = e[l];
            d != null && (i[l] = Q4[l](d), s.push({
                name: l,
                type: Tx[l]
            }))
        });
        const o = Zr.from(r),
            f = Yt(r);
        return f.EIP712Domain ? Ct.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", r) : f.EIP712Domain = s, o.encode(n), {
            types: f,
            domain: i,
            primaryType: o.primaryType,
            message: o.visit(n, (l, d) => {
                if (l.match(/^bytes(\d*)/)) return Jt(ro(d));
                if (l.match(/^u?int/)) return We.from(d).toString();
                switch (l) {
                    case "address":
                        return d.toLowerCase();
                    case "bool":
                        return !!d;
                    case "string":
                        return typeof d != "string" && Ct.throwArgumentError("invalid string", "value", d), d
                }
                return Ct.throwArgumentError("unsupported type", "type", l)
            })
        }
    }
}
const e8 = "bytes/5.5.0",
    Eh = new W(e8);

function t8(t) {
    return !!t.toHexString
}

function Yu(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Yu(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function Sx(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function r8(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !Sx(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!Sx(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Px(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Eh.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Yu(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), t8(t) && (t = t.toHexString()), n8(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Eh.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Yu(new Uint8Array(n))
    }
    return r8(t) ? Yu(new Uint8Array(t)) : Eh.throwArgumentError("invalid arrayify value", "value", t)
}

function n8(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
class Ix {
    constructor(e) {
        pe(this, "alphabet", e), pe(this, "base", e.length), pe(this, "_alphabetMap", {}), pe(this, "_leader", e.charAt(0));
        for (let r = 0; r < e.length; r++) this._alphabetMap[e.charAt(r)] = r
    }
    encode(e) {
        let r = Px(e);
        if (r.length === 0) return "";
        let n = [0];
        for (let s = 0; s < r.length; ++s) {
            let o = r[s];
            for (let f = 0; f < n.length; ++f) o += n[f] << 8, n[f] = o % this.base, o = o / this.base | 0;
            for (; o > 0;) n.push(o % this.base), o = o / this.base | 0
        }
        let i = "";
        for (let s = 0; r[s] === 0 && s < r.length - 1; ++s) i += this._leader;
        for (let s = n.length - 1; s >= 0; --s) i += this.alphabet[n[s]];
        return i
    }
    decode(e) {
        if (typeof e != "string") throw new TypeError("Expected String");
        let r = [];
        if (e.length === 0) return new Uint8Array(r);
        r.push(0);
        for (let n = 0; n < e.length; n++) {
            let i = this._alphabetMap[e[n]];
            if (i === void 0) throw new Error("Non-base" + this.base + " character");
            let s = i;
            for (let o = 0; o < r.length; ++o) s += r[o] * this.base, r[o] = s & 255, s >>= 8;
            for (; s > 0;) r.push(s & 255), s >>= 8
        }
        for (let n = 0; e[n] === this._leader && n < e.length - 1; ++n) r.push(0);
        return Px(new Uint8Array(r.reverse()))
    }
}
new Ix("abcdefghijklmnopqrstuvwxyz234567");
const Rx = new Ix("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
    i8 = "bytes/5.5.0",
    Ah = new W(i8);

function s8(t) {
    return !!t.toHexString
}

function Qu(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return Qu(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function kx(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function o8(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !kx(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!kx(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function a8(t, e) {
    if (e || (e = {}), typeof t == "number") {
        Ah.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), Qu(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), s8(t) && (t = t.toHexString()), f8(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : Ah.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return Qu(new Uint8Array(n))
    }
    return o8(t) ? Qu(new Uint8Array(t)) : Ah.throwArgumentError("invalid arrayify value", "value", t)
}

function f8(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const u8 = "sha2/5.5.0";
new W(u8);

function Ox(t) {
    return "0x" + Qt.sha256().update(a8(t)).digest("hex")
}
var Cx = {
    exports: {}
};
(function(t, e) {
    (function(r) {
        function n(h) {
            return parseInt(h) === h
        }

        function i(h) {
            if (!n(h.length)) return !1;
            for (var u = 0; u < h.length; u++)
                if (!n(h[u]) || h[u] < 0 || h[u] > 255) return !1;
            return !0
        }

        function s(h, u) {
            if (h.buffer && ArrayBuffer.isView(h) && h.name === "Uint8Array") return u && (h.slice ? h = h.slice() : h = Array.prototype.slice.call(h)), h;
            if (Array.isArray(h)) {
                if (!i(h)) throw new Error("Array contains invalid value: " + h);
                return new Uint8Array(h)
            }
            if (n(h.length) && i(h)) return new Uint8Array(h);
            throw new Error("unsupported array-like object")
        }

        function o(h) {
            return new Uint8Array(h)
        }

        function f(h, u, _, L, E) {
            (L != null || E != null) && (h.slice ? h = h.slice(L, E) : h = Array.prototype.slice.call(h, L, E)), u.set(h, _)
        }
        var l = function() {
                function h(_) {
                    var L = [],
                        E = 0;
                    for (_ = encodeURI(_); E < _.length;) {
                        var R = _.charCodeAt(E++);
                        R === 37 ? (L.push(parseInt(_.substr(E, 2), 16)), E += 2) : L.push(R)
                    }
                    return s(L)
                }

                function u(_) {
                    for (var L = [], E = 0; E < _.length;) {
                        var R = _[E];
                        R < 128 ? (L.push(String.fromCharCode(R)), E++) : R > 191 && R < 224 ? (L.push(String.fromCharCode((R & 31) << 6 | _[E + 1] & 63)), E += 2) : (L.push(String.fromCharCode((R & 15) << 12 | (_[E + 1] & 63) << 6 | _[E + 2] & 63)), E += 3)
                    }
                    return L.join("")
                }
                return {
                    toBytes: h,
                    fromBytes: u
                }
            }(),
            d = function() {
                function h(L) {
                    for (var E = [], R = 0; R < L.length; R += 2) E.push(parseInt(L.substr(R, 2), 16));
                    return E
                }
                var u = "0123456789abcdef";

                function _(L) {
                    for (var E = [], R = 0; R < L.length; R++) {
                        var G = L[R];
                        E.push(u[(G & 240) >> 4] + u[G & 15])
                    }
                    return E.join("")
                }
                return {
                    toBytes: h,
                    fromBytes: _
                }
            }(),
            p = {
                16: 10,
                24: 12,
                32: 14
            },
            A = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
            T = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
            N = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
            P = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986],
            C = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766],
            S = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126],
            k = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436],
            I = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890],
            U = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935],
            M = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600],
            F = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480],
            D = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795],
            q = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855],
            V = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150],
            Q = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

        function ce(h) {
            for (var u = [], _ = 0; _ < h.length; _ += 4) u.push(h[_] << 24 | h[_ + 1] << 16 | h[_ + 2] << 8 | h[_ + 3]);
            return u
        }
        var O = function(h) {
            if (!(this instanceof O)) throw Error("AES must be instanitated with `new`");
            Object.defineProperty(this, "key", {
                value: s(h, !0)
            }), this._prepare()
        };
        O.prototype._prepare = function() {
            var h = p[this.key.length];
            if (h == null) throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
            this._Ke = [], this._Kd = [];
            for (var u = 0; u <= h; u++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
            for (var _ = (h + 1) * 4, L = this.key.length / 4, E = ce(this.key), R, u = 0; u < L; u++) R = u >> 2, this._Ke[R][u % 4] = E[u], this._Kd[h - R][u % 4] = E[u];
            for (var G = 0, z = L, j; z < _;) {
                if (j = E[L - 1], E[0] ^= T[j >> 16 & 255] << 24 ^ T[j >> 8 & 255] << 16 ^ T[j & 255] << 8 ^ T[j >> 24 & 255] ^ A[G] << 24, G += 1, L != 8)
                    for (var u = 1; u < L; u++) E[u] ^= E[u - 1];
                else {
                    for (var u = 1; u < L / 2; u++) E[u] ^= E[u - 1];
                    j = E[L / 2 - 1], E[L / 2] ^= T[j & 255] ^ T[j >> 8 & 255] << 8 ^ T[j >> 16 & 255] << 16 ^ T[j >> 24 & 255] << 24;
                    for (var u = L / 2 + 1; u < L; u++) E[u] ^= E[u - 1]
                }
                for (var u = 0, re, ee; u < L && z < _;) re = z >> 2, ee = z % 4, this._Ke[re][ee] = E[u], this._Kd[h - re][ee] = E[u++], z++
            }
            for (var re = 1; re < h; re++)
                for (var ee = 0; ee < 4; ee++) j = this._Kd[re][ee], this._Kd[re][ee] = D[j >> 24 & 255] ^ q[j >> 16 & 255] ^ V[j >> 8 & 255] ^ Q[j & 255]
        }, O.prototype.encrypt = function(h) {
            if (h.length != 16) throw new Error("invalid plaintext size (must be 16 bytes)");
            for (var u = this._Ke.length - 1, _ = [0, 0, 0, 0], L = ce(h), E = 0; E < 4; E++) L[E] ^= this._Ke[0][E];
            for (var R = 1; R < u; R++) {
                for (var E = 0; E < 4; E++) _[E] = P[L[E] >> 24 & 255] ^ C[L[(E + 1) % 4] >> 16 & 255] ^ S[L[(E + 2) % 4] >> 8 & 255] ^ k[L[(E + 3) % 4] & 255] ^ this._Ke[R][E];
                L = _.slice()
            }
            for (var G = o(16), z, E = 0; E < 4; E++) z = this._Ke[u][E], G[4 * E] = (T[L[E] >> 24 & 255] ^ z >> 24) & 255, G[4 * E + 1] = (T[L[(E + 1) % 4] >> 16 & 255] ^ z >> 16) & 255, G[4 * E + 2] = (T[L[(E + 2) % 4] >> 8 & 255] ^ z >> 8) & 255, G[4 * E + 3] = (T[L[(E + 3) % 4] & 255] ^ z) & 255;
            return G
        }, O.prototype.decrypt = function(h) {
            if (h.length != 16) throw new Error("invalid ciphertext size (must be 16 bytes)");
            for (var u = this._Kd.length - 1, _ = [0, 0, 0, 0], L = ce(h), E = 0; E < 4; E++) L[E] ^= this._Kd[0][E];
            for (var R = 1; R < u; R++) {
                for (var E = 0; E < 4; E++) _[E] = I[L[E] >> 24 & 255] ^ U[L[(E + 3) % 4] >> 16 & 255] ^ M[L[(E + 2) % 4] >> 8 & 255] ^ F[L[(E + 1) % 4] & 255] ^ this._Kd[R][E];
                L = _.slice()
            }
            for (var G = o(16), z, E = 0; E < 4; E++) z = this._Kd[u][E], G[4 * E] = (N[L[E] >> 24 & 255] ^ z >> 24) & 255, G[4 * E + 1] = (N[L[(E + 3) % 4] >> 16 & 255] ^ z >> 16) & 255, G[4 * E + 2] = (N[L[(E + 2) % 4] >> 8 & 255] ^ z >> 8) & 255, G[4 * E + 3] = (N[L[(E + 1) % 4] & 255] ^ z) & 255;
            return G
        };
        var w = function(h) {
            if (!(this instanceof w)) throw Error("AES must be instanitated with `new`");
            this.description = "Electronic Code Block", this.name = "ecb", this._aes = new O(h)
        };
        w.prototype.encrypt = function(h) {
            if (h = s(h), h.length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
            for (var u = o(h.length), _ = o(16), L = 0; L < h.length; L += 16) f(h, _, 0, L, L + 16), _ = this._aes.encrypt(_), f(_, u, L);
            return u
        }, w.prototype.decrypt = function(h) {
            if (h = s(h), h.length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
            for (var u = o(h.length), _ = o(16), L = 0; L < h.length; L += 16) f(h, _, 0, L, L + 16), _ = this._aes.decrypt(_), f(_, u, L);
            return u
        };
        var m = function(h, u) {
            if (!(this instanceof m)) throw Error("AES must be instanitated with `new`");
            if (this.description = "Cipher Block Chaining", this.name = "cbc", !u) u = o(16);
            else if (u.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)");
            this._lastCipherblock = s(u, !0), this._aes = new O(h)
        };
        m.prototype.encrypt = function(h) {
            if (h = s(h), h.length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
            for (var u = o(h.length), _ = o(16), L = 0; L < h.length; L += 16) {
                f(h, _, 0, L, L + 16);
                for (var E = 0; E < 16; E++) _[E] ^= this._lastCipherblock[E];
                this._lastCipherblock = this._aes.encrypt(_), f(this._lastCipherblock, u, L)
            }
            return u
        }, m.prototype.decrypt = function(h) {
            if (h = s(h), h.length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
            for (var u = o(h.length), _ = o(16), L = 0; L < h.length; L += 16) {
                f(h, _, 0, L, L + 16), _ = this._aes.decrypt(_);
                for (var E = 0; E < 16; E++) u[L + E] = _[E] ^ this._lastCipherblock[E];
                f(h, this._lastCipherblock, 0, L, L + 16)
            }
            return u
        };
        var a = function(h, u, _) {
            if (!(this instanceof a)) throw Error("AES must be instanitated with `new`");
            if (this.description = "Cipher Feedback", this.name = "cfb", !u) u = o(16);
            else if (u.length != 16) throw new Error("invalid initialation vector size (must be 16 size)");
            _ || (_ = 1), this.segmentSize = _, this._shiftRegister = s(u, !0), this._aes = new O(h)
        };
        a.prototype.encrypt = function(h) {
            if (h.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)");
            for (var u = s(h, !0), _, L = 0; L < u.length; L += this.segmentSize) {
                _ = this._aes.encrypt(this._shiftRegister);
                for (var E = 0; E < this.segmentSize; E++) u[L + E] ^= _[E];
                f(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), f(u, this._shiftRegister, 16 - this.segmentSize, L, L + this.segmentSize)
            }
            return u
        }, a.prototype.decrypt = function(h) {
            if (h.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)");
            for (var u = s(h, !0), _, L = 0; L < u.length; L += this.segmentSize) {
                _ = this._aes.encrypt(this._shiftRegister);
                for (var E = 0; E < this.segmentSize; E++) u[L + E] ^= _[E];
                f(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), f(h, this._shiftRegister, 16 - this.segmentSize, L, L + this.segmentSize)
            }
            return u
        };
        var c = function(h, u) {
            if (!(this instanceof c)) throw Error("AES must be instanitated with `new`");
            if (this.description = "Output Feedback", this.name = "ofb", !u) u = o(16);
            else if (u.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)");
            this._lastPrecipher = s(u, !0), this._lastPrecipherIndex = 16, this._aes = new O(h)
        };
        c.prototype.encrypt = function(h) {
            for (var u = s(h, !0), _ = 0; _ < u.length; _++) this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), u[_] ^= this._lastPrecipher[this._lastPrecipherIndex++];
            return u
        }, c.prototype.decrypt = c.prototype.encrypt;
        var g = function(h) {
            if (!(this instanceof g)) throw Error("Counter must be instanitated with `new`");
            h !== 0 && !h && (h = 1), typeof h == "number" ? (this._counter = o(16), this.setValue(h)) : this.setBytes(h)
        };
        g.prototype.setValue = function(h) {
            if (typeof h != "number" || parseInt(h) != h) throw new Error("invalid counter value (must be an integer)");
            for (var u = 15; u >= 0; --u) this._counter[u] = h % 256, h = h >> 8
        }, g.prototype.setBytes = function(h) {
            if (h = s(h, !0), h.length != 16) throw new Error("invalid counter bytes size (must be 16 bytes)");
            this._counter = h
        }, g.prototype.increment = function() {
            for (var h = 15; h >= 0; h--)
                if (this._counter[h] === 255) this._counter[h] = 0;
                else {
                    this._counter[h]++;
                    break
                }
        };
        var v = function(h, u) {
            if (!(this instanceof v)) throw Error("AES must be instanitated with `new`");
            this.description = "Counter", this.name = "ctr", u instanceof g || (u = new g(u)), this._counter = u, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new O(h)
        };
        v.prototype.encrypt = function(h) {
            for (var u = s(h, !0), _ = 0; _ < u.length; _++) this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), u[_] ^= this._remainingCounter[this._remainingCounterIndex++];
            return u
        }, v.prototype.decrypt = v.prototype.encrypt;

        function x(h) {
            h = s(h, !0);
            var u = 16 - h.length % 16,
                _ = o(h.length + u);
            f(h, _);
            for (var L = h.length; L < _.length; L++) _[L] = u;
            return _
        }

        function b(h) {
            if (h = s(h, !0), h.length < 16) throw new Error("PKCS#7 invalid length");
            var u = h[h.length - 1];
            if (u > 16) throw new Error("PKCS#7 padding byte out of range");
            for (var _ = h.length - u, L = 0; L < u; L++)
                if (h[_ + L] !== u) throw new Error("PKCS#7 invalid padding byte");
            var E = o(_);
            return f(h, E, 0, 0, _), E
        }
        var y = {
            AES: O,
            Counter: g,
            ModeOfOperation: {
                ecb: w,
                cbc: m,
                cfb: a,
                ofb: c,
                ctr: v
            },
            utils: {
                hex: d,
                utf8: l
            },
            padding: {
                pkcs7: {
                    pad: x,
                    strip: b
                }
            },
            _arrayTest: {
                coerceArray: s,
                createArray: o,
                copyArray: f
            }
        };
        t.exports = y
    })()
})(Cx);
var DS = Cx.exports,
    Fx = {
        exports: {}
    };
(function(t, e) {
    (function(r) {
        const n = 2147483647;

        function i(C) {
            const S = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
            let k = 1779033703,
                I = 3144134277,
                U = 1013904242,
                M = 2773480762,
                F = 1359893119,
                D = 2600822924,
                q = 528734635,
                V = 1541459225;
            const Q = new Uint32Array(64);

            function ce(v) {
                let x = 0,
                    b = v.length;
                for (; b >= 64;) {
                    let y = k,
                        h = I,
                        u = U,
                        _ = M,
                        L = F,
                        E = D,
                        R = q,
                        G = V,
                        z, j, re, ee, K;
                    for (j = 0; j < 16; j++) re = x + j * 4, Q[j] = (v[re] & 255) << 24 | (v[re + 1] & 255) << 16 | (v[re + 2] & 255) << 8 | v[re + 3] & 255;
                    for (j = 16; j < 64; j++) z = Q[j - 2], ee = (z >>> 17 | z << 32 - 17) ^ (z >>> 19 | z << 32 - 19) ^ z >>> 10, z = Q[j - 15], K = (z >>> 7 | z << 32 - 7) ^ (z >>> 18 | z << 32 - 18) ^ z >>> 3, Q[j] = (ee + Q[j - 7] | 0) + (K + Q[j - 16] | 0) | 0;
                    for (j = 0; j < 64; j++) ee = (((L >>> 6 | L << 32 - 6) ^ (L >>> 11 | L << 32 - 11) ^ (L >>> 25 | L << 32 - 25)) + (L & E ^ ~L & R) | 0) + (G + (S[j] + Q[j] | 0) | 0) | 0, K = ((y >>> 2 | y << 32 - 2) ^ (y >>> 13 | y << 32 - 13) ^ (y >>> 22 | y << 32 - 22)) + (y & h ^ y & u ^ h & u) | 0, G = R, R = E, E = L, L = _ + ee | 0, _ = u, u = h, h = y, y = ee + K | 0;
                    k = k + y | 0, I = I + h | 0, U = U + u | 0, M = M + _ | 0, F = F + L | 0, D = D + E | 0, q = q + R | 0, V = V + G | 0, x += 64, b -= 64
                }
            }
            ce(C);
            let O, w = C.length % 64,
                m = C.length / 536870912 | 0,
                a = C.length << 3,
                c = w < 56 ? 56 : 120,
                g = C.slice(C.length - w, C.length);
            for (g.push(128), O = w + 1; O < c; O++) g.push(0);
            return g.push(m >>> 24 & 255), g.push(m >>> 16 & 255), g.push(m >>> 8 & 255), g.push(m >>> 0 & 255), g.push(a >>> 24 & 255), g.push(a >>> 16 & 255), g.push(a >>> 8 & 255), g.push(a >>> 0 & 255), ce(g), [k >>> 24 & 255, k >>> 16 & 255, k >>> 8 & 255, k >>> 0 & 255, I >>> 24 & 255, I >>> 16 & 255, I >>> 8 & 255, I >>> 0 & 255, U >>> 24 & 255, U >>> 16 & 255, U >>> 8 & 255, U >>> 0 & 255, M >>> 24 & 255, M >>> 16 & 255, M >>> 8 & 255, M >>> 0 & 255, F >>> 24 & 255, F >>> 16 & 255, F >>> 8 & 255, F >>> 0 & 255, D >>> 24 & 255, D >>> 16 & 255, D >>> 8 & 255, D >>> 0 & 255, q >>> 24 & 255, q >>> 16 & 255, q >>> 8 & 255, q >>> 0 & 255, V >>> 24 & 255, V >>> 16 & 255, V >>> 8 & 255, V >>> 0 & 255]
        }

        function s(C, S, k) {
            C = C.length <= 64 ? C : i(C);
            const I = 64 + S.length + 4,
                U = new Array(I),
                M = new Array(64);
            let F, D = [];
            for (F = 0; F < 64; F++) U[F] = 54;
            for (F = 0; F < C.length; F++) U[F] ^= C[F];
            for (F = 0; F < S.length; F++) U[64 + F] = S[F];
            for (F = I - 4; F < I; F++) U[F] = 0;
            for (F = 0; F < 64; F++) M[F] = 92;
            for (F = 0; F < C.length; F++) M[F] ^= C[F];

            function q() {
                for (let V = I - 1; V >= I - 4; V--) {
                    if (U[V]++, U[V] <= 255) return;
                    U[V] = 0
                }
            }
            for (; k >= 32;) q(), D = D.concat(i(M.concat(i(U)))), k -= 32;
            return k > 0 && (q(), D = D.concat(i(M.concat(i(U))).slice(0, k))), D
        }

        function o(C, S, k, I, U) {
            let M;
            for (p(C, (2 * k - 1) * 16, U, 0, 16), M = 0; M < 2 * k; M++) d(C, M * 16, U, 16), l(U, I), p(U, 0, C, S + M * 16, 16);
            for (M = 0; M < k; M++) p(C, S + M * 2 * 16, C, M * 16, 16);
            for (M = 0; M < k; M++) p(C, S + (M * 2 + 1) * 16, C, (M + k) * 16, 16)
        }

        function f(C, S) {
            return C << S | C >>> 32 - S
        }

        function l(C, S) {
            p(C, 0, S, 0, 16);
            for (let k = 8; k > 0; k -= 2) S[4] ^= f(S[0] + S[12], 7), S[8] ^= f(S[4] + S[0], 9), S[12] ^= f(S[8] + S[4], 13), S[0] ^= f(S[12] + S[8], 18), S[9] ^= f(S[5] + S[1], 7), S[13] ^= f(S[9] + S[5], 9), S[1] ^= f(S[13] + S[9], 13), S[5] ^= f(S[1] + S[13], 18), S[14] ^= f(S[10] + S[6], 7), S[2] ^= f(S[14] + S[10], 9), S[6] ^= f(S[2] + S[14], 13), S[10] ^= f(S[6] + S[2], 18), S[3] ^= f(S[15] + S[11], 7), S[7] ^= f(S[3] + S[15], 9), S[11] ^= f(S[7] + S[3], 13), S[15] ^= f(S[11] + S[7], 18), S[1] ^= f(S[0] + S[3], 7), S[2] ^= f(S[1] + S[0], 9), S[3] ^= f(S[2] + S[1], 13), S[0] ^= f(S[3] + S[2], 18), S[6] ^= f(S[5] + S[4], 7), S[7] ^= f(S[6] + S[5], 9), S[4] ^= f(S[7] + S[6], 13), S[5] ^= f(S[4] + S[7], 18), S[11] ^= f(S[10] + S[9], 7), S[8] ^= f(S[11] + S[10], 9), S[9] ^= f(S[8] + S[11], 13), S[10] ^= f(S[9] + S[8], 18), S[12] ^= f(S[15] + S[14], 7), S[13] ^= f(S[12] + S[15], 9), S[14] ^= f(S[13] + S[12], 13), S[15] ^= f(S[14] + S[13], 18);
            for (let k = 0; k < 16; ++k) C[k] += S[k]
        }

        function d(C, S, k, I) {
            for (let U = 0; U < I; U++) k[U] ^= C[S + U]
        }

        function p(C, S, k, I, U) {
            for (; U--;) k[I++] = C[S++]
        }

        function A(C) {
            if (!C || typeof C.length != "number") return !1;
            for (let S = 0; S < C.length; S++) {
                const k = C[S];
                if (typeof k != "number" || k % 1 || k < 0 || k >= 256) return !1
            }
            return !0
        }

        function T(C, S) {
            if (typeof C != "number" || C % 1) throw new Error("invalid " + S);
            return C
        }

        function N(C, S, k, I, U, M, F) {
            if (k = T(k, "N"), I = T(I, "r"), U = T(U, "p"), M = T(M, "dkLen"), k === 0 || (k & k - 1) != 0) throw new Error("N must be power of 2");
            if (k > n / 128 / I) throw new Error("N too large");
            if (I > n / 128 / U) throw new Error("r too large");
            if (!A(C)) throw new Error("password must be an array or buffer");
            if (C = Array.prototype.slice.call(C), !A(S)) throw new Error("salt must be an array or buffer");
            S = Array.prototype.slice.call(S);
            let D = s(C, S, U * 128 * I);
            const q = new Uint32Array(U * 32 * I);
            for (let L = 0; L < q.length; L++) {
                const E = L * 4;
                q[L] = (D[E + 3] & 255) << 24 | (D[E + 2] & 255) << 16 | (D[E + 1] & 255) << 8 | (D[E + 0] & 255) << 0
            }
            const V = new Uint32Array(64 * I),
                Q = new Uint32Array(32 * I * k),
                ce = 32 * I,
                O = new Uint32Array(16),
                w = new Uint32Array(16),
                m = U * k * 2;
            let a = 0,
                c = null,
                g = !1,
                v = 0,
                x = 0,
                b, y;
            const h = F ? parseInt(1e3 / I) : 4294967295,
                u = typeof setImmediate != "undefined" ? setImmediate : setTimeout,
                _ = function() {
                    if (g) return F(new Error("cancelled"), a / m);
                    let L;
                    switch (v) {
                        case 0:
                            y = x * 32 * I, p(q, y, V, 0, ce), v = 1, b = 0;
                        case 1:
                            L = k - b, L > h && (L = h);
                            for (let R = 0; R < L; R++) p(V, 0, Q, (b + R) * ce, ce), o(V, ce, I, O, w);
                            if (b += L, a += L, F) {
                                const R = parseInt(1e3 * a / m);
                                if (R !== c) {
                                    if (g = F(null, a / m), g) break;
                                    c = R
                                }
                            }
                            if (b < k) break;
                            b = 0, v = 2;
                        case 2:
                            L = k - b, L > h && (L = h);
                            for (let R = 0; R < L; R++) {
                                const G = (2 * I - 1) * 16,
                                    z = V[G] & k - 1;
                                d(Q, z * ce, V, ce), o(V, ce, I, O, w)
                            }
                            if (b += L, a += L, F) {
                                const R = parseInt(1e3 * a / m);
                                if (R !== c) {
                                    if (g = F(null, a / m), g) break;
                                    c = R
                                }
                            }
                            if (b < k) break;
                            if (p(V, 0, q, y, ce), x++, x < U) {
                                v = 0;
                                break
                            }
                            D = [];
                            for (let R = 0; R < q.length; R++) D.push(q[R] >> 0 & 255), D.push(q[R] >> 8 & 255), D.push(q[R] >> 16 & 255), D.push(q[R] >> 24 & 255);
                            const E = s(C, D, M);
                            return F && F(null, 1, E), E
                    }
                    F && u(_)
                };
            if (!F)
                for (;;) {
                    const L = _();
                    if (L != null) return L
                }
            _()
        }
        const P = {
            scrypt: function(C, S, k, I, U, M, F) {
                return new Promise(function(D, q) {
                    let V = 0;
                    F && F(0), N(C, S, k, I, U, M, function(Q, ce, O) {
                        if (Q) q(Q);
                        else if (O) F && V !== 1 && F(1), D(new Uint8Array(O));
                        else if (F && ce !== V) return V = ce, F(ce)
                    })
                })
            },
            syncScrypt: function(C, S, k, I, U, M) {
                return new Uint8Array(N(C, S, k, I, U, M))
            }
        };
        t.exports = P
    })()
})(Fx);
var US = Fx.exports;
const l8 = "networks/5.5.1",
    Dx = new W(l8);

function c8(t) {
    return t && typeof t.renetwork == "function"
}

function Qo(t) {
    const e = function(r, n) {
        n == null && (n = {});
        const i = [];
        if (r.InfuraProvider) try {
            i.push(new r.InfuraProvider(t, n.infura))
        } catch {}
        if (r.EtherscanProvider) try {
            i.push(new r.EtherscanProvider(t, n.etherscan))
        } catch {}
        if (r.AlchemyProvider) try {
            i.push(new r.AlchemyProvider(t, n.alchemy))
        } catch {}
        if (r.PocketProvider) {
            const s = ["goerli", "ropsten", "rinkeby"];
            try {
                const o = new r.PocketProvider(t);
                o.network && s.indexOf(o.network.name) === -1 && i.push(o)
            } catch {}
        }
        if (r.CloudflareProvider) try {
            i.push(new r.CloudflareProvider(t))
        } catch {}
        if (i.length === 0) return null;
        if (r.FallbackProvider) {
            let s = 1;
            return n.quorum != null ? s = n.quorum : t === "homestead" && (s = 2), new r.FallbackProvider(i, s)
        }
        return i[0]
    };
    return e.renetwork = function(r) {
        return Qo(r)
    }, e
}

function el(t, e) {
    const r = function(n, i) {
        return n.JsonRpcProvider ? new n.JsonRpcProvider(t, e) : null
    };
    return r.renetwork = function(n) {
        return el(t, n)
    }, r
}
const Ux = {
        chainId: 1,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "homestead",
        _defaultProvider: Qo("homestead")
    },
    Lx = {
        chainId: 3,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "ropsten",
        _defaultProvider: Qo("ropsten")
    },
    Bx = {
        chainId: 63,
        name: "classicMordor",
        _defaultProvider: el("https://www.ethercluster.com/mordor", "classicMordor")
    },
    tl = {
        unspecified: {
            chainId: 0,
            name: "unspecified"
        },
        homestead: Ux,
        mainnet: Ux,
        morden: {
            chainId: 2,
            name: "morden"
        },
        ropsten: Lx,
        testnet: Lx,
        rinkeby: {
            chainId: 4,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "rinkeby",
            _defaultProvider: Qo("rinkeby")
        },
        kovan: {
            chainId: 42,
            name: "kovan",
            _defaultProvider: Qo("kovan")
        },
        goerli: {
            chainId: 5,
            ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
            name: "goerli",
            _defaultProvider: Qo("goerli")
        },
        classic: {
            chainId: 61,
            name: "classic",
            _defaultProvider: el("https://www.ethercluster.com/etc", "classic")
        },
        classicMorden: {
            chainId: 62,
            name: "classicMorden"
        },
        classicMordor: Bx,
        classicTestnet: Bx,
        classicKotti: {
            chainId: 6,
            name: "classicKotti",
            _defaultProvider: el("https://www.ethercluster.com/kotti", "classicKotti")
        },
        xdai: {
            chainId: 100,
            name: "xdai"
        },
        matic: {
            chainId: 137,
            name: "matic"
        },
        maticmum: {
            chainId: 80001,
            name: "maticmum"
        },
        optimism: {
            chainId: 10,
            name: "optimism"
        },
        "optimism-kovan": {
            chainId: 69,
            name: "optimism-kovan"
        },
        "optimism-goerli": {
            chainId: 420,
            name: "optimism-goerli"
        },
        arbitrum: {
            chainId: 42161,
            name: "arbitrum"
        },
        "arbitrum-rinkeby": {
            chainId: 421611,
            name: "arbitrum-rinkeby"
        },
        bnb: {
            chainId: 56,
            name: "bnb"
        },
        bnbt: {
            chainId: 97,
            name: "bnbt"
        }
    };

function h8(t) {
    if (t == null) return null;
    if (typeof t == "number") {
        for (const n in tl) {
            const i = tl[n];
            if (i.chainId === t) return {
                name: i.name,
                chainId: i.chainId,
                ensAddress: i.ensAddress || null,
                _defaultProvider: i._defaultProvider || null
            }
        }
        return {
            chainId: t,
            name: "unknown"
        }
    }
    if (typeof t == "string") {
        const n = tl[t];
        return n == null ? null : {
            name: n.name,
            chainId: n.chainId,
            ensAddress: n.ensAddress,
            _defaultProvider: n._defaultProvider || null
        }
    }
    const e = tl[t.name];
    if (!e) return typeof t.chainId != "number" && Dx.throwArgumentError("invalid network chainId", "network", t), t;
    t.chainId !== 0 && t.chainId !== e.chainId && Dx.throwArgumentError("network chainId mismatch", "network", t);
    let r = t._defaultProvider || null;
    return r == null && e._defaultProvider && (c8(e._defaultProvider) ? r = e._defaultProvider.renetwork(t) : r = e._defaultProvider), {
        name: t.name,
        chainId: e.chainId,
        ensAddress: t.ensAddress || e.ensAddress || null,
        _defaultProvider: r
    }
}
const d8 = "bytes/5.5.0",
    ea = new W(d8);

function $x(t) {
    return !!t.toHexString
}

function rl(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return rl(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function p8(t) {
    return Mh(t) && !(t.length % 2) || _h(t)
}

function Gx(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function _h(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !Gx(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!Gx(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function Th(t, e) {
    if (e || (e = {}), typeof t == "number") {
        ea.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), rl(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), $x(t) && (t = t.toHexString()), Mh(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0x0" + r.substring(2) : e.hexPad === "right" ? r += "0" : ea.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return rl(new Uint8Array(n))
    }
    return _h(t) ? rl(new Uint8Array(t)) : ea.throwArgumentError("invalid arrayify value", "value", t)
}

function Mh(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const Nh = "0123456789abcdef";

function m8(t, e) {
    if (e || (e = {}), typeof t == "number") {
        ea.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = Nh[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), $x(t)) return t.toHexString();
    if (Mh(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : ea.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (_h(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += Nh[(i & 240) >> 4] + Nh[i & 15]
        }
        return r
    }
    return ea.throwArgumentError("invalid hexlify value", "value", t)
}

function y8(t) {
    t = atob(t);
    const e = [];
    for (let r = 0; r < t.length; r++) e.push(t.charCodeAt(r));
    return Th(e)
}

function g8(t) {
    t = Th(t);
    let e = "";
    for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
    return btoa(e)
}
const x8 = "web/5.5.1";
var b8 = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};

function v8(t, e) {
    return b8(this, void 0, void 0, function*() {
        e == null && (e = {});
        const r = {
            method: e.method || "GET",
            headers: e.headers || {},
            body: e.body || void 0
        };
        e.skipFetchSetup !== !0 && (r.mode = "cors", r.cache = "no-cache", r.credentials = "same-origin", r.redirect = "follow", r.referrer = "client");
        const n = yield fetch(t, r), i = yield n.arrayBuffer(), s = {};
        return n.headers.forEach ? n.headers.forEach((o, f) => {
            s[f.toLowerCase()] = o
        }) : n.headers.keys().forEach(o => {
            s[o.toLowerCase()] = n.headers.get(o)
        }), {
            headers: s,
            statusCode: n.status,
            statusMessage: n.statusText,
            body: Th(new Uint8Array(i))
        }
    })
}
var w8 = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Xn = new W(x8);

function zx(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}

function As(t, e) {
    if (t == null) return null;
    if (typeof t == "string") return t;
    if (p8(t)) {
        if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json")) try {
            return zo(t)
        } catch {}
        return m8(t)
    }
    return t
}

function E8(t, e, r) {
    const n = typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12;
    Xn.assertArgument(n > 0 && n % 1 == 0, "invalid connection throttle limit", "connection.throttleLimit", n);
    const i = typeof t == "object" ? t.throttleCallback : null,
        s = typeof t == "object" && typeof t.throttleSlotInterval == "number" ? t.throttleSlotInterval : 100;
    Xn.assertArgument(s > 0 && s % 1 == 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
    const o = {};
    let f = null;
    const l = {
        method: "GET"
    };
    let d = !1,
        p = 2 * 60 * 1e3;
    if (typeof t == "string") f = t;
    else if (typeof t == "object") {
        if ((t == null || t.url == null) && Xn.throwArgumentError("missing URL", "connection.url", t), f = t.url, typeof t.timeout == "number" && t.timeout > 0 && (p = t.timeout), t.headers)
            for (const S in t.headers) o[S.toLowerCase()] = {
                key: S,
                value: String(t.headers[S])
            }, ["if-none-match", "if-modified-since"].indexOf(S.toLowerCase()) >= 0 && (d = !0);
        if (l.allowGzip = !!t.allowGzip, t.user != null && t.password != null) {
            f.substring(0, 6) !== "https:" && t.allowInsecureAuthentication !== !0 && Xn.throwError("basic authentication requires a secure https url", W.errors.INVALID_ARGUMENT, {
                argument: "url",
                url: f,
                user: t.user,
                password: "[REDACTED]"
            });
            const S = t.user + ":" + t.password;
            o.authorization = {
                key: "Authorization",
                value: "Basic " + g8(xi(S))
            }
        }
    }
    const A = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
        T = f ? f.match(A) : null;
    if (T) try {
        const S = {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
                "content-type": T[1]
            },
            body: y8(T[2])
        };
        let k = S.body;
        return r && (k = r(S.body, S)), Promise.resolve(k)
    } catch (S) {
        Xn.throwError("processing response error", W.errors.SERVER_ERROR, {
            body: As(T[1], T[2]),
            error: S,
            requestBody: null,
            requestMethod: "GET",
            url: f
        })
    }
    e && (l.method = "POST", l.body = e, o["content-type"] == null && (o["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
    }), o["content-length"] == null && (o["content-length"] = {
        key: "Content-Length",
        value: String(e.length)
    }));
    const N = {};
    Object.keys(o).forEach(S => {
        const k = o[S];
        N[k.key] = k.value
    }), l.headers = N;
    const P = function() {
            let S = null;
            return {
                promise: new Promise(function(U, M) {
                    p && (S = setTimeout(() => {
                        S != null && (S = null, M(Xn.makeError("timeout", W.errors.TIMEOUT, {
                            requestBody: As(l.body, N["content-type"]),
                            requestMethod: l.method,
                            timeout: p,
                            url: f
                        })))
                    }, p))
                }),
                cancel: function() {
                    S != null && (clearTimeout(S), S = null)
                }
            }
        }(),
        C = function() {
            return w8(this, void 0, void 0, function*() {
                for (let S = 0; S < n; S++) {
                    let k = null;
                    try {
                        if (k = yield v8(f, l), S < n) {
                            if (k.statusCode === 301 || k.statusCode === 302) {
                                const U = k.headers.location || "";
                                if (l.method === "GET" && U.match(/^https:/)) {
                                    f = k.headers.location;
                                    continue
                                }
                            } else if (k.statusCode === 429) {
                                let U = !0;
                                if (i && (U = yield i(S, f)), U) {
                                    let M = 0;
                                    const F = k.headers["retry-after"];
                                    typeof F == "string" && F.match(/^[1-9][0-9]*$/) ? M = parseInt(F) * 1e3 : M = s * parseInt(String(Math.random() * Math.pow(2, S))), yield zx(M);
                                    continue
                                }
                            }
                        }
                    } catch (U) {
                        k = U.response, k == null && (P.cancel(), Xn.throwError("missing response", W.errors.SERVER_ERROR, {
                            requestBody: As(l.body, N["content-type"]),
                            requestMethod: l.method,
                            serverError: U,
                            url: f
                        }))
                    }
                    let I = k.body;
                    if (d && k.statusCode === 304 ? I = null : (k.statusCode < 200 || k.statusCode >= 300) && (P.cancel(), Xn.throwError("bad response", W.errors.SERVER_ERROR, {
                            status: k.statusCode,
                            headers: k.headers,
                            body: As(I, k.headers ? k.headers["content-type"] : null),
                            requestBody: As(l.body, N["content-type"]),
                            requestMethod: l.method,
                            url: f
                        })), r) try {
                        const U = yield r(I, k);
                        return P.cancel(), U
                    } catch (U) {
                        if (U.throttleRetry && S < n) {
                            let M = !0;
                            if (i && (M = yield i(S, f)), M) {
                                const F = s * parseInt(String(Math.random() * Math.pow(2, S)));
                                yield zx(F);
                                continue
                            }
                        }
                        P.cancel(), Xn.throwError("processing response error", W.errors.SERVER_ERROR, {
                            body: As(I, k.headers ? k.headers["content-type"] : null),
                            error: U,
                            requestBody: As(l.body, N["content-type"]),
                            requestMethod: l.method,
                            url: f
                        })
                    }
                    return P.cancel(), I
                }
                return Xn.throwError("failed response", W.errors.SERVER_ERROR, {
                    requestBody: As(l.body, N["content-type"]),
                    requestMethod: l.method,
                    url: f
                })
            })
        }();
    return Promise.race([P.promise, C])
}

function Hx(t, e, r) {
    let n = (s, o) => {
            let f = null;
            if (s != null) try {
                f = JSON.parse(zo(s))
            } catch (l) {
                Xn.throwError("invalid JSON", W.errors.SERVER_ERROR, {
                    body: s,
                    error: l
                })
            }
            return r && (f = r(f, o)), f
        },
        i = null;
    if (e != null) {
        i = xi(e);
        const s = typeof t == "string" ? {
            url: t
        } : Yt(t);
        s.headers ? Object.keys(s.headers).filter(f => f.toLowerCase() === "content-type").length !== 0 || (s.headers = Yt(s.headers), s.headers["content-type"] = "application/json") : s.headers = {
            "content-type": "application/json"
        }, t = s
    }
    return E8(t, i, n)
}

function of (t, e) {
    return e || (e = {}), e = Yt(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(r, n) {
        let i = null,
            s = !1;
        const o = () => s ? !1 : (s = !0, i && clearTimeout(i), !0);
        e.timeout && (i = setTimeout(() => {
            o() && n(new Error("timeout"))
        }, e.timeout));
        const f = e.retryLimit;
        let l = 0;

        function d() {
            return t().then(function(p) {
                if (p !== void 0) o() && r(p);
                else if (e.oncePoll) e.oncePoll.once("poll", d);
                else if (e.onceBlock) e.onceBlock.once("block", d);
                else if (!s) {
                    if (l++, l > f) {
                        o() && n(new Error("retry limit reached"));
                        return
                    }
                    let A = e.interval * parseInt(String(Math.random() * Math.pow(2, l)));
                    A < e.floor && (A = e.floor), A > e.ceiling && (A = e.ceiling), setTimeout(d, A)
                }
                return null
            }, function(p) {
                o() && n(p)
            })
        }
        d()
    })
}
var nl = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
    Sh = {};
for (var il = 0; il < nl.length; il++) {
    var Ph = nl.charAt(il);
    if (Sh[Ph] !== void 0) throw new TypeError(Ph + " is ambiguous");
    Sh[Ph] = il
}

function ta(t) {
    var e = t >> 25;
    return (t & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059
}

function qx(t) {
    for (var e = 1, r = 0; r < t.length; ++r) {
        var n = t.charCodeAt(r);
        if (n < 33 || n > 126) return "Invalid prefix (" + t + ")";
        e = ta(e) ^ n >> 5
    }
    for (e = ta(e), r = 0; r < t.length; ++r) {
        var i = t.charCodeAt(r);
        e = ta(e) ^ i & 31
    }
    return e
}

function A8(t, e, r) {
    if (r = r || 90, t.length + 7 + e.length > r) throw new TypeError("Exceeds length limit");
    t = t.toLowerCase();
    var n = qx(t);
    if (typeof n == "string") throw new Error(n);
    for (var i = t + "1", s = 0; s < e.length; ++s) {
        var o = e[s];
        if (o >> 5 != 0) throw new Error("Non 5-bit word");
        n = ta(n) ^ o, i += nl.charAt(o)
    }
    for (s = 0; s < 6; ++s) n = ta(n);
    for (n ^= 1, s = 0; s < 6; ++s) {
        var f = n >> (5 - s) * 5 & 31;
        i += nl.charAt(f)
    }
    return i
}

function jx(t, e) {
    if (e = e || 90, t.length < 8) return t + " too short";
    if (t.length > e) return "Exceeds length limit";
    var r = t.toLowerCase(),
        n = t.toUpperCase();
    if (t !== r && t !== n) return "Mixed-case string " + t;
    t = r;
    var i = t.lastIndexOf("1");
    if (i === -1) return "No separator character for " + t;
    if (i === 0) return "Missing prefix for " + t;
    var s = t.slice(0, i),
        o = t.slice(i + 1);
    if (o.length < 6) return "Data too short";
    var f = qx(s);
    if (typeof f == "string") return f;
    for (var l = [], d = 0; d < o.length; ++d) {
        var p = o.charAt(d),
            A = Sh[p];
        if (A === void 0) return "Unknown character " + p;
        f = ta(f) ^ A, !(d + 6 >= o.length) && l.push(A)
    }
    return f !== 1 ? "Invalid checksum for " + t : {
        prefix: s,
        words: l
    }
}

function _8() {
    var t = jx.apply(null, arguments);
    if (typeof t == "object") return t
}

function T8(t) {
    var e = jx.apply(null, arguments);
    if (typeof e == "object") return e;
    throw new Error(e)
}

function sl(t, e, r, n) {
    for (var i = 0, s = 0, o = (1 << r) - 1, f = [], l = 0; l < t.length; ++l)
        for (i = i << e | t[l], s += e; s >= r;) s -= r, f.push(i >> s & o);
    if (n) s > 0 && f.push(i << r - s & o);
    else {
        if (s >= e) return "Excess padding";
        if (i << r - s & o) return "Non-zero padding"
    }
    return f
}

function M8(t) {
    var e = sl(t, 8, 5, !0);
    if (Array.isArray(e)) return e
}

function N8(t) {
    var e = sl(t, 8, 5, !0);
    if (Array.isArray(e)) return e;
    throw new Error(e)
}

function S8(t) {
    var e = sl(t, 5, 8, !1);
    if (Array.isArray(e)) return e
}

function P8(t) {
    var e = sl(t, 5, 8, !1);
    if (Array.isArray(e)) return e;
    throw new Error(e)
}
var Wx = {
    decodeUnsafe: _8,
    decode: T8,
    encode: A8,
    toWordsUnsafe: M8,
    toWords: N8,
    fromWordsUnsafe: S8,
    fromWords: P8
};
const ol = "providers/5.5.1",
    ra = new W(ol);
class Se {
    constructor() {
        ra.checkNew(new.target, Se), this.formats = this.getDefaultFormats()
    }
    getDefaultFormats() {
        const e = {},
            r = this.address.bind(this),
            n = this.bigNumber.bind(this),
            i = this.blockTag.bind(this),
            s = this.data.bind(this),
            o = this.hash.bind(this),
            f = this.hex.bind(this),
            l = this.number.bind(this),
            d = this.type.bind(this),
            p = A => this.data(A, !0);
        return e.transaction = {
            hash: o,
            type: d,
            accessList: Se.allowNull(this.accessList.bind(this), null),
            blockHash: Se.allowNull(o, null),
            blockNumber: Se.allowNull(l, null),
            transactionIndex: Se.allowNull(l, null),
            confirmations: Se.allowNull(l, null),
            from: r,
            gasPrice: Se.allowNull(n),
            maxPriorityFeePerGas: Se.allowNull(n),
            maxFeePerGas: Se.allowNull(n),
            gasLimit: n,
            to: Se.allowNull(r, null),
            value: n,
            nonce: l,
            data: s,
            r: Se.allowNull(this.uint256),
            s: Se.allowNull(this.uint256),
            v: Se.allowNull(l),
            creates: Se.allowNull(r, null),
            raw: Se.allowNull(s)
        }, e.transactionRequest = {
            from: Se.allowNull(r),
            nonce: Se.allowNull(l),
            gasLimit: Se.allowNull(n),
            gasPrice: Se.allowNull(n),
            maxPriorityFeePerGas: Se.allowNull(n),
            maxFeePerGas: Se.allowNull(n),
            to: Se.allowNull(r),
            value: Se.allowNull(n),
            data: Se.allowNull(p),
            type: Se.allowNull(l),
            accessList: Se.allowNull(this.accessList.bind(this), null)
        }, e.receiptLog = {
            transactionIndex: l,
            blockNumber: l,
            transactionHash: o,
            address: r,
            topics: Se.arrayOf(o),
            data: s,
            logIndex: l,
            blockHash: o
        }, e.receipt = {
            to: Se.allowNull(this.address, null),
            from: Se.allowNull(this.address, null),
            contractAddress: Se.allowNull(r, null),
            transactionIndex: l,
            root: Se.allowNull(f),
            gasUsed: n,
            logsBloom: Se.allowNull(s),
            blockHash: o,
            transactionHash: o,
            logs: Se.arrayOf(this.receiptLog.bind(this)),
            blockNumber: l,
            confirmations: Se.allowNull(l, null),
            cumulativeGasUsed: n,
            effectiveGasPrice: Se.allowNull(n),
            status: Se.allowNull(l),
            type: d
        }, e.block = {
            hash: o,
            parentHash: o,
            number: l,
            timestamp: l,
            nonce: Se.allowNull(f),
            difficulty: this.difficulty.bind(this),
            gasLimit: n,
            gasUsed: n,
            miner: r,
            extraData: s,
            transactions: Se.allowNull(Se.arrayOf(o)),
            baseFeePerGas: Se.allowNull(n)
        }, e.blockWithTransactions = Yt(e.block), e.blockWithTransactions.transactions = Se.allowNull(Se.arrayOf(this.transactionResponse.bind(this))), e.filter = {
            fromBlock: Se.allowNull(i, void 0),
            toBlock: Se.allowNull(i, void 0),
            blockHash: Se.allowNull(o, void 0),
            address: Se.allowNull(r, void 0),
            topics: Se.allowNull(this.topics.bind(this), void 0)
        }, e.filterLog = {
            blockNumber: Se.allowNull(l),
            blockHash: Se.allowNull(o),
            transactionIndex: l,
            removed: Se.allowNull(this.boolean.bind(this)),
            address: r,
            data: Se.allowFalsish(s, "0x"),
            topics: Se.arrayOf(o),
            transactionHash: o,
            logIndex: l
        }, e
    }
    accessList(e) {
        return Zo(e || [])
    }
    number(e) {
        return e === "0x" ? 0 : We.from(e).toNumber()
    }
    type(e) {
        return e === "0x" || e == null ? 0 : We.from(e).toNumber()
    }
    bigNumber(e) {
        return We.from(e)
    }
    boolean(e) {
        if (typeof e == "boolean") return e;
        if (typeof e == "string") {
            if (e = e.toLowerCase(), e === "true") return !0;
            if (e === "false") return !1
        }
        throw new Error("invalid boolean - " + e)
    }
    hex(e, r) {
        return typeof e == "string" && (!r && e.substring(0, 2) !== "0x" && (e = "0x" + e), Ht(e)) ? e.toLowerCase() : ra.throwArgumentError("invalid hash", "value", e)
    }
    data(e, r) {
        const n = this.hex(e, r);
        if (n.length % 2 != 0) throw new Error("invalid data; odd-length - " + e);
        return n
    }
    address(e) {
        return nr(e)
    }
    callAddress(e) {
        if (!Ht(e, 32)) return null;
        const r = nr(nf(e, 12));
        return r === F5 ? null : r
    }
    contractAddress(e) {
        return Qy(e)
    }
    blockTag(e) {
        if (e == null) return "latest";
        if (e === "earliest") return "0x0";
        if (e === "latest" || e === "pending") return e;
        if (typeof e == "number" || Ht(e)) return yh(e);
        throw new Error("invalid blockTag")
    }
    hash(e, r) {
        const n = this.hex(e, r);
        return Ju(n) !== 32 ? ra.throwArgumentError("invalid hash", "value", e) : n
    }
    difficulty(e) {
        if (e == null) return null;
        const r = We.from(e);
        try {
            return r.toNumber()
        } catch {}
        return null
    }
    uint256(e) {
        if (!Ht(e)) throw new Error("invalid uint256");
        return Qi(e, 32)
    }
    _block(e, r) {
        e.author != null && e.miner == null && (e.miner = e.author);
        const n = e._difficulty != null ? e._difficulty : e.difficulty,
            i = Se.check(r, e);
        return i._difficulty = n == null ? null : We.from(n), i
    }
    block(e) {
        return this._block(e, this.formats.block)
    }
    blockWithTransactions(e) {
        return this._block(e, this.formats.blockWithTransactions)
    }
    transactionRequest(e) {
        return Se.check(this.formats.transactionRequest, e)
    }
    transactionResponse(e) {
        e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas), e.to && We.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), e.input != null && e.data == null && (e.data = e.input), e.to == null && e.creates == null && (e.creates = this.contractAddress(e)), (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
        const r = Se.check(this.formats.transaction, e);
        if (e.chainId != null) {
            let n = e.chainId;
            Ht(n) && (n = We.from(n).toNumber()), r.chainId = n
        } else {
            let n = e.networkId;
            n == null && r.v == null && (n = e.chainId), Ht(n) && (n = We.from(n).toNumber()), typeof n != "number" && r.v != null && (n = (r.v - 35) / 2, n < 0 && (n = 0), n = parseInt(n)), typeof n != "number" && (n = 0), r.chainId = n
        }
        return r.blockHash && r.blockHash.replace(/0/g, "") === "x" && (r.blockHash = null), r
    }
    transaction(e) {
        return R4(e)
    }
    receiptLog(e) {
        return Se.check(this.formats.receiptLog, e)
    }
    receipt(e) {
        const r = Se.check(this.formats.receipt, e);
        if (r.root != null)
            if (r.root.length <= 4) {
                const n = We.from(r.root).toNumber();
                n === 0 || n === 1 ? (r.status != null && r.status !== n && ra.throwArgumentError("alt-root-status/status mismatch", "value", {
                    root: r.root,
                    status: r.status
                }), r.status = n, delete r.root) : ra.throwArgumentError("invalid alt-root-status", "value.root", r.root)
            } else r.root.length !== 66 && ra.throwArgumentError("invalid root hash", "value.root", r.root);
        return r.status != null && (r.byzantium = !0), r
    }
    topics(e) {
        return Array.isArray(e) ? e.map(r => this.topics(r)) : e != null ? this.hash(e, !0) : null
    }
    filter(e) {
        return Se.check(this.formats.filter, e)
    }
    filterLog(e) {
        return Se.check(this.formats.filterLog, e)
    }
    static check(e, r) {
        const n = {};
        for (const i in e) try {
            const s = e[i](r[i]);
            s !== void 0 && (n[i] = s)
        } catch (s) {
            throw s.checkKey = i, s.checkValue = r[i], s
        }
        return n
    }
    static allowNull(e, r) {
        return function(n) {
            return n == null ? r : e(n)
        }
    }
    static allowFalsish(e, r) {
        return function(n) {
            return n ? e(n) : r
        }
    }
    static arrayOf(e) {
        return function(r) {
            if (!Array.isArray(r)) throw new Error("not an array");
            const n = [];
            return r.forEach(function(i) {
                n.push(e(i))
            }), n
        }
    }
}
var Ze = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Mt = new W(ol);

function Vx(t) {
    return t == null ? "null" : (Ju(t) !== 32 && Mt.throwArgumentError("invalid topic", "topic", t), t.toLowerCase())
}

function Kx(t) {
    for (t = t.slice(); t.length > 0 && t[t.length - 1] == null;) t.pop();
    return t.map(e => {
        if (Array.isArray(e)) {
            const r = {};
            e.forEach(i => {
                r[Vx(i)] = !0
            });
            const n = Object.keys(r);
            return n.sort(), n.join("|")
        } else return Vx(e)
    }).join("&")
}

function I8(t) {
    return t === "" ? [] : t.split(/&/g).map(e => {
        if (e === "") return [];
        const r = e.split("|").map(n => n === "null" ? null : n);
        return r.length === 1 ? r[0] : r
    })
}

function na(t) {
    if (typeof t == "string") {
        if (t = t.toLowerCase(), Ju(t) === 32) return "tx:" + t;
        if (t.indexOf(":") === -1) return t
    } else {
        if (Array.isArray(t)) return "filter:*:" + Kx(t);
        if (NE.isForkEvent(t)) throw Mt.warn("not implemented"), new Error("not implemented");
        if (t && typeof t == "object") return "filter:" + (t.address || "*") + ":" + Kx(t.topics || [])
    }
    throw new Error("invalid event - " + t)
}

function af() {
    return new Date().getTime()
}

function Xx(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}
const R8 = ["block", "network", "pending", "poll"];
class k8 {
    constructor(e, r, n) {
        pe(this, "tag", e), pe(this, "listener", r), pe(this, "once", n)
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash;
            case "filter":
                return this.filter
        }
        return this.tag
    }
    get type() {
        return this.tag.split(":")[0]
    }
    get hash() {
        const e = this.tag.split(":");
        return e[0] !== "tx" ? null : e[1]
    }
    get filter() {
        const e = this.tag.split(":");
        if (e[0] !== "filter") return null;
        const r = e[1],
            n = I8(e[2]),
            i = {};
        return n.length > 0 && (i.topics = n), r && r !== "*" && (i.address = r), i
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || R8.indexOf(this.tag) >= 0
    }
}
const O8 = {
    "0": {
        symbol: "btc",
        p2pkh: 0,
        p2sh: 5,
        prefix: "bc"
    },
    "2": {
        symbol: "ltc",
        p2pkh: 48,
        p2sh: 50,
        prefix: "ltc"
    },
    "3": {
        symbol: "doge",
        p2pkh: 30,
        p2sh: 22
    },
    "60": {
        symbol: "eth",
        ilk: "eth"
    },
    "61": {
        symbol: "etc",
        ilk: "eth"
    },
    "700": {
        symbol: "xdai",
        ilk: "eth"
    }
};

function Ih(t) {
    return Qi(We.from(t).toHexString(), 32)
}

function Jx(t) {
    return Rx.encode(Yo([t, nf(Ox(Ox(t)), 0, 4)]))
}
const Zx = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), new RegExp("^(ipfs)://(.*)$", "i"), new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

function C8(t) {
    try {
        return zo(Yx(t))
    } catch {}
    return null
}

function Yx(t) {
    if (t === "0x") return null;
    const e = We.from(nf(t, 0, 32)).toNumber(),
        r = We.from(nf(t, e, e + 32)).toNumber();
    return nf(t, e + 32, e + 32 + r)
}
class Qx {
    constructor(e, r, n, i) {
        pe(this, "provider", e), pe(this, "name", n), pe(this, "address", e.formatter.address(r)), pe(this, "_resolvedAddress", i)
    }
    _fetchBytes(e, r) {
        return Ze(this, void 0, void 0, function*() {
            const n = {
                to: this.address,
                data: Es([e, Zu(this.name), r || "0x"])
            };
            try {
                return Yx(yield this.provider.call(n))
            } catch (i) {
                return i.code === W.errors.CALL_EXCEPTION, null
            }
        })
    }
    _getAddress(e, r) {
        const n = O8[String(e)];
        if (n == null && Mt.throwError(`unsupported coin type: ${e}`, W.errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${e})`
            }), n.ilk === "eth") return this.provider.formatter.address(r);
        const i = ro(r);
        if (n.p2pkh != null) {
            const s = r.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (s) {
                const o = parseInt(s[1], 16);
                if (s[2].length === o * 2 && o >= 1 && o <= 75) return Jx(Yo([
                    [n.p2pkh], "0x" + s[2]
                ]))
            }
        }
        if (n.p2sh != null) {
            const s = r.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (s) {
                const o = parseInt(s[1], 16);
                if (s[2].length === o * 2 && o >= 1 && o <= 75) return Jx(Yo([
                    [n.p2sh], "0x" + s[2]
                ]))
            }
        }
        if (n.prefix != null) {
            const s = i[1];
            let o = i[0];
            if (o === 0 ? s !== 20 && s !== 32 && (o = -1) : o = -1, o >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
                const f = Wx.toWords(i.slice(2));
                return f.unshift(o), Wx.encode(n.prefix, f)
            }
        }
        return null
    }
    getAddress(e) {
        return Ze(this, void 0, void 0, function*() {
            if (e == null && (e = 60), e === 60) try {
                const i = {
                        to: this.address,
                        data: "0x3b3b57de" + Zu(this.name).substring(2)
                    },
                    s = yield this.provider.call(i);
                return s === "0x" || s === H5 ? null : this.provider.formatter.callAddress(s)
            } catch (i) {
                if (i.code === W.errors.CALL_EXCEPTION) return null;
                throw i
            }
            const r = yield this._fetchBytes("0xf1cb7e06", Ih(e));
            if (r == null || r === "0x") return null;
            const n = this._getAddress(e, r);
            return n == null && Mt.throwError("invalid or unsupported coin data", W.errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${e})`,
                coinType: e,
                data: r
            }), n
        })
    }
    getAvatar() {
        return Ze(this, void 0, void 0, function*() {
            const e = [];
            try {
                const r = yield this.getText("avatar");
                if (r == null) return null;
                for (let n = 0; n < Zx.length; n++) {
                    const i = r.match(Zx[n]);
                    if (i != null) switch (i[1]) {
                        case "https":
                            return e.push({
                                type: "url",
                                content: r
                            }), {
                                linkage: e,
                                url: r
                            };
                        case "data":
                            return e.push({
                                type: "data",
                                content: r
                            }), {
                                linkage: e,
                                url: r
                            };
                        case "ipfs":
                            return e.push({
                                type: "ipfs",
                                content: r
                            }), {
                                linkage: e,
                                url: `https://gateway.ipfs.io/ipfs/${r.substring(7)}`
                            };
                        case "erc721":
                        case "erc1155":
                            {
                                const s = i[1] === "erc721" ? "0xc87b56dd" : "0x0e89341c";e.push({
                                    type: i[1],
                                    content: r
                                });
                                const o = this._resolvedAddress || (yield this.getAddress()),
                                    f = (i[2] || "").split("/");
                                if (f.length !== 2) return null;
                                const l = yield this.provider.formatter.address(f[0]), d = Qi(We.from(f[1]).toHexString(), 32);
                                if (i[1] === "erc721") {
                                    const N = this.provider.formatter.callAddress(yield this.provider.call({
                                        to: l,
                                        data: Es(["0x6352211e", d])
                                    }));
                                    if (o !== N) return null;
                                    e.push({
                                        type: "owner",
                                        content: N
                                    })
                                } else if (i[1] === "erc1155") {
                                    const N = We.from(yield this.provider.call({
                                        to: l,
                                        data: Es(["0x00fdd58e", Qi(o, 32), d])
                                    }));
                                    if (N.isZero()) return null;
                                    e.push({
                                        type: "balance",
                                        content: N.toString()
                                    })
                                }
                                const p = {
                                    to: this.provider.formatter.address(f[0]),
                                    data: Es([s, d])
                                };
                                let A = C8(yield this.provider.call(p));
                                if (A == null) return null;e.push({
                                    type: "metadata-url",
                                    content: A
                                }),
                                i[1] === "erc1155" && (A = A.replace("{id}", d.substring(2)));
                                const T = yield Hx(A);
                                return !T || typeof T.image != "string" || !T.image.match(/^(https:\/\/|data:)/i) ? null : (e.push({
                                    type: "metadata",
                                    content: JSON.stringify(T)
                                }), e.push({
                                    type: "url",
                                    content: T.image
                                }), {
                                    linkage: e,
                                    url: T.image
                                })
                            }
                    }
                }
            } catch {}
            return null
        })
    }
    getContentHash() {
        return Ze(this, void 0, void 0, function*() {
            const e = yield this._fetchBytes("0xbc1c58d1");
            if (e == null || e === "0x") return null;
            const r = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (r) {
                const i = parseInt(r[3], 16);
                if (r[4].length === i * 2) return "ipfs://" + Rx.encode("0x" + r[1])
            }
            const n = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            return n && n[1].length === 32 * 2 ? "bzz://" + n[1] : Mt.throwError("invalid or unsupported content hash data", W.errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: e
            })
        })
    }
    getText(e) {
        return Ze(this, void 0, void 0, function*() {
            let r = xi(e);
            r = Yo([Ih(64), Ih(r.length), r]), r.length % 32 != 0 && (r = Yo([r, Qi("0x", 32 - e.length % 32)]));
            const n = yield this._fetchBytes("0x59d1d43c", Jt(r));
            return n == null || n === "0x" ? null : zo(n)
        })
    }
}
let Rh = null,
    F8 = 1;
class D8 extends Va {
    constructor(e) {
        Mt.checkNew(new.target, Va);
        super();
        if (this._events = [], this._emitted = {
                block: -2
            }, this.formatter = new.target.getFormatter(), pe(this, "anyNetwork", e === "any"), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise) this._networkPromise = e, e.catch(r => {}), this._ready().catch(r => {});
        else {
            const r = hi(new.target, "getNetwork")(e);
            r ? (pe(this, "_network", r), this.emit("network", r, null)) : Mt.throwArgumentError("invalid network", "network", e)
        }
        this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._pollingInterval = 4e3, this._fastQueryDate = 0
    }
    _ready() {
        return Ze(this, void 0, void 0, function*() {
            if (this._network == null) {
                let e = null;
                if (this._networkPromise) try {
                    e = yield this._networkPromise
                } catch {}
                e == null && (e = yield this.detectNetwork()), e || Mt.throwError("no network detected", W.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = e : pe(this, "_network", e), this.emit("network", e, null))
            }
            return this._network
        })
    }
    get ready() {
        return of(() => this._ready().then(e => e, e => {
            if (!(e.code === W.errors.NETWORK_ERROR && e.event === "noNetwork")) throw e
        }))
    }
    static getFormatter() {
        return Rh == null && (Rh = new Se), Rh
    }
    static getNetwork(e) {
        return h8(e == null ? "homestead" : e)
    }
    _getInternalBlockNumber(e) {
        return Ze(this, void 0, void 0, function*() {
            if (yield this._ready(), e > 0)
                for (; this._internalBlockNumber;) {
                    const i = this._internalBlockNumber;
                    try {
                        const s = yield i;
                        if (af() - s.respTime <= e) return s.blockNumber;
                        break
                    } catch {
                        if (this._internalBlockNumber === i) break
                    }
                }
            const r = af(),
                n = kt({
                    blockNumber: this.perform("getBlockNumber", {}),
                    networkError: this.getNetwork().then(i => null, i => i)
                }).then(({
                    blockNumber: i,
                    networkError: s
                }) => {
                    if (s) throw this._internalBlockNumber === n && (this._internalBlockNumber = null), s;
                    const o = af();
                    return i = We.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), {
                        blockNumber: i,
                        reqTime: r,
                        respTime: o
                    }
                });
            return this._internalBlockNumber = n, n.catch(i => {
                this._internalBlockNumber === n && (this._internalBlockNumber = null)
            }), (yield n).blockNumber
        })
    }
    poll() {
        return Ze(this, void 0, void 0, function*() {
            const e = F8++,
                r = [];
            let n = null;
            try {
                n = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2)
            } catch (i) {
                this.emit("error", i);
                return
            }
            if (this._setFastBlockNumber(n), this.emit("poll", e, n), n === this._lastBlockNumber) {
                this.emit("didPoll", e);
                return
            }
            if (this._emitted.block === -2 && (this._emitted.block = n - 1), Math.abs(this._emitted.block - n) > 1e3) Mt.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${n})`), this.emit("error", Mt.makeError("network block skew detected", W.errors.NETWORK_ERROR, {
                blockNumber: n,
                event: "blockSkew",
                previousBlockNumber: this._emitted.block
            })), this.emit("block", n);
            else
                for (let i = this._emitted.block + 1; i <= n; i++) this.emit("block", i);
            this._emitted.block !== n && (this._emitted.block = n, Object.keys(this._emitted).forEach(i => {
                if (i === "block") return;
                const s = this._emitted[i];
                s !== "pending" && n - s > 12 && delete this._emitted[i]
            })), this._lastBlockNumber === -2 && (this._lastBlockNumber = n - 1), this._events.forEach(i => {
                switch (i.type) {
                    case "tx":
                        {
                            const s = i.hash;
                            let o = this.getTransactionReceipt(s).then(f => (!f || f.blockNumber == null || (this._emitted["t:" + s] = f.blockNumber, this.emit(s, f)), null)).catch(f => {
                                this.emit("error", f)
                            });r.push(o);
                            break
                        }
                    case "filter":
                        {
                            const s = i.filter;s.fromBlock = this._lastBlockNumber + 1,
                            s.toBlock = n;
                            const o = this.getLogs(s).then(f => {
                                f.length !== 0 && f.forEach(l => {
                                    this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l)
                                })
                            }).catch(f => {
                                this.emit("error", f)
                            });r.push(o);
                            break
                        }
                }
            }), this._lastBlockNumber = n, Promise.all(r).then(() => {
                this.emit("didPoll", e)
            }).catch(i => {
                this.emit("error", i)
            })
        })
    }
    resetEventsBlock(e) {
        this._lastBlockNumber = e - 1, this.polling && this.poll()
    }
    get network() {
        return this._network
    }
    detectNetwork() {
        return Ze(this, void 0, void 0, function*() {
            return Mt.throwError("provider does not support network detection", W.errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            })
        })
    }
    getNetwork() {
        return Ze(this, void 0, void 0, function*() {
            const e = yield this._ready(), r = yield this.detectNetwork();
            if (e.chainId !== r.chainId) {
                if (this.anyNetwork) return this._network = r, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", r, e), yield Xx(0), this._network;
                const n = Mt.makeError("underlying network changed", W.errors.NETWORK_ERROR, {
                    event: "changed",
                    network: e,
                    detectedNetwork: r
                });
                throw this.emit("error", n), n
            }
            return e
        })
    }
    get blockNumber() {
        return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(e => {
            this._setFastBlockNumber(e)
        }, e => {}), this._fastBlockNumber != null ? this._fastBlockNumber : -1
    }
    get polling() {
        return this._poller != null
    }
    set polling(e) {
        e && !this._poller ? (this._poller = setInterval(() => {
            this.poll()
        }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
            this.poll(), this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), this._bootstrapPoll = null
            }, this.pollingInterval)
        }, 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null)
    }
    get pollingInterval() {
        return this._pollingInterval
    }
    set pollingInterval(e) {
        if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e) throw new Error("invalid polling interval");
        this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
            this.poll()
        }, this._pollingInterval))
    }
    _getFastBlockNumber() {
        const e = af();
        return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then(r => ((this._fastBlockNumber == null || r > this._fastBlockNumber) && (this._fastBlockNumber = r), this._fastBlockNumber))), this._fastBlockNumberPromise
    }
    _setFastBlockNumber(e) {
        this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = af(), (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)))
    }
    waitForTransaction(e, r, n) {
        return Ze(this, void 0, void 0, function*() {
            return this._waitForTransaction(e, r == null ? 1 : r, n || 0, null)
        })
    }
    _waitForTransaction(e, r, n, i) {
        return Ze(this, void 0, void 0, function*() {
            const s = yield this.getTransactionReceipt(e);
            return (s ? s.confirmations : 0) >= r ? s : new Promise((o, f) => {
                const l = [];
                let d = !1;
                const p = function() {
                        return d ? !0 : (d = !0, l.forEach(T => {
                            T()
                        }), !1)
                    },
                    A = T => {
                        T.confirmations < r || p() || o(T)
                    };
                if (this.on(e, A), l.push(() => {
                        this.removeListener(e, A)
                    }), i) {
                    let T = i.startBlock,
                        N = null;
                    const P = C => Ze(this, void 0, void 0, function*() {
                        d || (yield Xx(1e3), this.getTransactionCount(i.from).then(S => Ze(this, void 0, void 0, function*() {
                            if (!d) {
                                if (S <= i.nonce) T = C;
                                else {
                                    {
                                        const k = yield this.getTransaction(e);
                                        if (k && k.blockNumber != null) return
                                    }
                                    for (N == null && (N = T - 3, N < i.startBlock && (N = i.startBlock)); N <= C;) {
                                        if (d) return;
                                        const k = yield this.getBlockWithTransactions(N);
                                        for (let I = 0; I < k.transactions.length; I++) {
                                            const U = k.transactions[I];
                                            if (U.hash === e) return;
                                            if (U.from === i.from && U.nonce === i.nonce) {
                                                if (d) return;
                                                const M = yield this.waitForTransaction(U.hash, r);
                                                if (p()) return;
                                                let F = "replaced";
                                                U.data === i.data && U.to === i.to && U.value.eq(i.value) ? F = "repriced" : U.data === "0x" && U.from === U.to && U.value.isZero() && (F = "cancelled"), f(Mt.makeError("transaction was replaced", W.errors.TRANSACTION_REPLACED, {
                                                    cancelled: F === "replaced" || F === "cancelled",
                                                    reason: F,
                                                    replacement: this._wrapTransaction(U),
                                                    hash: e,
                                                    receipt: M
                                                }));
                                                return
                                            }
                                        }
                                        N++
                                    }
                                }
                                d || this.once("block", P)
                            }
                        }), S => {
                            d || this.once("block", P)
                        }))
                    });
                    if (d) return;
                    this.once("block", P), l.push(() => {
                        this.removeListener("block", P)
                    })
                }
                if (typeof n == "number" && n > 0) {
                    const T = setTimeout(() => {
                        p() || f(Mt.makeError("timeout exceeded", W.errors.TIMEOUT, {
                            timeout: n
                        }))
                    }, n);
                    T.unref && T.unref(), l.push(() => {
                        clearTimeout(T)
                    })
                }
            })
        })
    }
    getBlockNumber() {
        return Ze(this, void 0, void 0, function*() {
            return this._getInternalBlockNumber(0)
        })
    }
    getGasPrice() {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const e = yield this.perform("getGasPrice", {});
            try {
                return We.from(e)
            } catch (r) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result: e,
                    error: r
                })
            }
        })
    }
    getBalance(e, r) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield kt({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("getBalance", n);
            try {
                return We.from(i)
            } catch (s) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "getBalance",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    getTransactionCount(e, r) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield kt({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("getTransactionCount", n);
            try {
                return We.from(i).toNumber()
            } catch (s) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    getCode(e, r) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield kt({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("getCode", n);
            try {
                return Jt(i)
            } catch (s) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "getCode",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    getStorageAt(e, r, n) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const i = yield kt({
                address: this._getAddress(e),
                blockTag: this._getBlockTag(n),
                position: Promise.resolve(r).then(o => yh(o))
            }), s = yield this.perform("getStorageAt", i);
            try {
                return Jt(s)
            } catch (o) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params: i,
                    result: s,
                    error: o
                })
            }
        })
    }
    _wrapTransaction(e, r, n) {
        if (r != null && Ju(r) !== 32) throw new Error("invalid response - sendTransaction");
        const i = e;
        return r != null && e.hash !== r && Mt.throwError("Transaction hash mismatch from Provider.sendTransaction.", W.errors.UNKNOWN_ERROR, {
            expectedHash: e.hash,
            returnedHash: r
        }), i.wait = (s, o) => Ze(this, void 0, void 0, function*() {
            s == null && (s = 1), o == null && (o = 0);
            let f;
            s !== 0 && n != null && (f = {
                data: e.data,
                from: e.from,
                nonce: e.nonce,
                to: e.to,
                value: e.value,
                startBlock: n
            });
            const l = yield this._waitForTransaction(e.hash, s, o, f);
            return l == null && s === 0 ? null : (this._emitted["t:" + e.hash] = l.blockNumber, l.status === 0 && Mt.throwError("transaction failed", W.errors.CALL_EXCEPTION, {
                transactionHash: e.hash,
                transaction: e,
                receipt: l
            }), l)
        }), i
    }
    sendTransaction(e) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield Promise.resolve(e).then(s => Jt(s)), n = this.formatter.transaction(e);
            n.confirmations == null && (n.confirmations = 0);
            const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const s = yield this.perform("sendTransaction", {
                    signedTransaction: r
                });
                return this._wrapTransaction(n, s, i)
            } catch (s) {
                throw s.transaction = n, s.transactionHash = n.hash, s
            }
        })
    }
    _getTransactionRequest(e) {
        return Ze(this, void 0, void 0, function*() {
            const r = yield e, n = {};
            return ["from", "to"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? this._getAddress(s) : null))
            }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? We.from(s) : null))
            }), ["type"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s != null ? s : null))
            }), r.accessList && (n.accessList = this.formatter.accessList(r.accessList)), ["data"].forEach(i => {
                r[i] != null && (n[i] = Promise.resolve(r[i]).then(s => s ? Jt(s) : null))
            }), this.formatter.transactionRequest(yield kt(n))
        })
    }
    _getFilter(e) {
        return Ze(this, void 0, void 0, function*() {
            e = yield e;
            const r = {};
            return e.address != null && (r.address = this._getAddress(e.address)), ["blockHash", "topics"].forEach(n => {
                e[n] != null && (r[n] = e[n])
            }), ["fromBlock", "toBlock"].forEach(n => {
                e[n] != null && (r[n] = this._getBlockTag(e[n]))
            }), this.formatter.filter(yield kt(r))
        })
    }
    call(e, r) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const n = yield kt({
                transaction: this._getTransactionRequest(e),
                blockTag: this._getBlockTag(r)
            }), i = yield this.perform("call", n);
            try {
                return Jt(i)
            } catch (s) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "call",
                    params: n,
                    result: i,
                    error: s
                })
            }
        })
    }
    estimateGas(e) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield kt({
                transaction: this._getTransactionRequest(e)
            }), n = yield this.perform("estimateGas", r);
            try {
                return We.from(n)
            } catch (i) {
                return Mt.throwError("bad result from backend", W.errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params: r,
                    result: n,
                    error: i
                })
            }
        })
    }
    _getAddress(e) {
        return Ze(this, void 0, void 0, function*() {
            e = yield e, typeof e != "string" && Mt.throwArgumentError("invalid address or ENS name", "name", e);
            const r = yield this.resolveName(e);
            return r == null && Mt.throwError("ENS name not configured", W.errors.UNSUPPORTED_OPERATION, {
                operation: `resolveName(${JSON.stringify(e)})`
            }), r
        })
    }
    _getBlock(e, r) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork(), e = yield e;
            let n = -128;
            const i = {
                includeTransactions: !!r
            };
            if (Ht(e, 32)) i.blockHash = e;
            else try {
                i.blockTag = yield this._getBlockTag(e), Ht(i.blockTag) && (n = parseInt(i.blockTag.substring(2), 16))
            } catch {
                Mt.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e)
            }
            return of(() => Ze(this, void 0, void 0, function*() {
                const s = yield this.perform("getBlock", i);
                if (s == null) return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && n > this._emitted.block ? null : void 0;
                if (r) {
                    let o = null;
                    for (let l = 0; l < s.transactions.length; l++) {
                        const d = s.transactions[l];
                        if (d.blockNumber == null) d.confirmations = 0;
                        else if (d.confirmations == null) {
                            o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                            let p = o - d.blockNumber + 1;
                            p <= 0 && (p = 1), d.confirmations = p
                        }
                    }
                    const f = this.formatter.blockWithTransactions(s);
                    return f.transactions = f.transactions.map(l => this._wrapTransaction(l)), f
                }
                return this.formatter.block(s)
            }), {
                oncePoll: this
            })
        })
    }
    getBlock(e) {
        return this._getBlock(e, !1)
    }
    getBlockWithTransactions(e) {
        return this._getBlock(e, !0)
    }
    getTransaction(e) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork(), e = yield e;
            const r = {
                transactionHash: this.formatter.hash(e, !0)
            };
            return of(() => Ze(this, void 0, void 0, function*() {
                const n = yield this.perform("getTransaction", r);
                if (n == null) return this._emitted["t:" + e] == null ? null : void 0;
                const i = this.formatter.transactionResponse(n);
                if (i.blockNumber == null) i.confirmations = 0;
                else if (i.confirmations == null) {
                    let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
                    o <= 0 && (o = 1), i.confirmations = o
                }
                return this._wrapTransaction(i)
            }), {
                oncePoll: this
            })
        })
    }
    getTransactionReceipt(e) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork(), e = yield e;
            const r = {
                transactionHash: this.formatter.hash(e, !0)
            };
            return of(() => Ze(this, void 0, void 0, function*() {
                const n = yield this.perform("getTransactionReceipt", r);
                if (n == null) return this._emitted["t:" + e] == null ? null : void 0;
                if (n.blockHash == null) return;
                const i = this.formatter.receipt(n);
                if (i.blockNumber == null) i.confirmations = 0;
                else if (i.confirmations == null) {
                    let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
                    o <= 0 && (o = 1), i.confirmations = o
                }
                return i
            }), {
                oncePoll: this
            })
        })
    }
    getLogs(e) {
        return Ze(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const r = yield kt({
                filter: this._getFilter(e)
            }), n = yield this.perform("getLogs", r);
            return n.forEach(i => {
                i.removed == null && (i.removed = !1)
            }), Se.arrayOf(this.formatter.filterLog.bind(this.formatter))(n)
        })
    }
    getEtherPrice() {
        return Ze(this, void 0, void 0, function*() {
            return yield this.getNetwork(), this.perform("getEtherPrice", {})
        })
    }
    _getBlockTag(e) {
        return Ze(this, void 0, void 0, function*() {
            if (e = yield e, typeof e == "number" && e < 0) {
                e % 1 && Mt.throwArgumentError("invalid BlockTag", "blockTag", e);
                let r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                return r += e, r < 0 && (r = 0), this.formatter.blockTag(r)
            }
            return this.formatter.blockTag(e)
        })
    }
    getResolver(e) {
        return Ze(this, void 0, void 0, function*() {
            try {
                const r = yield this._getResolver(e);
                return r == null ? null : new Qx(this, r, e)
            } catch (r) {
                return r.code === W.errors.CALL_EXCEPTION, null
            }
        })
    }
    _getResolver(e) {
        return Ze(this, void 0, void 0, function*() {
            const r = yield this.getNetwork();
            r.ensAddress || Mt.throwError("network does not support ENS", W.errors.UNSUPPORTED_OPERATION, {
                operation: "ENS",
                network: r.name
            });
            const n = {
                to: r.ensAddress,
                data: "0x0178b8bf" + Zu(e).substring(2)
            };
            try {
                return this.formatter.callAddress(yield this.call(n))
            } catch (i) {
                if (i.code === W.errors.CALL_EXCEPTION) return null;
                throw i
            }
        })
    }
    resolveName(e) {
        return Ze(this, void 0, void 0, function*() {
            e = yield e;
            try {
                return Promise.resolve(this.formatter.address(e))
            } catch (n) {
                if (Ht(e)) throw n
            }
            typeof e != "string" && Mt.throwArgumentError("invalid ENS name", "name", e);
            const r = yield this.getResolver(e);
            return r ? yield r.getAddress(): null
        })
    }
    lookupAddress(e) {
        return Ze(this, void 0, void 0, function*() {
            e = yield e, e = this.formatter.address(e);
            const r = e.substring(2).toLowerCase() + ".addr.reverse",
                n = yield this._getResolver(r);
            if (!n) return null;
            let i = ro(yield this.call({
                to: n,
                data: "0x691f3431" + Zu(r).substring(2)
            }));
            if (i.length < 32 || !We.from(i.slice(0, 32)).eq(32) || (i = i.slice(32), i.length < 32)) return null;
            const s = We.from(i.slice(0, 32)).toNumber();
            if (i = i.slice(32), s > i.length) return null;
            const o = zo(i.slice(0, s));
            return (yield this.resolveName(o)) != e ? null : o
        })
    }
    getAvatar(e) {
        return Ze(this, void 0, void 0, function*() {
            let r = null;
            if (Ht(e)) {
                const i = this.formatter.address(e),
                    s = i.substring(2).toLowerCase() + ".addr.reverse",
                    o = yield this._getResolver(s);
                if (!o) return null;
                r = new Qx(this, o, "_", i)
            } else if (r = yield this.getResolver(e), !r) return null;
            const n = yield r.getAvatar();
            return n == null ? null : n.url
        })
    }
    perform(e, r) {
        return Mt.throwError(e + " not implemented", W.errors.NOT_IMPLEMENTED, {
            operation: e
        })
    }
    _startEvent(e) {
        this.polling = this._events.filter(r => r.pollable()).length > 0
    }
    _stopEvent(e) {
        this.polling = this._events.filter(r => r.pollable()).length > 0
    }
    _addEventListener(e, r, n) {
        const i = new k8(na(e), r, n);
        return this._events.push(i), this._startEvent(i), this
    }
    on(e, r) {
        return this._addEventListener(e, r, !1)
    }
    once(e, r) {
        return this._addEventListener(e, r, !0)
    }
    emit(e, ...r) {
        let n = !1,
            i = [],
            s = na(e);
        return this._events = this._events.filter(o => o.tag !== s ? !0 : (setTimeout(() => {
            o.listener.apply(this, r)
        }, 0), n = !0, o.once ? (i.push(o), !1) : !0)), i.forEach(o => {
            this._stopEvent(o)
        }), n
    }
    listenerCount(e) {
        if (!e) return this._events.length;
        let r = na(e);
        return this._events.filter(n => n.tag === r).length
    }
    listeners(e) {
        if (e == null) return this._events.map(n => n.listener);
        let r = na(e);
        return this._events.filter(n => n.tag === r).map(n => n.listener)
    }
    off(e, r) {
        if (r == null) return this.removeAllListeners(e);
        const n = [];
        let i = !1,
            s = na(e);
        return this._events = this._events.filter(o => o.tag !== s || o.listener != r || i ? !0 : (i = !0, n.push(o), !1)), n.forEach(o => {
            this._stopEvent(o)
        }), this
    }
    removeAllListeners(e) {
        let r = [];
        if (e == null) r = this._events, this._events = [];
        else {
            const n = na(e);
            this._events = this._events.filter(i => i.tag !== n ? !0 : (r.push(i), !1))
        }
        return r.forEach(n => {
            this._stopEvent(n)
        }), this
    }
}
var es = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const cr = new W(ol),
    U8 = ["call", "estimateGas"];

function e1(t, e, r) {
    if (t === "call" && e.code === W.errors.SERVER_ERROR) {
        const s = e.error;
        if (s && s.message.match("reverted") && Ht(s.data)) return s.data;
        cr.throwError("missing revert data in call exception", W.errors.CALL_EXCEPTION, {
            error: e,
            data: "0x"
        })
    }
    let n = e.message;
    e.code === W.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? n = e.error.message : typeof e.body == "string" ? n = e.body : typeof e.responseText == "string" && (n = e.responseText), n = (n || "").toLowerCase();
    const i = r.transaction || r.signedTransaction;
    throw n.match(/insufficient funds|base fee exceeds gas limit/) && cr.throwError("insufficient funds for intrinsic transaction cost", W.errors.INSUFFICIENT_FUNDS, {
        error: e,
        method: t,
        transaction: i
    }), n.match(/nonce too low/) && cr.throwError("nonce has already been used", W.errors.NONCE_EXPIRED, {
        error: e,
        method: t,
        transaction: i
    }), n.match(/replacement transaction underpriced/) && cr.throwError("replacement fee too low", W.errors.REPLACEMENT_UNDERPRICED, {
        error: e,
        method: t,
        transaction: i
    }), n.match(/only replay-protected/) && cr.throwError("legacy pre-eip-155 transactions not supported", W.errors.UNSUPPORTED_OPERATION, {
        error: e,
        method: t,
        transaction: i
    }), U8.indexOf(t) >= 0 && n.match(/gas required exceeds allowance|always failing transaction|execution reverted/) && cr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", W.errors.UNPREDICTABLE_GAS_LIMIT, {
        error: e,
        method: t,
        transaction: i
    }), e
}

function t1(t) {
    return new Promise(function(e) {
        setTimeout(e, t)
    })
}

function L8(t) {
    if (t.error) {
        const e = new Error(t.error.message);
        throw e.code = t.error.code, e.data = t.error.data, e
    }
    return t.result
}

function ff(t) {
    return t && t.toLowerCase()
}
const kh = {};
class al extends bh {
    constructor(e, r, n) {
        cr.checkNew(new.target, al);
        super();
        if (e !== kh) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        pe(this, "provider", r), n == null && (n = 0), typeof n == "string" ? (pe(this, "_address", this.provider.formatter.address(n)), pe(this, "_index", null)) : typeof n == "number" ? (pe(this, "_index", n), pe(this, "_address", null)) : cr.throwArgumentError("invalid address or index", "addressOrIndex", n)
    }
    connect(e) {
        return cr.throwError("cannot alter JSON-RPC Signer connection", W.errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        })
    }
    connectUnchecked() {
        return new B8(kh, this.provider, this._address || this._index)
    }
    getAddress() {
        return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then(e => (e.length <= this._index && cr.throwError("unknown account #" + this._index, W.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
        }), this.provider.formatter.address(e[this._index])))
    }
    sendUncheckedTransaction(e) {
        e = Yt(e);
        const r = this.getAddress().then(n => (n && (n = n.toLowerCase()), n));
        if (e.gasLimit == null) {
            const n = Yt(e);
            n.from = r, e.gasLimit = this.provider.estimateGas(n)
        }
        return e.to != null && (e.to = Promise.resolve(e.to).then(n => es(this, void 0, void 0, function*() {
            if (n == null) return null;
            const i = yield this.provider.resolveName(n);
            return i == null && cr.throwArgumentError("provided ENS name resolves to null", "tx.to", n), i
        }))), kt({
            tx: kt(e),
            sender: r
        }).then(({
            tx: n,
            sender: i
        }) => {
            n.from != null ? n.from.toLowerCase() !== i && cr.throwArgumentError("from address mismatch", "transaction", e) : n.from = i;
            const s = this.provider.constructor.hexlifyTransaction(n, {
                from: !0
            });
            return this.provider.send("eth_sendTransaction", [s]).then(o => o, o => e1("sendTransaction", o, s))
        })
    }
    signTransaction(e) {
        return cr.throwError("signing transactions is unsupported", W.errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        })
    }
    sendTransaction(e) {
        return es(this, void 0, void 0, function*() {
            const r = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), n = yield this.sendUncheckedTransaction(e);
            try {
                return yield of (() => es(this, void 0, void 0, function*() {
                    const i = yield this.provider.getTransaction(n);
                    if (i !== null) return this.provider._wrapTransaction(i, n, r)
                }), {
                    oncePoll: this.provider
                })
            } catch (i) {
                throw i.transactionHash = n, i
            }
        })
    }
    signMessage(e) {
        return es(this, void 0, void 0, function*() {
            const r = typeof e == "string" ? xi(e) : e,
                n = yield this.getAddress();
            return yield this.provider.send("personal_sign", [Jt(r), n.toLowerCase()])
        })
    }
    _legacySignMessage(e) {
        return es(this, void 0, void 0, function*() {
            const r = typeof e == "string" ? xi(e) : e,
                n = yield this.getAddress();
            return yield this.provider.send("eth_sign", [n.toLowerCase(), Jt(r)])
        })
    }
    _signTypedData(e, r, n) {
        return es(this, void 0, void 0, function*() {
            const i = yield Zr.resolveNames(e, r, n, o => this.provider.resolveName(o)), s = yield this.getAddress();
            return yield this.provider.send("eth_signTypedData_v4", [s.toLowerCase(), JSON.stringify(Zr.getPayload(i.domain, r, i.value))])
        })
    }
    unlock(e) {
        return es(this, void 0, void 0, function*() {
            const r = this.provider,
                n = yield this.getAddress();
            return r.send("personal_unlockAccount", [n.toLowerCase(), e, null])
        })
    }
}
class B8 extends al {
    sendTransaction(e) {
        return this.sendUncheckedTransaction(e).then(r => ({
            hash: r,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: n => this.provider.waitForTransaction(r, n)
        }))
    }
}
const $8 = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    value: !0,
    type: !0,
    accessList: !0,
    maxFeePerGas: !0,
    maxPriorityFeePerGas: !0
};
class Oh extends D8 {
    constructor(e, r) {
        cr.checkNew(new.target, Oh);
        let n = r;
        n == null && (n = new Promise((i, s) => {
            setTimeout(() => {
                this.detectNetwork().then(o => {
                    i(o)
                }, o => {
                    s(o)
                })
            }, 0)
        }));
        super(n);
        e || (e = hi(this.constructor, "defaultUrl")()), typeof e == "string" ? pe(this, "connection", Object.freeze({
            url: e
        })) : pe(this, "connection", Object.freeze(Yt(e))), this._nextId = 42
    }
    get _cache() {
        return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache
    }
    static defaultUrl() {
        return "http://localhost:8545"
    }
    detectNetwork() {
        return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
            this._cache.detectNetwork = null
        }, 0)), this._cache.detectNetwork
    }
    _uncachedDetectNetwork() {
        return es(this, void 0, void 0, function*() {
            yield t1(0);
            let e = null;
            try {
                e = yield this.send("eth_chainId", [])
            } catch {
                try {
                    e = yield this.send("net_version", [])
                } catch {}
            }
            if (e != null) {
                const r = hi(this.constructor, "getNetwork");
                try {
                    return r(We.from(e).toNumber())
                } catch (n) {
                    return cr.throwError("could not detect network", W.errors.NETWORK_ERROR, {
                        chainId: e,
                        event: "invalidNetwork",
                        serverError: n
                    })
                }
            }
            return cr.throwError("could not detect network", W.errors.NETWORK_ERROR, {
                event: "noNetwork"
            })
        })
    }
    getSigner(e) {
        return new al(kh, this, e)
    }
    getUncheckedSigner(e) {
        return this.getSigner(e).connectUnchecked()
    }
    listAccounts() {
        return this.send("eth_accounts", []).then(e => e.map(r => this.formatter.address(r)))
    }
    send(e, r) {
        const n = {
            method: e,
            params: r,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: Wi(n),
            provider: this
        });
        const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
        if (i && this._cache[e]) return this._cache[e];
        const s = Hx(this.connection, JSON.stringify(n), L8).then(o => (this.emit("debug", {
            action: "response",
            request: n,
            response: o,
            provider: this
        }), o), o => {
            throw this.emit("debug", {
                action: "response",
                error: o,
                request: n,
                provider: this
            }), o
        });
        return i && (this._cache[e] = s, setTimeout(() => {
            this._cache[e] = null
        }, 0)), s
    }
    prepareRequest(e, r) {
        switch (e) {
            case "getBlockNumber":
                return ["eth_blockNumber", []];
            case "getGasPrice":
                return ["eth_gasPrice", []];
            case "getBalance":
                return ["eth_getBalance", [ff(r.address), r.blockTag]];
            case "getTransactionCount":
                return ["eth_getTransactionCount", [ff(r.address), r.blockTag]];
            case "getCode":
                return ["eth_getCode", [ff(r.address), r.blockTag]];
            case "getStorageAt":
                return ["eth_getStorageAt", [ff(r.address), r.position, r.blockTag]];
            case "sendTransaction":
                return ["eth_sendRawTransaction", [r.signedTransaction]];
            case "getBlock":
                return r.blockTag ? ["eth_getBlockByNumber", [r.blockTag, !!r.includeTransactions]] : r.blockHash ? ["eth_getBlockByHash", [r.blockHash, !!r.includeTransactions]] : null;
            case "getTransaction":
                return ["eth_getTransactionByHash", [r.transactionHash]];
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [r.transactionHash]];
            case "call":
                {
                    const n = hi(this.constructor, "hexlifyTransaction");
                    return ["eth_call", [n(r.transaction, {
                        from: !0
                    }), r.blockTag]]
                }
            case "estimateGas":
                {
                    const n = hi(this.constructor, "hexlifyTransaction");
                    return ["eth_estimateGas", [n(r.transaction, {
                        from: !0
                    })]]
                }
            case "getLogs":
                return r.filter && r.filter.address != null && (r.filter.address = ff(r.filter.address)), ["eth_getLogs", [r.filter]]
        }
        return null
    }
    perform(e, r) {
        return es(this, void 0, void 0, function*() {
            if (e === "call" || e === "estimateGas") {
                const i = r.transaction;
                if (i && i.type != null && We.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
                    const s = yield this.getFeeData();
                    s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (r = Yt(r), r.transaction = Yt(i), delete r.transaction.type)
                }
            }
            const n = this.prepareRequest(e, r);
            n == null && cr.throwError(e + " not implemented", W.errors.NOT_IMPLEMENTED, {
                operation: e
            });
            try {
                return yield this.send(n[0], n[1])
            } catch (i) {
                return e1(e, i, r)
            }
        })
    }
    _startEvent(e) {
        e.tag === "pending" && this._startPending(), super._startEvent(e)
    }
    _startPending() {
        if (this._pendingFilter != null) return;
        const e = this,
            r = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = r, r.then(function(n) {
            function i() {
                e.send("eth_getFilterChanges", [n]).then(function(s) {
                    if (e._pendingFilter != r) return null;
                    let o = Promise.resolve();
                    return s.forEach(function(f) {
                        e._emitted["t:" + f.toLowerCase()] = "pending", o = o.then(function() {
                            return e.getTransaction(f).then(function(l) {
                                return e.emit("pending", l), null
                            })
                        })
                    }), o.then(function() {
                        return t1(1e3)
                    })
                }).then(function() {
                    if (e._pendingFilter != r) {
                        e.send("eth_uninstallFilter", [n]);
                        return
                    }
                    return setTimeout(function() {
                        i()
                    }, 0), null
                }).catch(s => {})
            }
            return i(), n
        }).catch(n => {})
    }
    _stopEvent(e) {
        e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e)
    }
    static hexlifyTransaction(e, r) {
        const n = Yt($8);
        if (r)
            for (const s in r) r[s] && (n[s] = !0);
        r5(e, n);
        const i = {};
        return ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
            if (e[s] == null) return;
            const o = yh(e[s]);
            s === "gasLimit" && (s = "gas"), i[s] = o
        }), ["from", "to", "data"].forEach(function(s) {
            e[s] != null && (i[s] = Jt(e[s]))
        }), e.accessList && (i.accessList = Zo(e.accessList)), i
    }
}
const Ch = new W(ol);
let G8 = 1;

function r1(t, e) {
    const r = "Web3LegacyFetcher";
    return function(n, i) {
        const s = {
            method: n,
            params: i,
            id: G8++,
            jsonrpc: "2.0"
        };
        return new Promise((o, f) => {
            this.emit("debug", {
                action: "request",
                fetcher: r,
                request: Wi(s),
                provider: this
            }), e(s, (l, d) => {
                if (l) return this.emit("debug", {
                    action: "response",
                    fetcher: r,
                    error: l,
                    request: s,
                    provider: this
                }), f(l);
                if (this.emit("debug", {
                        action: "response",
                        fetcher: r,
                        request: s,
                        response: d,
                        provider: this
                    }), d.error) {
                    const p = new Error(d.error.message);
                    return p.code = d.error.code, p.data = d.error.data, f(p)
                }
                o(d.result)
            })
        })
    }
}

function z8(t) {
    return function(e, r) {
        r == null && (r = []);
        const n = {
            method: e,
            params: r
        };
        return this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: Wi(n),
            provider: this
        }), t.request(n).then(i => (this.emit("debug", {
            action: "response",
            fetcher: "Eip1193Fetcher",
            request: n,
            response: i,
            provider: this
        }), i), i => {
            throw this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request: n,
                error: i,
                provider: this
            }), i
        })
    }
}
class n1 extends Oh {
    constructor(e, r) {
        Ch.checkNew(new.target, n1), e == null && Ch.throwArgumentError("missing provider", "provider", e);
        let n = null,
            i = null,
            s = null;
        typeof e == "function" ? (n = "unknown:", i = e) : (n = e.host || e.path || "", !n && e.isMetaMask && (n = "metamask"), s = e, e.request ? (n === "" && (n = "eip-1193:"), i = z8(e)) : e.sendAsync ? i = r1(e, e.sendAsync.bind(e)) : e.send ? i = r1(e, e.send.bind(e)) : Ch.throwArgumentError("unsupported provider", "provider", e), n || (n = "unknown:"));
        super(n, r);
        pe(this, "jsonRpcFetchFunc", i), pe(this, "provider", s)
    }
    send(e, r) {
        return this.jsonRpcFetchFunc(e, r)
    }
}
var H8 = Object.defineProperty,
    q8 = Object.defineProperties,
    j8 = Object.getOwnPropertyDescriptors,
    i1 = Object.getOwnPropertySymbols,
    W8 = Object.prototype.hasOwnProperty,
    V8 = Object.prototype.propertyIsEnumerable,
    s1 = (t, e, r) => e in t ? H8(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r,
    ki = (t, e) => {
        for (var r in e || (e = {})) W8.call(e, r) && s1(t, r, e[r]);
        if (i1)
            for (var r of i1(e)) V8.call(e, r) && s1(t, r, e[r]);
        return t
    },
    Fh = (t, e) => q8(t, j8(e));
const uf = {
    type: "default",
    timeout: 5e3,
    showCloseButton: !0,
    position: "top-right",
    transition: "bounce",
    hideProgressBar: !1,
    swipeClose: !0
};
var no, _s;
(_s = no || (no = {}))[_s.TITLE_ONLY = 0] = "TITLE_ONLY", _s[_s.TITLE_DESCRIPTION = 1] = "TITLE_DESCRIPTION", _s[_s.COMPONENT = 2] = "COMPONENT", _s[_s.VNODE = 3] = "VNODE";
const K8 = {
        "top-left": {
            bounce: "mosha__bounceInLeft",
            zoom: "mosha__zoomIn",
            slide: "mosha__slideInLeft"
        },
        "top-right": {
            bounce: "mosha__bounceInRight",
            zoom: "mosha__zoomIn",
            slide: "mosha__slideInRight"
        },
        "top-center": {
            bounce: "mosha__bounceInDown",
            zoom: "mosha__zoomIn",
            slide: "mosha__slideInDown"
        },
        "bottom-center": {
            bounce: "mosha__bounceInUp",
            zoom: "mosha__zoomIn",
            slide: "mosha__slideInUp"
        },
        "bottom-right": {
            bounce: "mosha__bounceInRight",
            zoom: "mosha__zoomIn",
            slide: "mosha__slideInRight"
        },
        "bottom-left": {
            bounce: "mosha__bounceInLeft",
            zoom: "mosha__zoomIn",
            slide: "mosha__slideInLeft"
        }
    },
    LS = (t, e) => _t(t, e),
    o1 = (t, e = 300) => {
        let r;
        return (...n) => {
            r && (clearTimeout(r), r = void 0), r = setTimeout(() => t(...n), e)
        }
    },
    X8 = (t, e, r) => {
        const n = Zt(),
            i = Zt(void 0),
            s = Zt(),
            o = d => d instanceof MouseEvent,
            f = d => {
                r !== !1 && n.value && (o(d) ? i.value = n.value.clientX - d.clientX : i.value = n.value.touches[0].clientX - d.touches[0].clientX, s.value = Fh(ki({}, s.value), {
                    transition: "none"
                }), t.endsWith("left") ? s.value.left = -i.value + "px !important" : t.endsWith("right") ? s.value.right = `${i.value}px !important` : i.value > 0 ? s.value.left = -i.value + "px !important" : s.value.right = `${i.value}px !important`, Math.abs(i.value) > 200 && e())
            },
            l = d => {
                r !== !1 && (n.value && (n.value = void 0), i.value && (i.value = void 0), removeEventListener(d, f))
            };
        return Ao(() => {
            r !== !1 && (l("mousemove"), l("touchmove"))
        }), {
            swipedDiff: i,
            swipeStart: n,
            swipeStyle: s,
            swipeHandler: f,
            startSwipeHandler: d => {
                if (r === !1) return;
                n.value = d;
                const p = o(d) ? "mousemove" : "touchmove",
                    A = o(d) ? "mouseup" : "touchend";
                addEventListener(p, f), addEventListener(A, () => (T => {
                    const N = {
                            transition: "left .3s ease-out",
                            left: 0
                        },
                        P = {
                            transition: "right .3s ease-out",
                            right: 0
                        },
                        C = {
                            transition: "all .3s ease-out",
                            left: 0,
                            right: 0
                        };
                    t.endsWith("left") ? s.value = ki(ki({}, s.value), N) : t.endsWith("right") ? s.value = ki(ki({}, s.value), P) : s.value = ki(ki({}, s.value), C), n.value = void 0, i.value = void 0, removeEventListener(T, f)
                })(p))
            },
            cleanUpMove: l
        }
    };
var a1 = Eo({
    props: {
        type: {
            type: String,
            default: "default"
        }
    }
});
const J8 = {
        class: "mosha__icon"
    },
    Z8 = {
        key: 0,
        xmlns: "http://www.w3.org/2000/svg",
        height: "32px",
        viewBox: "0 0 24 24",
        width: "32px",
        fill: "#ffffff"
    },
    Y8 = _t("path", {
        d: "M4.47 21h15.06c1.54 0 2.5-1.67 1.73-3L13.73 4.99c-.77-1.33-2.69-1.33-3.46 0L2.74 18c-.77 1.33.19 3 1.73 3zM12 14c-.55 0-1-.45-1-1v-2c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z"
    }, null, -1),
    Q8 = {
        key: 1,
        xmlns: "http://www.w3.org/2000/svg",
        height: "32px",
        viewBox: "0 0 24 24",
        width: "32px",
        fill: "#ffffff"
    },
    e_ = _t("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 11c-.55 0-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z"
    }, null, -1),
    t_ = {
        key: 2,
        xmlns: "http://www.w3.org/2000/svg",
        height: "32px",
        viewBox: "0 0 24 24",
        width: "32px",
        fill: "#ffffff"
    },
    r_ = _t("path", {
        d: "M0 0h24v24H0V0z",
        fill: "none"
    }, null, -1),
    n_ = _t("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM9.29 16.29L5.7 12.7c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L10 14.17l6.88-6.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-7.59 7.59c-.38.39-1.02.39-1.41 0z"
    }, null, -1),
    i_ = {
        key: 3,
        xmlns: "http://www.w3.org/2000/svg",
        height: "32px",
        viewBox: "0 0 24 24",
        width: "32px",
        fill: "#616161"
    },
    s_ = _t("path", {
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1),
    o_ = _t("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
    }, null, -1),
    a_ = {
        key: 4,
        xmlns: "http://www.w3.org/2000/svg",
        height: "32px",
        viewBox: "0 0 24 24",
        width: "32px",
        fill: "#ffffff"
    },
    f_ = _t("path", {
        d: "M0 0h24v24H0z",
        fill: "none"
    }, null, -1),
    u_ = _t("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
    }, null, -1);
a1.render = function(t, e, r, n, i, s) {
    return vr(), wr("span", J8, [t.type === "warning" ? (vr(), wr("svg", Z8, [Y8])) : t.type === "danger" ? (vr(), wr("svg", Q8, [e_])) : t.type === "success" ? (vr(), wr("svg", t_, [r_, n_])) : t.type === "default" ? (vr(), wr("svg", i_, [s_, o_])) : (vr(), wr("svg", a_, [f_, u_]))])
};
var fl = Eo({
    name: "MToast",
    components: {
        MIcon: a1
    },
    props: {
        visible: Boolean,
        text: {
            type: String,
            default: ""
        },
        description: {
            type: String,
            default: ""
        },
        toastBackgroundColor: {
            type: String,
            default: ""
        },
        type: {
            type: String,
            default: "default"
        },
        onClose: {
            type: Function,
            default: () => null
        },
        onCloseHandler: {
            type: Function,
            required: !0
        },
        offset: {
            type: Number,
            required: !0
        },
        id: {
            type: Number,
            required: !0
        },
        timeout: {
            type: Number,
            default: 5e3
        },
        position: {
            type: String,
            required: !0
        },
        showCloseButton: {
            type: Boolean,
            default: !0
        },
        swipeClose: {
            type: Boolean,
            default: !0
        },
        hideProgressBar: {
            type: Boolean,
            default: !1
        },
        showIcon: {
            type: Boolean,
            default: !1
        },
        transition: {
            type: String,
            default: "bounce"
        }
    },
    setup(t, e) {
        const r = Zt(),
            {
                width: n
            } = (() => {
                const I = Zt(-1),
                    U = Zt(-1),
                    M = F => {
                        F !== null && F.currentTarget !== null && (I.value = F.currentTarget.innerWidth, U.value = F.currentTarget.innerHeight)
                    };
                return us(() => {
                    window.innerWidth > 0 && (I.value = window.innerWidth, U.value = window.innerHeight), window.addEventListener("resize", o1(M))
                }), Ao(() => {
                    window.removeEventListener("resize", o1(M))
                }), {
                    width: I,
                    height: U
                }
            })(),
            {
                swipedDiff: i,
                startSwipeHandler: s,
                swipeStyle: o,
                cleanUpMove: f
            } = X8(t.position, t.onCloseHandler, t.swipeClose),
            {
                transitionType: l
            } = (d = t.position, p = t.transition, A = i, {
                transitionType: br(() => A.value > 200 ? "mosha__fadeOutLeft" : A.value < -200 ? "mosha__fadeOutRight" : K8[d][p])
            });
        var d, p, A;
        const {
            start: T,
            stop: N,
            progress: P
        } = ((I, U) => {
            const M = Zt(),
                F = Zt(0),
                D = Zt(U),
                q = Zt(),
                V = Zt(100),
                Q = () => {
                    clearInterval(q.value), clearTimeout(M.value)
                };
            return us(() => {}), Ao(() => {
                Q()
            }), {
                start: () => {
                    F.value = Date.now(), clearTimeout(M.value), q.value = setInterval(() => {
                        V.value--
                    }, U / 100 - 5), M.value = setTimeout(I, D.value)
                },
                stop: () => {
                    clearInterval(q.value), clearTimeout(M.value), D.value -= Date.now() - F.value
                },
                clear: Q,
                progress: V
            }
        })(() => {
            t.onCloseHandler()
        }, t.timeout), C = br(() => e.slots.default), S = br(() => /<\/?[a-z][\s\S]*>/i.test(t.description)), k = () => {
            t.timeout > 0 && T()
        };
        return m6(() => {
            const {
                customStyle: I
            } = ((U, M, F) => {
                const D = br(() => {
                    switch (U) {
                        case "top-left":
                            return {
                                left: "0",
                                top: `${M}px`
                            };
                        case "bottom-left":
                            return {
                                left: "0",
                                bottom: `${M}px`
                            };
                        case "bottom-right":
                            return {
                                right: "0",
                                bottom: `${M}px`
                            };
                        case "top-center":
                            return {
                                top: `${M}px`,
                                left: "0",
                                right: "0",
                                marginRight: "auto",
                                marginLeft: "auto"
                            };
                        case "bottom-center":
                            return {
                                bottom: `${M}px`,
                                left: "0",
                                right: "0",
                                marginRight: "auto",
                                marginLeft: "auto"
                            };
                        default:
                            return {
                                right: "0",
                                top: `${M}px`
                            }
                    }
                });
                return F.length > 0 && (D.value.backgroundColor = F), {
                    customStyle: D
                }
            })(t.position, t.offset, t.toastBackgroundColor);
            r.value = I.value
        }), us(() => {
            k()
        }), {
            style: r,
            transitionType: l,
            startTimer: k,
            progress: P,
            onTouchStart: I => {
                s(I)
            },
            onMouseLeave: () => {
                f("mousemove"), k()
            },
            onMouseDown: I => {
                s(I)
            },
            swipeStyle: o,
            isSlotPassed: C,
            isDescriptionHtml: S,
            onMouseEnter: () => {
                t.timeout > 0 && n.value > 425 && N()
            }
        }
    }
});
const l_ = {
        class: "mosha__toast__content-wrapper"
    },
    c_ = {
        class: "mosha__toast__content"
    },
    h_ = {
        class: "mosha__toast__content__text"
    },
    d_ = {
        key: 1,
        class: "mosha__toast__content__description"
    },
    p_ = {
        key: 0,
        class: "mosha__toast__slot-wrapper"
    };
fl.render = function(t, e, r, n, i, s) {
    const o = Ww("MIcon");
    return vr(), wr(nc, {
        name: t.transitionType,
        type: "animation"
    }, {
        default: $p(() => [t.visible ? (vr(), wr("div", {
            key: 0,
            class: ["mosha__toast", t.toastBackgroundColor ? null : t.type],
            style: [t.style, t.swipeStyle],
            onMouseenter: e[2] || (e[2] = (...f) => t.onMouseEnter && t.onMouseEnter(...f)),
            onMouseleave: e[3] || (e[3] = (...f) => t.onMouseLeave && t.onMouseLeave(...f)),
            onTouchstartPassive: e[4] || (e[4] = (...f) => t.onTouchStart && t.onTouchStart(...f)),
            onMousedown: e[5] || (e[5] = (...f) => t.onMouseDown && t.onMouseDown(...f))
        }, [_t("div", l_, [t.showIcon ? (vr(), wr(o, {
            key: 0,
            type: t.type
        }, null, 8, ["type"])) : Hs("", !0), _t("div", c_, [_t("div", h_, fp(t.text), 1), t.description.length > 0 && t.isDescriptionHtml ? (vr(), wr("div", {
            key: 0,
            class: "mosha__toast__content__description",
            innerHTML: t.description
        }, null, 8, ["innerHTML"])) : Hs("", !0), t.description.length > 0 && !t.isDescriptionHtml ? (vr(), wr("div", d_, fp(t.description), 1)) : Hs("", !0)])]), t.isSlotPassed ? (vr(), wr("div", p_, [Qw(t.$slots, "default")])) : Hs("", !0), t.showCloseButton ? (vr(), wr("div", {
            key: 1,
            class: "mosha__toast__close-icon",
            onClick: e[1] || (e[1] = (...f) => t.onCloseHandler && t.onCloseHandler(...f))
        })) : Hs("", !0), t.hideProgressBar ? Hs("", !0) : (vr(), wr("div", {
            key: 2,
            class: "mosha__toast__progress",
            style: {
                width: `${t.progress}%`
            }
        }, null, 4))], 38)) : Hs("", !0)]),
        _: 3
    }, 8, ["name"])
};
const ul = {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": [],
    "top-center": [],
    "bottom-center": []
};
let m_ = 0;
const BS = (t, e) => {
        const r = m_++,
            n = e ? y_(e) : uf;
        if (t.__v_isVNode) return Dh(r, no.VNODE, n, t), {
            close: () => ia(r, n.position)
        };
        if (t.hasOwnProperty("render")) return Dh(r, no.COMPONENT, n, t), {
            close: () => ia(r, n.position)
        };
        const i = g_(t);
        return Dh(r, no.TITLE_DESCRIPTION, n, i), {
            close: () => ia(r, n.position)
        }
    },
    Dh = (t, e, r, n) => {
        setTimeout(() => {
            const i = x_(r, ul, 12),
                s = document.createElement("div");
            let o;
            document.body.appendChild(s), o = e === no.VNODE ? _t(fl, Uh(r, t, i, ia), () => [n]) : e === no.TITLE_DESCRIPTION ? _t(fl, Uh(r, t, i, ia, n)) : _t(fl, Uh(r, t, i, ia), () => [_t(n)]), yu(o, s), ul[r.position].push({
                toastVNode: o,
                container: s
            }), o.component && (o.component.props.visible = !0)
        }, 1)
    },
    Uh = (t, e, r, n, i) => Fh(ki(ki({}, t), i), {
        id: e,
        offset: r,
        visible: !1,
        onCloseHandler: () => {
            n(e, t.position ? t.position : "top-right")
        }
    }),
    y_ = t => {
        const e = Fh(ki({}, t), {
            type: t.type || uf.type,
            timeout: t.timeout || uf.timeout,
            showCloseButton: t.showCloseButton,
            position: t.position || uf.position,
            showIcon: t.showIcon,
            swipeClose: t.swipeClose,
            transition: t.transition || uf.transition
        });
        return e.hideProgressBar = e.timeout !== void 0 && e.timeout <= 0, t.hideProgressBar !== void 0 && (e.hideProgressBar = t.hideProgressBar), e
    },
    g_ = t => ({
        text: typeof t == "string" ? t : t.title,
        description: typeof t == "string" ? void 0 : t.description
    }),
    x_ = (t, e, r) => {
        let n = r;
        if (!t.position) throw new Error("no position");
        return e[t.position].forEach(({
            toastVNode: i
        }) => {
            n += i.el.offsetHeight + r || 0
        }), n
    },
    ia = (t, e) => {
        const r = ul[e],
            n = r.findIndex(({
                toastVNode: f
            }) => f.props && t === f.props.id);
        if (n === -1) return;
        const {
            container: i,
            toastVNode: s
        } = r[n];
        if (!s.el) return;
        const o = s.el.offsetHeight;
        ul[e].splice(n, 1), ((f, l, d, p) => {
            for (let A = f; A < l.length; A++) {
                const {
                    toastVNode: T
                } = l[A];
                if (!T.el) return;
                const N = d.split("-")[0] || "top",
                    P = parseInt(T.el.style[N], 10) - p - 12;
                if (!T.component) return;
                T.component.props.offset = P
            }
        })(n, r, e, o), s.component && (s.component.props.visible = !1, s.component.props.onClose && s.component.props.onClose(), setTimeout(() => {
            yu(null, i), document.body.removeChild(i)
        }, 1e3))
    };
var b_ = !0,
    Lh = "Invariant failed";

function Bh(t, e) {
    if (!t) {
        if (b_) throw new Error(Lh);
        var r = typeof e == "function" ? e() : e,
            n = r ? "".concat(Lh, ": ").concat(r) : Lh;
        throw new Error(n)
    }
}

function v_(t, e) {
    for (var r = -1, n = e.length, i = t.length; ++r < n;) t[i + r] = e[r];
    return t
}
var w_ = typeof global == "object" && global && global.Object === Object && global,
    E_ = w_,
    A_ = typeof self == "object" && self && self.Object === Object && self,
    __ = E_ || A_ || Function("return this")(),
    T_ = __,
    M_ = T_.Symbol,
    sa = M_,
    f1 = Object.prototype,
    N_ = f1.hasOwnProperty,
    S_ = f1.toString,
    lf = sa ? sa.toStringTag : void 0;

function P_(t) {
    var e = N_.call(t, lf),
        r = t[lf];
    try {
        t[lf] = void 0;
        var n = !0
    } catch {}
    var i = S_.call(t);
    return n && (e ? t[lf] = r : delete t[lf]), i
}
var I_ = Object.prototype,
    R_ = I_.toString;

function k_(t) {
    return R_.call(t)
}
var O_ = "[object Null]",
    C_ = "[object Undefined]",
    u1 = sa ? sa.toStringTag : void 0;

function F_(t) {
    return t == null ? t === void 0 ? C_ : O_ : u1 && u1 in Object(t) ? P_(t) : k_(t)
}

function l1(t) {
    return t != null && typeof t == "object"
}
var D_ = "[object Arguments]";

function c1(t) {
    return l1(t) && F_(t) == D_
}
var h1 = Object.prototype,
    U_ = h1.hasOwnProperty,
    L_ = h1.propertyIsEnumerable,
    B_ = c1(function() {
        return arguments
    }()) ? c1 : function(t) {
        return l1(t) && U_.call(t, "callee") && !L_.call(t, "callee")
    },
    $_ = B_,
    G_ = Array.isArray,
    z_ = G_,
    d1 = sa ? sa.isConcatSpreadable : void 0;

function H_(t) {
    return z_(t) || $_(t) || !!(d1 && t && t[d1])
}

function p1(t, e, r, n, i) {
    var s = -1,
        o = t.length;
    for (r || (r = H_), i || (i = []); ++s < o;) {
        var f = t[s];
        e > 0 && r(f) ? e > 1 ? p1(f, e - 1, r, n, i) : v_(i, f) : n || (i[i.length] = f)
    }
    return i
}

function q_(t) {
    var e = t == null ? 0 : t.length;
    return e ? p1(t, 1) : []
}
const j_ = "logger/5.7.0";
let m1 = !1,
    y1 = !1;
const ll = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let g1 = ll.default,
    $h = null;

function W_() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const x1 = W_();
var Gh;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(Gh || (Gh = {}));
var Jn;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(Jn || (Jn = {}));
const b1 = "0123456789abcdef";
class Bt {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        ll[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(g1 > ll[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(Bt.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Bt.levels.INFO, e)
    }
    warn(...e) {
        this._log(Bt.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (y1) return this.makeError("censored error", r, {});
        r || (r = Bt.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += b1[d[A] >> 4], p += b1[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case Jn.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case Jn.CALL_EXCEPTION:
            case Jn.INSUFFICIENT_FUNDS:
            case Jn.MISSING_NEW:
            case Jn.NONCE_EXPIRED:
            case Jn.REPLACEMENT_UNDERPRICED:
            case Jn.TRANSACTION_REPLACED:
            case Jn.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, Bt.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        x1 && this.throwError("platform missing String.prototype.normalize", Bt.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: x1
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Bt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, Bt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Bt.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, Bt.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", Bt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Bt.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", Bt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return $h || ($h = new Bt(j_)), $h
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Bt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), m1) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", Bt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        y1 = !!e, m1 = !!r
    }
    static setLogLevel(e) {
        const r = ll[e.toLowerCase()];
        if (r == null) {
            Bt.globalLogger().warn("invalid log level - " + e);
            return
        }
        g1 = r
    }
    static from(e) {
        return new Bt(e)
    }
}
Bt.errors = Jn;
Bt.levels = Gh;
const V_ = "bytes/5.7.0",
    qt = new Bt(V_);

function v1(t) {
    return !!t.toHexString
}

function oa(t) {
    return t.slice || (t.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return oa(new Uint8Array(Array.prototype.slice.apply(t, e)))
    }), t
}

function w1(t) {
    return $t(t) && !(t.length % 2) || cl(t)
}

function E1(t) {
    return typeof t == "number" && t == t && t % 1 == 0
}

function cl(t) {
    if (t == null) return !1;
    if (t.constructor === Uint8Array) return !0;
    if (typeof t == "string" || !E1(t.length) || t.length < 0) return !1;
    for (let e = 0; e < t.length; e++) {
        const r = t[e];
        if (!E1(r) || r < 0 || r >= 256) return !1
    }
    return !0
}

function ze(t, e) {
    if (e || (e = {}), typeof t == "number") {
        qt.checkSafeUint53(t, "invalid arrayify value");
        const r = [];
        for (; t;) r.unshift(t & 255), t = parseInt(String(t / 256));
        return r.length === 0 && r.push(0), oa(new Uint8Array(r))
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), v1(t) && (t = t.toHexString()), $t(t)) {
        let r = t.substring(2);
        r.length % 2 && (e.hexPad === "left" ? r = "0" + r : e.hexPad === "right" ? r += "0" : qt.throwArgumentError("hex data is odd-length", "value", t));
        const n = [];
        for (let i = 0; i < r.length; i += 2) n.push(parseInt(r.substring(i, i + 2), 16));
        return oa(new Uint8Array(n))
    }
    return cl(t) ? oa(new Uint8Array(t)) : qt.throwArgumentError("invalid arrayify value", "value", t)
}

function io(t) {
    const e = t.map(i => ze(i)),
        r = e.reduce((i, s) => i + s.length, 0),
        n = new Uint8Array(r);
    return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), oa(n)
}

function K_(t) {
    let e = ze(t);
    if (e.length === 0) return e;
    let r = 0;
    for (; r < e.length && e[r] === 0;) r++;
    return r && (e = e.slice(r)), e
}

function X_(t, e) {
    t = ze(t), t.length > e && qt.throwArgumentError("value out of range", "value", arguments[0]);
    const r = new Uint8Array(e);
    return r.set(t, e - t.length), oa(r)
}

function $t(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e)
}
const zh = "0123456789abcdef";

function nt(t, e) {
    if (e || (e = {}), typeof t == "number") {
        qt.checkSafeUint53(t, "invalid hexlify value");
        let r = "";
        for (; t;) r = zh[t & 15] + r, t = Math.floor(t / 16);
        return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00"
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), v1(t)) return t.toHexString();
    if ($t(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : qt.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (cl(t)) {
        let r = "0x";
        for (let n = 0; n < t.length; n++) {
            let i = t[n];
            r += zh[(i & 240) >> 4] + zh[i & 15]
        }
        return r
    }
    return qt.throwArgumentError("invalid hexlify value", "value", t)
}

function hl(t) {
    if (typeof t != "string") t = nt(t);
    else if (!$t(t) || t.length % 2) return null;
    return (t.length - 2) / 2
}

function Ir(t, e, r) {
    return typeof t != "string" ? t = nt(t) : (!$t(t) || t.length % 2) && qt.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, r != null ? "0x" + t.substring(e, 2 + 2 * r) : "0x" + t.substring(e)
}

function pn(t) {
    let e = "0x";
    return t.forEach(r => {
        e += nt(r).substring(2)
    }), e
}

function mn(t, e) {
    for (typeof t != "string" ? t = nt(t) : $t(t) || qt.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && qt.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2;) t = "0x0" + t.substring(2);
    return t
}

function dl(t) {
    const e = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (w1(t)) {
        let r = ze(t);
        r.length === 64 ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = nt(r.slice(0, 32)), e.s = nt(r.slice(32, 64))) : r.length === 65 ? (e.r = nt(r.slice(0, 32)), e.s = nt(r.slice(32, 64)), e.v = r[64]) : qt.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : qt.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = nt(r.slice(32, 64))
    } else {
        if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
            const i = X_(ze(e._vs), 32);
            e._vs = nt(i);
            const s = i[0] >= 128 ? 1 : 0;
            e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && qt.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
            const o = nt(i);
            e.s == null ? e.s = o : e.s !== o && qt.throwArgumentError("signature v mismatch _vs", "signature", t)
        }
        if (e.recoveryParam == null) e.v == null ? qt.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
        else if (e.v == null) e.v = 27 + e.recoveryParam;
        else {
            const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
            e.recoveryParam !== i && qt.throwArgumentError("signature recoveryParam mismatch v", "signature", t)
        }
        e.r == null || !$t(e.r) ? qt.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = mn(e.r, 32), e.s == null || !$t(e.s) ? qt.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = mn(e.s, 32);
        const r = ze(e.s);
        r[0] >= 128 && qt.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
        const n = nt(r);
        e._vs && ($t(e._vs) || qt.throwArgumentError("signature invalid _vs", "signature", t), e._vs = mn(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && qt.throwArgumentError("signature _vs mismatch v and s", "signature", t)
    }
    return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e
}

function J_(t) {
    return t = dl(t), nt(io([t.r, t.s, t.recoveryParam ? "0x1c" : "0x1b"]))
}
var A1 = {
    exports: {}
};
(function(t) {
    (function(e, r) {
        function n(m, a) {
            if (!m) throw new Error(a || "Assertion failed")
        }

        function i(m, a) {
            m.super_ = a;
            var c = function() {};
            c.prototype = a.prototype, m.prototype = new c, m.prototype.constructor = m
        }

        function s(m, a, c) {
            if (s.isBN(m)) return m;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((a === "le" || a === "be") && (c = a, a = 10), this._init(m || 0, a || 10, c || "be"))
        }
        typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
        var o;
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = require("buffer").Buffer
        } catch {}
        s.isBN = function(a) {
            return a instanceof s ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words)
        }, s.max = function(a, c) {
            return a.cmp(c) > 0 ? a : c
        }, s.min = function(a, c) {
            return a.cmp(c) < 0 ? a : c
        }, s.prototype._init = function(a, c, g) {
            if (typeof a == "number") return this._initNumber(a, c, g);
            if (typeof a == "object") return this._initArray(a, c, g);
            c === "hex" && (c = 16), n(c === (c | 0) && c >= 2 && c <= 36), a = a.toString().replace(/\s+/g, "");
            var v = 0;
            a[0] === "-" && (v++, this.negative = 1), v < a.length && (c === 16 ? this._parseHex(a, v, g) : (this._parseBase(a, c, v), g === "le" && this._initArray(this.toArray(), c, g)))
        }, s.prototype._initNumber = function(a, c, g) {
            a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [a & 67108863, a / 67108864 & 67108863], this.length = 2) : (n(a < 9007199254740992), this.words = [a & 67108863, a / 67108864 & 67108863, 1], this.length = 3), g === "le" && this._initArray(this.toArray(), c, g)
        }, s.prototype._initArray = function(a, c, g) {
            if (n(typeof a.length == "number"), a.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
            for (var v = 0; v < this.length; v++) this.words[v] = 0;
            var x, b, y = 0;
            if (g === "be")
                for (v = a.length - 1, x = 0; v >= 0; v -= 3) b = a[v] | a[v - 1] << 8 | a[v - 2] << 16, this.words[x] |= b << y & 67108863, this.words[x + 1] = b >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, x++);
            else if (g === "le")
                for (v = 0, x = 0; v < a.length; v += 3) b = a[v] | a[v + 1] << 8 | a[v + 2] << 16, this.words[x] |= b << y & 67108863, this.words[x + 1] = b >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, x++);
            return this._strip()
        };

        function f(m, a) {
            var c = m.charCodeAt(a);
            if (c >= 48 && c <= 57) return c - 48;
            if (c >= 65 && c <= 70) return c - 55;
            if (c >= 97 && c <= 102) return c - 87;
            n(!1, "Invalid character in " + m)
        }

        function l(m, a, c) {
            var g = f(m, c);
            return c - 1 >= a && (g |= f(m, c - 1) << 4), g
        }
        s.prototype._parseHex = function(a, c, g) {
            this.length = Math.ceil((a.length - c) / 6), this.words = new Array(this.length);
            for (var v = 0; v < this.length; v++) this.words[v] = 0;
            var x = 0,
                b = 0,
                y;
            if (g === "be")
                for (v = a.length - 1; v >= c; v -= 2) y = l(a, c, v) << x, this.words[b] |= y & 67108863, x >= 18 ? (x -= 18, b += 1, this.words[b] |= y >>> 26) : x += 8;
            else {
                var h = a.length - c;
                for (v = h % 2 == 0 ? c + 1 : c; v < a.length; v += 2) y = l(a, c, v) << x, this.words[b] |= y & 67108863, x >= 18 ? (x -= 18, b += 1, this.words[b] |= y >>> 26) : x += 8
            }
            this._strip()
        };

        function d(m, a, c, g) {
            for (var v = 0, x = 0, b = Math.min(m.length, c), y = a; y < b; y++) {
                var h = m.charCodeAt(y) - 48;
                v *= g, h >= 49 ? x = h - 49 + 10 : h >= 17 ? x = h - 17 + 10 : x = h, n(h >= 0 && x < g, "Invalid character"), v += x
            }
            return v
        }
        s.prototype._parseBase = function(a, c, g) {
            this.words = [0], this.length = 1;
            for (var v = 0, x = 1; x <= 67108863; x *= c) v++;
            v--, x = x / c | 0;
            for (var b = a.length - g, y = b % v, h = Math.min(b, b - y) + g, u = 0, _ = g; _ < h; _ += v) u = d(a, _, _ + v, c), this.imuln(x), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
            if (y !== 0) {
                var L = 1;
                for (u = d(a, _, a.length, c), _ = 0; _ < y; _++) L *= c;
                this.imuln(L), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u)
            }
            this._strip()
        }, s.prototype.copy = function(a) {
            a.words = new Array(this.length);
            for (var c = 0; c < this.length; c++) a.words[c] = this.words[c];
            a.length = this.length, a.negative = this.negative, a.red = this.red
        };

        function p(m, a) {
            m.words = a.words, m.length = a.length, m.negative = a.negative, m.red = a.red
        }
        if (s.prototype._move = function(a) {
                p(a, this)
            }, s.prototype.clone = function() {
                var a = new s(null);
                return this.copy(a), a
            }, s.prototype._expand = function(a) {
                for (; this.length < a;) this.words[this.length++] = 0;
                return this
            }, s.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, s.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, typeof Symbol != "undefined" && typeof Symbol.for == "function") try {
            s.prototype[Symbol.for("nodejs.util.inspect.custom")] = A
        } catch {
            s.prototype.inspect = A
        } else s.prototype.inspect = A;

        function A() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var T = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            N = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            P = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(a, c) {
            a = a || 10, c = c | 0 || 1;
            var g;
            if (a === 16 || a === "hex") {
                g = "";
                for (var v = 0, x = 0, b = 0; b < this.length; b++) {
                    var y = this.words[b],
                        h = ((y << v | x) & 16777215).toString(16);
                    x = y >>> 24 - v & 16777215, v += 2, v >= 26 && (v -= 26, b--), x !== 0 || b !== this.length - 1 ? g = T[6 - h.length] + h + g : g = h + g
                }
                for (x !== 0 && (g = x.toString(16) + g); g.length % c != 0;) g = "0" + g;
                return this.negative !== 0 && (g = "-" + g), g
            }
            if (a === (a | 0) && a >= 2 && a <= 36) {
                var u = N[a],
                    _ = P[a];
                g = "";
                var L = this.clone();
                for (L.negative = 0; !L.isZero();) {
                    var E = L.modrn(_).toString(a);
                    L = L.idivn(_), L.isZero() ? g = E + g : g = T[u - E.length] + E + g
                }
                for (this.isZero() && (g = "0" + g); g.length % c != 0;) g = "0" + g;
                return this.negative !== 0 && (g = "-" + g), g
            }
            n(!1, "Base should be between 2 and 36")
        }, s.prototype.toNumber = function() {
            var a = this.words[0];
            return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a
        }, s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }, o && (s.prototype.toBuffer = function(a, c) {
            return this.toArrayLike(o, a, c)
        }), s.prototype.toArray = function(a, c) {
            return this.toArrayLike(Array, a, c)
        };
        var C = function(a, c) {
            return a.allocUnsafe ? a.allocUnsafe(c) : new a(c)
        };
        s.prototype.toArrayLike = function(a, c, g) {
            this._strip();
            var v = this.byteLength(),
                x = g || Math.max(1, v);
            n(v <= x, "byte array longer than desired length"), n(x > 0, "Requested array length <= 0");
            var b = C(a, x),
                y = c === "le" ? "LE" : "BE";
            return this["_toArrayLike" + y](b, v), b
        }, s.prototype._toArrayLikeLE = function(a, c) {
            for (var g = 0, v = 0, x = 0, b = 0; x < this.length; x++) {
                var y = this.words[x] << b | v;
                a[g++] = y & 255, g < a.length && (a[g++] = y >> 8 & 255), g < a.length && (a[g++] = y >> 16 & 255), b === 6 ? (g < a.length && (a[g++] = y >> 24 & 255), v = 0, b = 0) : (v = y >>> 24, b += 2)
            }
            if (g < a.length)
                for (a[g++] = v; g < a.length;) a[g++] = 0
        }, s.prototype._toArrayLikeBE = function(a, c) {
            for (var g = a.length - 1, v = 0, x = 0, b = 0; x < this.length; x++) {
                var y = this.words[x] << b | v;
                a[g--] = y & 255, g >= 0 && (a[g--] = y >> 8 & 255), g >= 0 && (a[g--] = y >> 16 & 255), b === 6 ? (g >= 0 && (a[g--] = y >> 24 & 255), v = 0, b = 0) : (v = y >>> 24, b += 2)
            }
            if (g >= 0)
                for (a[g--] = v; g >= 0;) a[g--] = 0
        }, Math.clz32 ? s.prototype._countBits = function(a) {
            return 32 - Math.clz32(a)
        } : s.prototype._countBits = function(a) {
            var c = a,
                g = 0;
            return c >= 4096 && (g += 13, c >>>= 13), c >= 64 && (g += 7, c >>>= 7), c >= 8 && (g += 4, c >>>= 4), c >= 2 && (g += 2, c >>>= 2), g + c
        }, s.prototype._zeroBits = function(a) {
            if (a === 0) return 26;
            var c = a,
                g = 0;
            return (c & 8191) == 0 && (g += 13, c >>>= 13), (c & 127) == 0 && (g += 7, c >>>= 7), (c & 15) == 0 && (g += 4, c >>>= 4), (c & 3) == 0 && (g += 2, c >>>= 2), (c & 1) == 0 && g++, g
        }, s.prototype.bitLength = function() {
            var a = this.words[this.length - 1],
                c = this._countBits(a);
            return (this.length - 1) * 26 + c
        };

        function S(m) {
            for (var a = new Array(m.bitLength()), c = 0; c < a.length; c++) {
                var g = c / 26 | 0,
                    v = c % 26;
                a[c] = m.words[g] >>> v & 1
            }
            return a
        }
        s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var a = 0, c = 0; c < this.length; c++) {
                var g = this._zeroBits(this.words[c]);
                if (a += g, g !== 26) break
            }
            return a
        }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, s.prototype.toTwos = function(a) {
            return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone()
        }, s.prototype.fromTwos = function(a) {
            return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone()
        }, s.prototype.isNeg = function() {
            return this.negative !== 0
        }, s.prototype.neg = function() {
            return this.clone().ineg()
        }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, s.prototype.iuor = function(a) {
            for (; this.length < a.length;) this.words[this.length++] = 0;
            for (var c = 0; c < a.length; c++) this.words[c] = this.words[c] | a.words[c];
            return this._strip()
        }, s.prototype.ior = function(a) {
            return n((this.negative | a.negative) == 0), this.iuor(a)
        }, s.prototype.or = function(a) {
            return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this)
        }, s.prototype.uor = function(a) {
            return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this)
        }, s.prototype.iuand = function(a) {
            var c;
            this.length > a.length ? c = a : c = this;
            for (var g = 0; g < c.length; g++) this.words[g] = this.words[g] & a.words[g];
            return this.length = c.length, this._strip()
        }, s.prototype.iand = function(a) {
            return n((this.negative | a.negative) == 0), this.iuand(a)
        }, s.prototype.and = function(a) {
            return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this)
        }, s.prototype.uand = function(a) {
            return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this)
        }, s.prototype.iuxor = function(a) {
            var c, g;
            this.length > a.length ? (c = this, g = a) : (c = a, g = this);
            for (var v = 0; v < g.length; v++) this.words[v] = c.words[v] ^ g.words[v];
            if (this !== c)
                for (; v < c.length; v++) this.words[v] = c.words[v];
            return this.length = c.length, this._strip()
        }, s.prototype.ixor = function(a) {
            return n((this.negative | a.negative) == 0), this.iuxor(a)
        }, s.prototype.xor = function(a) {
            return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this)
        }, s.prototype.uxor = function(a) {
            return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this)
        }, s.prototype.inotn = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = Math.ceil(a / 26) | 0,
                g = a % 26;
            this._expand(c), g > 0 && c--;
            for (var v = 0; v < c; v++) this.words[v] = ~this.words[v] & 67108863;
            return g > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - g), this._strip()
        }, s.prototype.notn = function(a) {
            return this.clone().inotn(a)
        }, s.prototype.setn = function(a, c) {
            n(typeof a == "number" && a >= 0);
            var g = a / 26 | 0,
                v = a % 26;
            return this._expand(g + 1), c ? this.words[g] = this.words[g] | 1 << v : this.words[g] = this.words[g] & ~(1 << v), this._strip()
        }, s.prototype.iadd = function(a) {
            var c;
            if (this.negative !== 0 && a.negative === 0) return this.negative = 0, c = this.isub(a), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && a.negative !== 0) return a.negative = 0, c = this.isub(a), a.negative = 1, c._normSign();
            var g, v;
            this.length > a.length ? (g = this, v = a) : (g = a, v = this);
            for (var x = 0, b = 0; b < v.length; b++) c = (g.words[b] | 0) + (v.words[b] | 0) + x, this.words[b] = c & 67108863, x = c >>> 26;
            for (; x !== 0 && b < g.length; b++) c = (g.words[b] | 0) + x, this.words[b] = c & 67108863, x = c >>> 26;
            if (this.length = g.length, x !== 0) this.words[this.length] = x, this.length++;
            else if (g !== this)
                for (; b < g.length; b++) this.words[b] = g.words[b];
            return this
        }, s.prototype.add = function(a) {
            var c;
            return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, c = this.sub(a), a.negative ^= 1, c) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, c = a.sub(this), this.negative = 1, c) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this)
        }, s.prototype.isub = function(a) {
            if (a.negative !== 0) {
                a.negative = 0;
                var c = this.iadd(a);
                return a.negative = 1, c._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
            var g = this.cmp(a);
            if (g === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var v, x;
            g > 0 ? (v = this, x = a) : (v = a, x = this);
            for (var b = 0, y = 0; y < x.length; y++) c = (v.words[y] | 0) - (x.words[y] | 0) + b, b = c >> 26, this.words[y] = c & 67108863;
            for (; b !== 0 && y < v.length; y++) c = (v.words[y] | 0) + b, b = c >> 26, this.words[y] = c & 67108863;
            if (b === 0 && y < v.length && v !== this)
                for (; y < v.length; y++) this.words[y] = v.words[y];
            return this.length = Math.max(this.length, y), v !== this && (this.negative = 1), this._strip()
        }, s.prototype.sub = function(a) {
            return this.clone().isub(a)
        };

        function k(m, a, c) {
            c.negative = a.negative ^ m.negative;
            var g = m.length + a.length | 0;
            c.length = g, g = g - 1 | 0;
            var v = m.words[0] | 0,
                x = a.words[0] | 0,
                b = v * x,
                y = b & 67108863,
                h = b / 67108864 | 0;
            c.words[0] = y;
            for (var u = 1; u < g; u++) {
                for (var _ = h >>> 26, L = h & 67108863, E = Math.min(u, a.length - 1), R = Math.max(0, u - m.length + 1); R <= E; R++) {
                    var G = u - R | 0;
                    v = m.words[G] | 0, x = a.words[R] | 0, b = v * x + L, _ += b / 67108864 | 0, L = b & 67108863
                }
                c.words[u] = L | 0, h = _ | 0
            }
            return h !== 0 ? c.words[u] = h | 0 : c.length--, c._strip()
        }
        var I = function(a, c, g) {
            var v = a.words,
                x = c.words,
                b = g.words,
                y = 0,
                h, u, _, L = v[0] | 0,
                E = L & 8191,
                R = L >>> 13,
                G = v[1] | 0,
                z = G & 8191,
                j = G >>> 13,
                re = v[2] | 0,
                ee = re & 8191,
                K = re >>> 13,
                B = v[3] | 0,
                $ = B & 8191,
                H = B >>> 13,
                ne = v[4] | 0,
                J = ne & 8191,
                Y = ne >>> 13,
                ue = v[5] | 0,
                te = ue & 8191,
                Z = ue >>> 13,
                se = v[6] | 0,
                fe = se & 8191,
                ie = se >>> 13,
                me = v[7] | 0,
                he = me & 8191,
                le = me >>> 13,
                Pe = v[8] | 0,
                xe = Pe & 8191,
                de = Pe >>> 13,
                je = v[9] | 0,
                Ie = je & 8191,
                be = je >>> 13,
                X = x[0] | 0,
                ae = X & 8191,
                oe = X >>> 13,
                ve = x[1] | 0,
                ye = ve & 8191,
                ge = ve >>> 13,
                Ve = x[2] | 0,
                ke = Ve & 8191,
                Ae = Ve >>> 13,
                et = x[3] | 0,
                Oe = et & 8191,
                we = et >>> 13,
                rt = x[4] | 0,
                Fe = rt & 8191,
                Ee = rt >>> 13,
                it = x[5] | 0,
                Le = it & 8191,
                _e = it >>> 13,
                bt = x[6] | 0,
                Be = bt & 8191,
                Te = bt >>> 13,
                vt = x[7] | 0,
                $e = vt & 8191,
                Me = vt >>> 13,
                wt = x[8] | 0,
                Ge = wt & 8191,
                Ne = wt >>> 13,
                Et = x[9] | 0,
                De = Et & 8191,
                Ue = Et >>> 13;
            g.negative = a.negative ^ c.negative, g.length = 19, h = Math.imul(E, ae), u = Math.imul(E, oe), u = u + Math.imul(R, ae) | 0, _ = Math.imul(R, oe);
            var pr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, h = Math.imul(z, ae), u = Math.imul(z, oe), u = u + Math.imul(j, ae) | 0, _ = Math.imul(j, oe), h = h + Math.imul(E, ye) | 0, u = u + Math.imul(E, ge) | 0, u = u + Math.imul(R, ye) | 0, _ = _ + Math.imul(R, ge) | 0;
            var mr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (mr >>> 26) | 0, mr &= 67108863, h = Math.imul(ee, ae), u = Math.imul(ee, oe), u = u + Math.imul(K, ae) | 0, _ = Math.imul(K, oe), h = h + Math.imul(z, ye) | 0, u = u + Math.imul(z, ge) | 0, u = u + Math.imul(j, ye) | 0, _ = _ + Math.imul(j, ge) | 0, h = h + Math.imul(E, ke) | 0, u = u + Math.imul(E, Ae) | 0, u = u + Math.imul(R, ke) | 0, _ = _ + Math.imul(R, Ae) | 0;
            var yr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, h = Math.imul($, ae), u = Math.imul($, oe), u = u + Math.imul(H, ae) | 0, _ = Math.imul(H, oe), h = h + Math.imul(ee, ye) | 0, u = u + Math.imul(ee, ge) | 0, u = u + Math.imul(K, ye) | 0, _ = _ + Math.imul(K, ge) | 0, h = h + Math.imul(z, ke) | 0, u = u + Math.imul(z, Ae) | 0, u = u + Math.imul(j, ke) | 0, _ = _ + Math.imul(j, Ae) | 0, h = h + Math.imul(E, Oe) | 0, u = u + Math.imul(E, we) | 0, u = u + Math.imul(R, Oe) | 0, _ = _ + Math.imul(R, we) | 0;
            var gr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, h = Math.imul(J, ae), u = Math.imul(J, oe), u = u + Math.imul(Y, ae) | 0, _ = Math.imul(Y, oe), h = h + Math.imul($, ye) | 0, u = u + Math.imul($, ge) | 0, u = u + Math.imul(H, ye) | 0, _ = _ + Math.imul(H, ge) | 0, h = h + Math.imul(ee, ke) | 0, u = u + Math.imul(ee, Ae) | 0, u = u + Math.imul(K, ke) | 0, _ = _ + Math.imul(K, Ae) | 0, h = h + Math.imul(z, Oe) | 0, u = u + Math.imul(z, we) | 0, u = u + Math.imul(j, Oe) | 0, _ = _ + Math.imul(j, we) | 0, h = h + Math.imul(E, Fe) | 0, u = u + Math.imul(E, Ee) | 0, u = u + Math.imul(R, Fe) | 0, _ = _ + Math.imul(R, Ee) | 0;
            var xr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, h = Math.imul(te, ae), u = Math.imul(te, oe), u = u + Math.imul(Z, ae) | 0, _ = Math.imul(Z, oe), h = h + Math.imul(J, ye) | 0, u = u + Math.imul(J, ge) | 0, u = u + Math.imul(Y, ye) | 0, _ = _ + Math.imul(Y, ge) | 0, h = h + Math.imul($, ke) | 0, u = u + Math.imul($, Ae) | 0, u = u + Math.imul(H, ke) | 0, _ = _ + Math.imul(H, Ae) | 0, h = h + Math.imul(ee, Oe) | 0, u = u + Math.imul(ee, we) | 0, u = u + Math.imul(K, Oe) | 0, _ = _ + Math.imul(K, we) | 0, h = h + Math.imul(z, Fe) | 0, u = u + Math.imul(z, Ee) | 0, u = u + Math.imul(j, Fe) | 0, _ = _ + Math.imul(j, Ee) | 0, h = h + Math.imul(E, Le) | 0, u = u + Math.imul(E, _e) | 0, u = u + Math.imul(R, Le) | 0, _ = _ + Math.imul(R, _e) | 0;
            var Tn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Tn >>> 26) | 0, Tn &= 67108863, h = Math.imul(fe, ae), u = Math.imul(fe, oe), u = u + Math.imul(ie, ae) | 0, _ = Math.imul(ie, oe), h = h + Math.imul(te, ye) | 0, u = u + Math.imul(te, ge) | 0, u = u + Math.imul(Z, ye) | 0, _ = _ + Math.imul(Z, ge) | 0, h = h + Math.imul(J, ke) | 0, u = u + Math.imul(J, Ae) | 0, u = u + Math.imul(Y, ke) | 0, _ = _ + Math.imul(Y, Ae) | 0, h = h + Math.imul($, Oe) | 0, u = u + Math.imul($, we) | 0, u = u + Math.imul(H, Oe) | 0, _ = _ + Math.imul(H, we) | 0, h = h + Math.imul(ee, Fe) | 0, u = u + Math.imul(ee, Ee) | 0, u = u + Math.imul(K, Fe) | 0, _ = _ + Math.imul(K, Ee) | 0, h = h + Math.imul(z, Le) | 0, u = u + Math.imul(z, _e) | 0, u = u + Math.imul(j, Le) | 0, _ = _ + Math.imul(j, _e) | 0, h = h + Math.imul(E, Be) | 0, u = u + Math.imul(E, Te) | 0, u = u + Math.imul(R, Be) | 0, _ = _ + Math.imul(R, Te) | 0;
            var Mn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, h = Math.imul(he, ae), u = Math.imul(he, oe), u = u + Math.imul(le, ae) | 0, _ = Math.imul(le, oe), h = h + Math.imul(fe, ye) | 0, u = u + Math.imul(fe, ge) | 0, u = u + Math.imul(ie, ye) | 0, _ = _ + Math.imul(ie, ge) | 0, h = h + Math.imul(te, ke) | 0, u = u + Math.imul(te, Ae) | 0, u = u + Math.imul(Z, ke) | 0, _ = _ + Math.imul(Z, Ae) | 0, h = h + Math.imul(J, Oe) | 0, u = u + Math.imul(J, we) | 0, u = u + Math.imul(Y, Oe) | 0, _ = _ + Math.imul(Y, we) | 0, h = h + Math.imul($, Fe) | 0, u = u + Math.imul($, Ee) | 0, u = u + Math.imul(H, Fe) | 0, _ = _ + Math.imul(H, Ee) | 0, h = h + Math.imul(ee, Le) | 0, u = u + Math.imul(ee, _e) | 0, u = u + Math.imul(K, Le) | 0, _ = _ + Math.imul(K, _e) | 0, h = h + Math.imul(z, Be) | 0, u = u + Math.imul(z, Te) | 0, u = u + Math.imul(j, Be) | 0, _ = _ + Math.imul(j, Te) | 0, h = h + Math.imul(E, $e) | 0, u = u + Math.imul(E, Me) | 0, u = u + Math.imul(R, $e) | 0, _ = _ + Math.imul(R, Me) | 0;
            var Nn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, h = Math.imul(xe, ae), u = Math.imul(xe, oe), u = u + Math.imul(de, ae) | 0, _ = Math.imul(de, oe), h = h + Math.imul(he, ye) | 0, u = u + Math.imul(he, ge) | 0, u = u + Math.imul(le, ye) | 0, _ = _ + Math.imul(le, ge) | 0, h = h + Math.imul(fe, ke) | 0, u = u + Math.imul(fe, Ae) | 0, u = u + Math.imul(ie, ke) | 0, _ = _ + Math.imul(ie, Ae) | 0, h = h + Math.imul(te, Oe) | 0, u = u + Math.imul(te, we) | 0, u = u + Math.imul(Z, Oe) | 0, _ = _ + Math.imul(Z, we) | 0, h = h + Math.imul(J, Fe) | 0, u = u + Math.imul(J, Ee) | 0, u = u + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(Y, Ee) | 0, h = h + Math.imul($, Le) | 0, u = u + Math.imul($, _e) | 0, u = u + Math.imul(H, Le) | 0, _ = _ + Math.imul(H, _e) | 0, h = h + Math.imul(ee, Be) | 0, u = u + Math.imul(ee, Te) | 0, u = u + Math.imul(K, Be) | 0, _ = _ + Math.imul(K, Te) | 0, h = h + Math.imul(z, $e) | 0, u = u + Math.imul(z, Me) | 0, u = u + Math.imul(j, $e) | 0, _ = _ + Math.imul(j, Me) | 0, h = h + Math.imul(E, Ge) | 0, u = u + Math.imul(E, Ne) | 0, u = u + Math.imul(R, Ge) | 0, _ = _ + Math.imul(R, Ne) | 0;
            var Sn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, h = Math.imul(Ie, ae), u = Math.imul(Ie, oe), u = u + Math.imul(be, ae) | 0, _ = Math.imul(be, oe), h = h + Math.imul(xe, ye) | 0, u = u + Math.imul(xe, ge) | 0, u = u + Math.imul(de, ye) | 0, _ = _ + Math.imul(de, ge) | 0, h = h + Math.imul(he, ke) | 0, u = u + Math.imul(he, Ae) | 0, u = u + Math.imul(le, ke) | 0, _ = _ + Math.imul(le, Ae) | 0, h = h + Math.imul(fe, Oe) | 0, u = u + Math.imul(fe, we) | 0, u = u + Math.imul(ie, Oe) | 0, _ = _ + Math.imul(ie, we) | 0, h = h + Math.imul(te, Fe) | 0, u = u + Math.imul(te, Ee) | 0, u = u + Math.imul(Z, Fe) | 0, _ = _ + Math.imul(Z, Ee) | 0, h = h + Math.imul(J, Le) | 0, u = u + Math.imul(J, _e) | 0, u = u + Math.imul(Y, Le) | 0, _ = _ + Math.imul(Y, _e) | 0, h = h + Math.imul($, Be) | 0, u = u + Math.imul($, Te) | 0, u = u + Math.imul(H, Be) | 0, _ = _ + Math.imul(H, Te) | 0, h = h + Math.imul(ee, $e) | 0, u = u + Math.imul(ee, Me) | 0, u = u + Math.imul(K, $e) | 0, _ = _ + Math.imul(K, Me) | 0, h = h + Math.imul(z, Ge) | 0, u = u + Math.imul(z, Ne) | 0, u = u + Math.imul(j, Ge) | 0, _ = _ + Math.imul(j, Ne) | 0, h = h + Math.imul(E, De) | 0, u = u + Math.imul(E, Ue) | 0, u = u + Math.imul(R, De) | 0, _ = _ + Math.imul(R, Ue) | 0;
            var Pn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, h = Math.imul(Ie, ye), u = Math.imul(Ie, ge), u = u + Math.imul(be, ye) | 0, _ = Math.imul(be, ge), h = h + Math.imul(xe, ke) | 0, u = u + Math.imul(xe, Ae) | 0, u = u + Math.imul(de, ke) | 0, _ = _ + Math.imul(de, Ae) | 0, h = h + Math.imul(he, Oe) | 0, u = u + Math.imul(he, we) | 0, u = u + Math.imul(le, Oe) | 0, _ = _ + Math.imul(le, we) | 0, h = h + Math.imul(fe, Fe) | 0, u = u + Math.imul(fe, Ee) | 0, u = u + Math.imul(ie, Fe) | 0, _ = _ + Math.imul(ie, Ee) | 0, h = h + Math.imul(te, Le) | 0, u = u + Math.imul(te, _e) | 0, u = u + Math.imul(Z, Le) | 0, _ = _ + Math.imul(Z, _e) | 0, h = h + Math.imul(J, Be) | 0, u = u + Math.imul(J, Te) | 0, u = u + Math.imul(Y, Be) | 0, _ = _ + Math.imul(Y, Te) | 0, h = h + Math.imul($, $e) | 0, u = u + Math.imul($, Me) | 0, u = u + Math.imul(H, $e) | 0, _ = _ + Math.imul(H, Me) | 0, h = h + Math.imul(ee, Ge) | 0, u = u + Math.imul(ee, Ne) | 0, u = u + Math.imul(K, Ge) | 0, _ = _ + Math.imul(K, Ne) | 0, h = h + Math.imul(z, De) | 0, u = u + Math.imul(z, Ue) | 0, u = u + Math.imul(j, De) | 0, _ = _ + Math.imul(j, Ue) | 0;
            var In = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, h = Math.imul(Ie, ke), u = Math.imul(Ie, Ae), u = u + Math.imul(be, ke) | 0, _ = Math.imul(be, Ae), h = h + Math.imul(xe, Oe) | 0, u = u + Math.imul(xe, we) | 0, u = u + Math.imul(de, Oe) | 0, _ = _ + Math.imul(de, we) | 0, h = h + Math.imul(he, Fe) | 0, u = u + Math.imul(he, Ee) | 0, u = u + Math.imul(le, Fe) | 0, _ = _ + Math.imul(le, Ee) | 0, h = h + Math.imul(fe, Le) | 0, u = u + Math.imul(fe, _e) | 0, u = u + Math.imul(ie, Le) | 0, _ = _ + Math.imul(ie, _e) | 0, h = h + Math.imul(te, Be) | 0, u = u + Math.imul(te, Te) | 0, u = u + Math.imul(Z, Be) | 0, _ = _ + Math.imul(Z, Te) | 0, h = h + Math.imul(J, $e) | 0, u = u + Math.imul(J, Me) | 0, u = u + Math.imul(Y, $e) | 0, _ = _ + Math.imul(Y, Me) | 0, h = h + Math.imul($, Ge) | 0, u = u + Math.imul($, Ne) | 0, u = u + Math.imul(H, Ge) | 0, _ = _ + Math.imul(H, Ne) | 0, h = h + Math.imul(ee, De) | 0, u = u + Math.imul(ee, Ue) | 0, u = u + Math.imul(K, De) | 0, _ = _ + Math.imul(K, Ue) | 0;
            var Rn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863, h = Math.imul(Ie, Oe), u = Math.imul(Ie, we), u = u + Math.imul(be, Oe) | 0, _ = Math.imul(be, we), h = h + Math.imul(xe, Fe) | 0, u = u + Math.imul(xe, Ee) | 0, u = u + Math.imul(de, Fe) | 0, _ = _ + Math.imul(de, Ee) | 0, h = h + Math.imul(he, Le) | 0, u = u + Math.imul(he, _e) | 0, u = u + Math.imul(le, Le) | 0, _ = _ + Math.imul(le, _e) | 0, h = h + Math.imul(fe, Be) | 0, u = u + Math.imul(fe, Te) | 0, u = u + Math.imul(ie, Be) | 0, _ = _ + Math.imul(ie, Te) | 0, h = h + Math.imul(te, $e) | 0, u = u + Math.imul(te, Me) | 0, u = u + Math.imul(Z, $e) | 0, _ = _ + Math.imul(Z, Me) | 0, h = h + Math.imul(J, Ge) | 0, u = u + Math.imul(J, Ne) | 0, u = u + Math.imul(Y, Ge) | 0, _ = _ + Math.imul(Y, Ne) | 0, h = h + Math.imul($, De) | 0, u = u + Math.imul($, Ue) | 0, u = u + Math.imul(H, De) | 0, _ = _ + Math.imul(H, Ue) | 0;
            var kn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, h = Math.imul(Ie, Fe), u = Math.imul(Ie, Ee), u = u + Math.imul(be, Fe) | 0, _ = Math.imul(be, Ee), h = h + Math.imul(xe, Le) | 0, u = u + Math.imul(xe, _e) | 0, u = u + Math.imul(de, Le) | 0, _ = _ + Math.imul(de, _e) | 0, h = h + Math.imul(he, Be) | 0, u = u + Math.imul(he, Te) | 0, u = u + Math.imul(le, Be) | 0, _ = _ + Math.imul(le, Te) | 0, h = h + Math.imul(fe, $e) | 0, u = u + Math.imul(fe, Me) | 0, u = u + Math.imul(ie, $e) | 0, _ = _ + Math.imul(ie, Me) | 0, h = h + Math.imul(te, Ge) | 0, u = u + Math.imul(te, Ne) | 0, u = u + Math.imul(Z, Ge) | 0, _ = _ + Math.imul(Z, Ne) | 0, h = h + Math.imul(J, De) | 0, u = u + Math.imul(J, Ue) | 0, u = u + Math.imul(Y, De) | 0, _ = _ + Math.imul(Y, Ue) | 0;
            var On = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (On >>> 26) | 0, On &= 67108863, h = Math.imul(Ie, Le), u = Math.imul(Ie, _e), u = u + Math.imul(be, Le) | 0, _ = Math.imul(be, _e), h = h + Math.imul(xe, Be) | 0, u = u + Math.imul(xe, Te) | 0, u = u + Math.imul(de, Be) | 0, _ = _ + Math.imul(de, Te) | 0, h = h + Math.imul(he, $e) | 0, u = u + Math.imul(he, Me) | 0, u = u + Math.imul(le, $e) | 0, _ = _ + Math.imul(le, Me) | 0, h = h + Math.imul(fe, Ge) | 0, u = u + Math.imul(fe, Ne) | 0, u = u + Math.imul(ie, Ge) | 0, _ = _ + Math.imul(ie, Ne) | 0, h = h + Math.imul(te, De) | 0, u = u + Math.imul(te, Ue) | 0, u = u + Math.imul(Z, De) | 0, _ = _ + Math.imul(Z, Ue) | 0;
            var Cn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, h = Math.imul(Ie, Be), u = Math.imul(Ie, Te), u = u + Math.imul(be, Be) | 0, _ = Math.imul(be, Te), h = h + Math.imul(xe, $e) | 0, u = u + Math.imul(xe, Me) | 0, u = u + Math.imul(de, $e) | 0, _ = _ + Math.imul(de, Me) | 0, h = h + Math.imul(he, Ge) | 0, u = u + Math.imul(he, Ne) | 0, u = u + Math.imul(le, Ge) | 0, _ = _ + Math.imul(le, Ne) | 0, h = h + Math.imul(fe, De) | 0, u = u + Math.imul(fe, Ue) | 0, u = u + Math.imul(ie, De) | 0, _ = _ + Math.imul(ie, Ue) | 0;
            var Fn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Fn >>> 26) | 0, Fn &= 67108863, h = Math.imul(Ie, $e), u = Math.imul(Ie, Me), u = u + Math.imul(be, $e) | 0, _ = Math.imul(be, Me), h = h + Math.imul(xe, Ge) | 0, u = u + Math.imul(xe, Ne) | 0, u = u + Math.imul(de, Ge) | 0, _ = _ + Math.imul(de, Ne) | 0, h = h + Math.imul(he, De) | 0, u = u + Math.imul(he, Ue) | 0, u = u + Math.imul(le, De) | 0, _ = _ + Math.imul(le, Ue) | 0;
            var Dn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, h = Math.imul(Ie, Ge), u = Math.imul(Ie, Ne), u = u + Math.imul(be, Ge) | 0, _ = Math.imul(be, Ne), h = h + Math.imul(xe, De) | 0, u = u + Math.imul(xe, Ue) | 0, u = u + Math.imul(de, De) | 0, _ = _ + Math.imul(de, Ue) | 0;
            var Rs = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Rs >>> 26) | 0, Rs &= 67108863, h = Math.imul(Ie, De), u = Math.imul(Ie, Ue), u = u + Math.imul(be, De) | 0, _ = Math.imul(be, Ue);
            var ks = (y + h | 0) + ((u & 8191) << 13) | 0;
            return y = (_ + (u >>> 13) | 0) + (ks >>> 26) | 0, ks &= 67108863, b[0] = pr, b[1] = mr, b[2] = yr, b[3] = gr, b[4] = xr, b[5] = Tn, b[6] = Mn, b[7] = Nn, b[8] = Sn, b[9] = Pn, b[10] = In, b[11] = Rn, b[12] = kn, b[13] = On, b[14] = Cn, b[15] = Fn, b[16] = Dn, b[17] = Rs, b[18] = ks, y !== 0 && (b[19] = y, g.length++), g
        };
        Math.imul || (I = k);

        function U(m, a, c) {
            c.negative = a.negative ^ m.negative, c.length = m.length + a.length;
            for (var g = 0, v = 0, x = 0; x < c.length - 1; x++) {
                var b = v;
                v = 0;
                for (var y = g & 67108863, h = Math.min(x, a.length - 1), u = Math.max(0, x - m.length + 1); u <= h; u++) {
                    var _ = x - u,
                        L = m.words[_] | 0,
                        E = a.words[u] | 0,
                        R = L * E,
                        G = R & 67108863;
                    b = b + (R / 67108864 | 0) | 0, G = G + y | 0, y = G & 67108863, b = b + (G >>> 26) | 0, v += b >>> 26, b &= 67108863
                }
                c.words[x] = y, g = b, b = v
            }
            return g !== 0 ? c.words[x] = g : c.length--, c._strip()
        }

        function M(m, a, c) {
            return U(m, a, c)
        }
        s.prototype.mulTo = function(a, c) {
            var g, v = this.length + a.length;
            return this.length === 10 && a.length === 10 ? g = I(this, a, c) : v < 63 ? g = k(this, a, c) : v < 1024 ? g = U(this, a, c) : g = M(this, a, c), g
        }, s.prototype.mul = function(a) {
            var c = new s(null);
            return c.words = new Array(this.length + a.length), this.mulTo(a, c)
        }, s.prototype.mulf = function(a) {
            var c = new s(null);
            return c.words = new Array(this.length + a.length), M(this, a, c)
        }, s.prototype.imul = function(a) {
            return this.clone().mulTo(a, this)
        }, s.prototype.imuln = function(a) {
            var c = a < 0;
            c && (a = -a), n(typeof a == "number"), n(a < 67108864);
            for (var g = 0, v = 0; v < this.length; v++) {
                var x = (this.words[v] | 0) * a,
                    b = (x & 67108863) + (g & 67108863);
                g >>= 26, g += x / 67108864 | 0, g += b >>> 26, this.words[v] = b & 67108863
            }
            return g !== 0 && (this.words[v] = g, this.length++), c ? this.ineg() : this
        }, s.prototype.muln = function(a) {
            return this.clone().imuln(a)
        }, s.prototype.sqr = function() {
            return this.mul(this)
        }, s.prototype.isqr = function() {
            return this.imul(this.clone())
        }, s.prototype.pow = function(a) {
            var c = S(a);
            if (c.length === 0) return new s(1);
            for (var g = this, v = 0; v < c.length && c[v] === 0; v++, g = g.sqr());
            if (++v < c.length)
                for (var x = g.sqr(); v < c.length; v++, x = x.sqr()) c[v] !== 0 && (g = g.mul(x));
            return g
        }, s.prototype.iushln = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = a % 26,
                g = (a - c) / 26,
                v = 67108863 >>> 26 - c << 26 - c,
                x;
            if (c !== 0) {
                var b = 0;
                for (x = 0; x < this.length; x++) {
                    var y = this.words[x] & v,
                        h = (this.words[x] | 0) - y << c;
                    this.words[x] = h | b, b = y >>> 26 - c
                }
                b && (this.words[x] = b, this.length++)
            }
            if (g !== 0) {
                for (x = this.length - 1; x >= 0; x--) this.words[x + g] = this.words[x];
                for (x = 0; x < g; x++) this.words[x] = 0;
                this.length += g
            }
            return this._strip()
        }, s.prototype.ishln = function(a) {
            return n(this.negative === 0), this.iushln(a)
        }, s.prototype.iushrn = function(a, c, g) {
            n(typeof a == "number" && a >= 0);
            var v;
            c ? v = (c - c % 26) / 26 : v = 0;
            var x = a % 26,
                b = Math.min((a - x) / 26, this.length),
                y = 67108863 ^ 67108863 >>> x << x,
                h = g;
            if (v -= b, v = Math.max(0, v), h) {
                for (var u = 0; u < b; u++) h.words[u] = this.words[u];
                h.length = b
            }
            if (b !== 0)
                if (this.length > b)
                    for (this.length -= b, u = 0; u < this.length; u++) this.words[u] = this.words[u + b];
                else this.words[0] = 0, this.length = 1;
            var _ = 0;
            for (u = this.length - 1; u >= 0 && (_ !== 0 || u >= v); u--) {
                var L = this.words[u] | 0;
                this.words[u] = _ << 26 - x | L >>> x, _ = L & y
            }
            return h && _ !== 0 && (h.words[h.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, s.prototype.ishrn = function(a, c, g) {
            return n(this.negative === 0), this.iushrn(a, c, g)
        }, s.prototype.shln = function(a) {
            return this.clone().ishln(a)
        }, s.prototype.ushln = function(a) {
            return this.clone().iushln(a)
        }, s.prototype.shrn = function(a) {
            return this.clone().ishrn(a)
        }, s.prototype.ushrn = function(a) {
            return this.clone().iushrn(a)
        }, s.prototype.testn = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = a % 26,
                g = (a - c) / 26,
                v = 1 << c;
            if (this.length <= g) return !1;
            var x = this.words[g];
            return !!(x & v)
        }, s.prototype.imaskn = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = a % 26,
                g = (a - c) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g) return this;
            if (c !== 0 && g++, this.length = Math.min(g, this.length), c !== 0) {
                var v = 67108863 ^ 67108863 >>> c << c;
                this.words[this.length - 1] &= v
            }
            return this._strip()
        }, s.prototype.maskn = function(a) {
            return this.clone().imaskn(a)
        }, s.prototype.iaddn = function(a) {
            return n(typeof a == "number"), n(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a)
        }, s.prototype._iaddn = function(a) {
            this.words[0] += a;
            for (var c = 0; c < this.length && this.words[c] >= 67108864; c++) this.words[c] -= 67108864, c === this.length - 1 ? this.words[c + 1] = 1 : this.words[c + 1]++;
            return this.length = Math.max(this.length, c + 1), this
        }, s.prototype.isubn = function(a) {
            if (n(typeof a == "number"), n(a < 67108864), a < 0) return this.iaddn(-a);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(a), this.negative = 1, this;
            if (this.words[0] -= a, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var c = 0; c < this.length && this.words[c] < 0; c++) this.words[c] += 67108864, this.words[c + 1] -= 1;
            return this._strip()
        }, s.prototype.addn = function(a) {
            return this.clone().iaddn(a)
        }, s.prototype.subn = function(a) {
            return this.clone().isubn(a)
        }, s.prototype.iabs = function() {
            return this.negative = 0, this
        }, s.prototype.abs = function() {
            return this.clone().iabs()
        }, s.prototype._ishlnsubmul = function(a, c, g) {
            var v = a.length + g,
                x;
            this._expand(v);
            var b, y = 0;
            for (x = 0; x < a.length; x++) {
                b = (this.words[x + g] | 0) + y;
                var h = (a.words[x] | 0) * c;
                b -= h & 67108863, y = (b >> 26) - (h / 67108864 | 0), this.words[x + g] = b & 67108863
            }
            for (; x < this.length - g; x++) b = (this.words[x + g] | 0) + y, y = b >> 26, this.words[x + g] = b & 67108863;
            if (y === 0) return this._strip();
            for (n(y === -1), y = 0, x = 0; x < this.length; x++) b = -(this.words[x] | 0) + y, y = b >> 26, this.words[x] = b & 67108863;
            return this.negative = 1, this._strip()
        }, s.prototype._wordDiv = function(a, c) {
            var g = this.length - a.length,
                v = this.clone(),
                x = a,
                b = x.words[x.length - 1] | 0,
                y = this._countBits(b);
            g = 26 - y, g !== 0 && (x = x.ushln(g), v.iushln(g), b = x.words[x.length - 1] | 0);
            var h = v.length - x.length,
                u;
            if (c !== "mod") {
                u = new s(null), u.length = h + 1, u.words = new Array(u.length);
                for (var _ = 0; _ < u.length; _++) u.words[_] = 0
            }
            var L = v.clone()._ishlnsubmul(x, 1, h);
            L.negative === 0 && (v = L, u && (u.words[h] = 1));
            for (var E = h - 1; E >= 0; E--) {
                var R = (v.words[x.length + E] | 0) * 67108864 + (v.words[x.length + E - 1] | 0);
                for (R = Math.min(R / b | 0, 67108863), v._ishlnsubmul(x, R, E); v.negative !== 0;) R--, v.negative = 0, v._ishlnsubmul(x, 1, E), v.isZero() || (v.negative ^= 1);
                u && (u.words[E] = R)
            }
            return u && u._strip(), v._strip(), c !== "div" && g !== 0 && v.iushrn(g), {
                div: u || null,
                mod: v
            }
        }, s.prototype.divmod = function(a, c, g) {
            if (n(!a.isZero()), this.isZero()) return {
                div: new s(0),
                mod: new s(0)
            };
            var v, x, b;
            return this.negative !== 0 && a.negative === 0 ? (b = this.neg().divmod(a, c), c !== "mod" && (v = b.div.neg()), c !== "div" && (x = b.mod.neg(), g && x.negative !== 0 && x.iadd(a)), {
                div: v,
                mod: x
            }) : this.negative === 0 && a.negative !== 0 ? (b = this.divmod(a.neg(), c), c !== "mod" && (v = b.div.neg()), {
                div: v,
                mod: b.mod
            }) : (this.negative & a.negative) != 0 ? (b = this.neg().divmod(a.neg(), c), c !== "div" && (x = b.mod.neg(), g && x.negative !== 0 && x.isub(a)), {
                div: b.div,
                mod: x
            }) : a.length > this.length || this.cmp(a) < 0 ? {
                div: new s(0),
                mod: this
            } : a.length === 1 ? c === "div" ? {
                div: this.divn(a.words[0]),
                mod: null
            } : c === "mod" ? {
                div: null,
                mod: new s(this.modrn(a.words[0]))
            } : {
                div: this.divn(a.words[0]),
                mod: new s(this.modrn(a.words[0]))
            } : this._wordDiv(a, c)
        }, s.prototype.div = function(a) {
            return this.divmod(a, "div", !1).div
        }, s.prototype.mod = function(a) {
            return this.divmod(a, "mod", !1).mod
        }, s.prototype.umod = function(a) {
            return this.divmod(a, "mod", !0).mod
        }, s.prototype.divRound = function(a) {
            var c = this.divmod(a);
            if (c.mod.isZero()) return c.div;
            var g = c.div.negative !== 0 ? c.mod.isub(a) : c.mod,
                v = a.ushrn(1),
                x = a.andln(1),
                b = g.cmp(v);
            return b < 0 || x === 1 && b === 0 ? c.div : c.div.negative !== 0 ? c.div.isubn(1) : c.div.iaddn(1)
        }, s.prototype.modrn = function(a) {
            var c = a < 0;
            c && (a = -a), n(a <= 67108863);
            for (var g = (1 << 26) % a, v = 0, x = this.length - 1; x >= 0; x--) v = (g * v + (this.words[x] | 0)) % a;
            return c ? -v : v
        }, s.prototype.modn = function(a) {
            return this.modrn(a)
        }, s.prototype.idivn = function(a) {
            var c = a < 0;
            c && (a = -a), n(a <= 67108863);
            for (var g = 0, v = this.length - 1; v >= 0; v--) {
                var x = (this.words[v] | 0) + g * 67108864;
                this.words[v] = x / a | 0, g = x % a
            }
            return this._strip(), c ? this.ineg() : this
        }, s.prototype.divn = function(a) {
            return this.clone().idivn(a)
        }, s.prototype.egcd = function(a) {
            n(a.negative === 0), n(!a.isZero());
            var c = this,
                g = a.clone();
            c.negative !== 0 ? c = c.umod(a) : c = c.clone();
            for (var v = new s(1), x = new s(0), b = new s(0), y = new s(1), h = 0; c.isEven() && g.isEven();) c.iushrn(1), g.iushrn(1), ++h;
            for (var u = g.clone(), _ = c.clone(); !c.isZero();) {
                for (var L = 0, E = 1;
                    (c.words[0] & E) == 0 && L < 26; ++L, E <<= 1);
                if (L > 0)
                    for (c.iushrn(L); L-- > 0;)(v.isOdd() || x.isOdd()) && (v.iadd(u), x.isub(_)), v.iushrn(1), x.iushrn(1);
                for (var R = 0, G = 1;
                    (g.words[0] & G) == 0 && R < 26; ++R, G <<= 1);
                if (R > 0)
                    for (g.iushrn(R); R-- > 0;)(b.isOdd() || y.isOdd()) && (b.iadd(u), y.isub(_)), b.iushrn(1), y.iushrn(1);
                c.cmp(g) >= 0 ? (c.isub(g), v.isub(b), x.isub(y)) : (g.isub(c), b.isub(v), y.isub(x))
            }
            return {
                a: b,
                b: y,
                gcd: g.iushln(h)
            }
        }, s.prototype._invmp = function(a) {
            n(a.negative === 0), n(!a.isZero());
            var c = this,
                g = a.clone();
            c.negative !== 0 ? c = c.umod(a) : c = c.clone();
            for (var v = new s(1), x = new s(0), b = g.clone(); c.cmpn(1) > 0 && g.cmpn(1) > 0;) {
                for (var y = 0, h = 1;
                    (c.words[0] & h) == 0 && y < 26; ++y, h <<= 1);
                if (y > 0)
                    for (c.iushrn(y); y-- > 0;) v.isOdd() && v.iadd(b), v.iushrn(1);
                for (var u = 0, _ = 1;
                    (g.words[0] & _) == 0 && u < 26; ++u, _ <<= 1);
                if (u > 0)
                    for (g.iushrn(u); u-- > 0;) x.isOdd() && x.iadd(b), x.iushrn(1);
                c.cmp(g) >= 0 ? (c.isub(g), v.isub(x)) : (g.isub(c), x.isub(v))
            }
            var L;
            return c.cmpn(1) === 0 ? L = v : L = x, L.cmpn(0) < 0 && L.iadd(a), L
        }, s.prototype.gcd = function(a) {
            if (this.isZero()) return a.abs();
            if (a.isZero()) return this.abs();
            var c = this.clone(),
                g = a.clone();
            c.negative = 0, g.negative = 0;
            for (var v = 0; c.isEven() && g.isEven(); v++) c.iushrn(1), g.iushrn(1);
            do {
                for (; c.isEven();) c.iushrn(1);
                for (; g.isEven();) g.iushrn(1);
                var x = c.cmp(g);
                if (x < 0) {
                    var b = c;
                    c = g, g = b
                } else if (x === 0 || g.cmpn(1) === 0) break;
                c.isub(g)
            } while (!0);
            return g.iushln(v)
        }, s.prototype.invm = function(a) {
            return this.egcd(a).a.umod(a)
        }, s.prototype.isEven = function() {
            return (this.words[0] & 1) == 0
        }, s.prototype.isOdd = function() {
            return (this.words[0] & 1) == 1
        }, s.prototype.andln = function(a) {
            return this.words[0] & a
        }, s.prototype.bincn = function(a) {
            n(typeof a == "number");
            var c = a % 26,
                g = (a - c) / 26,
                v = 1 << c;
            if (this.length <= g) return this._expand(g + 1), this.words[g] |= v, this;
            for (var x = v, b = g; x !== 0 && b < this.length; b++) {
                var y = this.words[b] | 0;
                y += x, x = y >>> 26, y &= 67108863, this.words[b] = y
            }
            return x !== 0 && (this.words[b] = x, this.length++), this
        }, s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, s.prototype.cmpn = function(a) {
            var c = a < 0;
            if (this.negative !== 0 && !c) return -1;
            if (this.negative === 0 && c) return 1;
            this._strip();
            var g;
            if (this.length > 1) g = 1;
            else {
                c && (a = -a), n(a <= 67108863, "Number is too big");
                var v = this.words[0] | 0;
                g = v === a ? 0 : v < a ? -1 : 1
            }
            return this.negative !== 0 ? -g | 0 : g
        }, s.prototype.cmp = function(a) {
            if (this.negative !== 0 && a.negative === 0) return -1;
            if (this.negative === 0 && a.negative !== 0) return 1;
            var c = this.ucmp(a);
            return this.negative !== 0 ? -c | 0 : c
        }, s.prototype.ucmp = function(a) {
            if (this.length > a.length) return 1;
            if (this.length < a.length) return -1;
            for (var c = 0, g = this.length - 1; g >= 0; g--) {
                var v = this.words[g] | 0,
                    x = a.words[g] | 0;
                if (v !== x) {
                    v < x ? c = -1 : v > x && (c = 1);
                    break
                }
            }
            return c
        }, s.prototype.gtn = function(a) {
            return this.cmpn(a) === 1
        }, s.prototype.gt = function(a) {
            return this.cmp(a) === 1
        }, s.prototype.gten = function(a) {
            return this.cmpn(a) >= 0
        }, s.prototype.gte = function(a) {
            return this.cmp(a) >= 0
        }, s.prototype.ltn = function(a) {
            return this.cmpn(a) === -1
        }, s.prototype.lt = function(a) {
            return this.cmp(a) === -1
        }, s.prototype.lten = function(a) {
            return this.cmpn(a) <= 0
        }, s.prototype.lte = function(a) {
            return this.cmp(a) <= 0
        }, s.prototype.eqn = function(a) {
            return this.cmpn(a) === 0
        }, s.prototype.eq = function(a) {
            return this.cmp(a) === 0
        }, s.red = function(a) {
            return new O(a)
        }, s.prototype.toRed = function(a) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a)
        }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, s.prototype._forceRed = function(a) {
            return this.red = a, this
        }, s.prototype.forceRed = function(a) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(a)
        }, s.prototype.redAdd = function(a) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, a)
        }, s.prototype.redIAdd = function(a) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a)
        }, s.prototype.redSub = function(a) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, a)
        }, s.prototype.redISub = function(a) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, a)
        }, s.prototype.redShl = function(a) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, a)
        }, s.prototype.redMul = function(a) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a)
        }, s.prototype.redIMul = function(a) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a)
        }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, s.prototype.redPow = function(a) {
            return n(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a)
        };
        var F = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function D(m, a) {
            this.name = m, this.p = new s(a, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        D.prototype._tmp = function() {
            var a = new s(null);
            return a.words = new Array(Math.ceil(this.n / 13)), a
        }, D.prototype.ireduce = function(a) {
            var c = a,
                g;
            do this.split(c, this.tmp), c = this.imulK(c), c = c.iadd(this.tmp), g = c.bitLength(); while (g > this.n);
            var v = g < this.n ? -1 : c.ucmp(this.p);
            return v === 0 ? (c.words[0] = 0, c.length = 1) : v > 0 ? c.isub(this.p) : c.strip !== void 0 ? c.strip() : c._strip(), c
        }, D.prototype.split = function(a, c) {
            a.iushrn(this.n, 0, c)
        }, D.prototype.imulK = function(a) {
            return a.imul(this.k)
        };

        function q() {
            D.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(q, D), q.prototype.split = function(a, c) {
            for (var g = 4194303, v = Math.min(a.length, 9), x = 0; x < v; x++) c.words[x] = a.words[x];
            if (c.length = v, a.length <= 9) {
                a.words[0] = 0, a.length = 1;
                return
            }
            var b = a.words[9];
            for (c.words[c.length++] = b & g, x = 10; x < a.length; x++) {
                var y = a.words[x] | 0;
                a.words[x - 10] = (y & g) << 4 | b >>> 22, b = y
            }
            b >>>= 22, a.words[x - 10] = b, b === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9
        }, q.prototype.imulK = function(a) {
            a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
            for (var c = 0, g = 0; g < a.length; g++) {
                var v = a.words[g] | 0;
                c += v * 977, a.words[g] = c & 67108863, c = v * 64 + (c / 67108864 | 0)
            }
            return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a
        };

        function V() {
            D.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(V, D);

        function Q() {
            D.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(Q, D);

        function ce() {
            D.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(ce, D), ce.prototype.imulK = function(a) {
            for (var c = 0, g = 0; g < a.length; g++) {
                var v = (a.words[g] | 0) * 19 + c,
                    x = v & 67108863;
                v >>>= 26, a.words[g] = x, c = v
            }
            return c !== 0 && (a.words[a.length++] = c), a
        }, s._prime = function(a) {
            if (F[a]) return F[a];
            var c;
            if (a === "k256") c = new q;
            else if (a === "p224") c = new V;
            else if (a === "p192") c = new Q;
            else if (a === "p25519") c = new ce;
            else throw new Error("Unknown prime " + a);
            return F[a] = c, c
        };

        function O(m) {
            if (typeof m == "string") {
                var a = s._prime(m);
                this.m = a.p, this.prime = a
            } else n(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null
        }
        O.prototype._verify1 = function(a) {
            n(a.negative === 0, "red works only with positives"), n(a.red, "red works only with red numbers")
        }, O.prototype._verify2 = function(a, c) {
            n((a.negative | c.negative) == 0, "red works only with positives"), n(a.red && a.red === c.red, "red works only with red numbers")
        }, O.prototype.imod = function(a) {
            return this.prime ? this.prime.ireduce(a)._forceRed(this) : (p(a, a.umod(this.m)._forceRed(this)), a)
        }, O.prototype.neg = function(a) {
            return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this)
        }, O.prototype.add = function(a, c) {
            this._verify2(a, c);
            var g = a.add(c);
            return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this)
        }, O.prototype.iadd = function(a, c) {
            this._verify2(a, c);
            var g = a.iadd(c);
            return g.cmp(this.m) >= 0 && g.isub(this.m), g
        }, O.prototype.sub = function(a, c) {
            this._verify2(a, c);
            var g = a.sub(c);
            return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this)
        }, O.prototype.isub = function(a, c) {
            this._verify2(a, c);
            var g = a.isub(c);
            return g.cmpn(0) < 0 && g.iadd(this.m), g
        }, O.prototype.shl = function(a, c) {
            return this._verify1(a), this.imod(a.ushln(c))
        }, O.prototype.imul = function(a, c) {
            return this._verify2(a, c), this.imod(a.imul(c))
        }, O.prototype.mul = function(a, c) {
            return this._verify2(a, c), this.imod(a.mul(c))
        }, O.prototype.isqr = function(a) {
            return this.imul(a, a.clone())
        }, O.prototype.sqr = function(a) {
            return this.mul(a, a)
        }, O.prototype.sqrt = function(a) {
            if (a.isZero()) return a.clone();
            var c = this.m.andln(3);
            if (n(c % 2 == 1), c === 3) {
                var g = this.m.add(new s(1)).iushrn(2);
                return this.pow(a, g)
            }
            for (var v = this.m.subn(1), x = 0; !v.isZero() && v.andln(1) === 0;) x++, v.iushrn(1);
            n(!v.isZero());
            var b = new s(1).toRed(this),
                y = b.redNeg(),
                h = this.m.subn(1).iushrn(1),
                u = this.m.bitLength();
            for (u = new s(2 * u * u).toRed(this); this.pow(u, h).cmp(y) !== 0;) u.redIAdd(y);
            for (var _ = this.pow(u, v), L = this.pow(a, v.addn(1).iushrn(1)), E = this.pow(a, v), R = x; E.cmp(b) !== 0;) {
                for (var G = E, z = 0; G.cmp(b) !== 0; z++) G = G.redSqr();
                n(z < R);
                var j = this.pow(_, new s(1).iushln(R - z - 1));
                L = L.redMul(j), _ = j.redSqr(), E = E.redMul(_), R = z
            }
            return L
        }, O.prototype.invm = function(a) {
            var c = a._invmp(this.m);
            return c.negative !== 0 ? (c.negative = 0, this.imod(c).redNeg()) : this.imod(c)
        }, O.prototype.pow = function(a, c) {
            if (c.isZero()) return new s(1).toRed(this);
            if (c.cmpn(1) === 0) return a.clone();
            var g = 4,
                v = new Array(1 << g);
            v[0] = new s(1).toRed(this), v[1] = a;
            for (var x = 2; x < v.length; x++) v[x] = this.mul(v[x - 1], a);
            var b = v[0],
                y = 0,
                h = 0,
                u = c.bitLength() % 26;
            for (u === 0 && (u = 26), x = c.length - 1; x >= 0; x--) {
                for (var _ = c.words[x], L = u - 1; L >= 0; L--) {
                    var E = _ >> L & 1;
                    if (b !== v[0] && (b = this.sqr(b)), E === 0 && y === 0) {
                        h = 0;
                        continue
                    }
                    y <<= 1, y |= E, h++, !(h !== g && (x !== 0 || L !== 0)) && (b = this.mul(b, v[y]), h = 0, y = 0)
                }
                u = 26
            }
            return b
        }, O.prototype.convertTo = function(a) {
            var c = a.umod(this.m);
            return c === a ? c.clone() : c
        }, O.prototype.convertFrom = function(a) {
            var c = a.clone();
            return c.red = null, c
        }, s.mont = function(a) {
            return new w(a)
        };

        function w(m) {
            O.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(w, O), w.prototype.convertTo = function(a) {
            return this.imod(a.ushln(this.shift))
        }, w.prototype.convertFrom = function(a) {
            var c = this.imod(a.mul(this.rinv));
            return c.red = null, c
        }, w.prototype.imul = function(a, c) {
            if (a.isZero() || c.isZero()) return a.words[0] = 0, a.length = 1, a;
            var g = a.imul(c),
                v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                x = g.isub(v).iushrn(this.shift),
                b = x;
            return x.cmp(this.m) >= 0 ? b = x.isub(this.m) : x.cmpn(0) < 0 && (b = x.iadd(this.m)), b._forceRed(this)
        }, w.prototype.mul = function(a, c) {
            if (a.isZero() || c.isZero()) return new s(0)._forceRed(this);
            var g = a.mul(c),
                v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                x = g.isub(v).iushrn(this.shift),
                b = x;
            return x.cmp(this.m) >= 0 ? b = x.isub(this.m) : x.cmpn(0) < 0 && (b = x.iadd(this.m)), b._forceRed(this)
        }, w.prototype.invm = function(a) {
            var c = this.imod(a._invmp(this.m).mul(this.r2));
            return c._forceRed(this)
        }
    })(t, vu)
})(A1);
var Z_ = A1.exports;
const Y_ = "logger/5.7.0";
let _1 = !1,
    T1 = !1;
const pl = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let M1 = pl.default,
    Hh = null;

function Q_() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const N1 = Q_();
var qh;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(qh || (qh = {}));
var Zn;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(Zn || (Zn = {}));
const S1 = "0123456789abcdef";
class It {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        pl[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(M1 > pl[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(It.levels.DEBUG, e)
    }
    info(...e) {
        this._log(It.levels.INFO, e)
    }
    warn(...e) {
        this._log(It.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (T1) return this.makeError("censored error", r, {});
        r || (r = It.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += S1[d[A] >> 4], p += S1[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case Zn.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case Zn.CALL_EXCEPTION:
            case Zn.INSUFFICIENT_FUNDS:
            case Zn.MISSING_NEW:
            case Zn.NONCE_EXPIRED:
            case Zn.REPLACEMENT_UNDERPRICED:
            case Zn.TRANSACTION_REPLACED:
            case Zn.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, It.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        N1 && this.throwError("platform missing String.prototype.normalize", It.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: N1
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, It.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, It.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, It.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, It.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", It.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", It.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", It.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return Hh || (Hh = new It(Y_)), Hh
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", It.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), _1) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", It.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        T1 = !!e, _1 = !!r
    }
    static setLogLevel(e) {
        const r = pl[e.toLowerCase()];
        if (r == null) {
            It.globalLogger().warn("invalid log level - " + e);
            return
        }
        M1 = r
    }
    static from(e) {
        return new It(e)
    }
}
It.errors = Zn;
It.levels = qh;
const eT = "bignumber/5.7.0";
var ml = Z_.BN;
const ts = new It(eT),
    jh = {},
    P1 = 9007199254740991;
let I1 = !1;
class Ce {
    constructor(e, r) {
        e !== jh && ts.throwError("cannot call constructor directly; use BigNumber.from", It.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        }), this._hex = r, this._isBigNumber = !0, Object.freeze(this)
    }
    fromTwos(e) {
        return $r(ht(this).fromTwos(e))
    }
    toTwos(e) {
        return $r(ht(this).toTwos(e))
    }
    abs() {
        return this._hex[0] === "-" ? Ce.from(this._hex.substring(1)) : this
    }
    add(e) {
        return $r(ht(this).add(ht(e)))
    }
    sub(e) {
        return $r(ht(this).sub(ht(e)))
    }
    div(e) {
        return Ce.from(e).isZero() && yn("division-by-zero", "div"), $r(ht(this).div(ht(e)))
    }
    mul(e) {
        return $r(ht(this).mul(ht(e)))
    }
    mod(e) {
        const r = ht(e);
        return r.isNeg() && yn("division-by-zero", "mod"), $r(ht(this).umod(r))
    }
    pow(e) {
        const r = ht(e);
        return r.isNeg() && yn("negative-power", "pow"), $r(ht(this).pow(r))
    }
    and(e) {
        const r = ht(e);
        return (this.isNegative() || r.isNeg()) && yn("unbound-bitwise-result", "and"), $r(ht(this).and(r))
    }
    or(e) {
        const r = ht(e);
        return (this.isNegative() || r.isNeg()) && yn("unbound-bitwise-result", "or"), $r(ht(this).or(r))
    }
    xor(e) {
        const r = ht(e);
        return (this.isNegative() || r.isNeg()) && yn("unbound-bitwise-result", "xor"), $r(ht(this).xor(r))
    }
    mask(e) {
        return (this.isNegative() || e < 0) && yn("negative-width", "mask"), $r(ht(this).maskn(e))
    }
    shl(e) {
        return (this.isNegative() || e < 0) && yn("negative-width", "shl"), $r(ht(this).shln(e))
    }
    shr(e) {
        return (this.isNegative() || e < 0) && yn("negative-width", "shr"), $r(ht(this).shrn(e))
    }
    eq(e) {
        return ht(this).eq(ht(e))
    }
    lt(e) {
        return ht(this).lt(ht(e))
    }
    lte(e) {
        return ht(this).lte(ht(e))
    }
    gt(e) {
        return ht(this).gt(ht(e))
    }
    gte(e) {
        return ht(this).gte(ht(e))
    }
    isNegative() {
        return this._hex[0] === "-"
    }
    isZero() {
        return ht(this).isZero()
    }
    toNumber() {
        try {
            return ht(this).toNumber()
        } catch {
            yn("overflow", "toNumber", this.toString())
        }
        return null
    }
    toBigInt() {
        try {
            return BigInt(this.toString())
        } catch {}
        return ts.throwError("this platform does not support BigInt", It.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        })
    }
    toString() {
        return arguments.length > 0 && (arguments[0] === 10 ? I1 || (I1 = !0, ts.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? ts.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", It.errors.UNEXPECTED_ARGUMENT, {}) : ts.throwError("BigNumber.toString does not accept parameters", It.errors.UNEXPECTED_ARGUMENT, {})), ht(this).toString(10)
    }
    toHexString() {
        return this._hex
    }
    toJSON(e) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        }
    }
    static from(e) {
        if (e instanceof Ce) return e;
        if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new Ce(jh, cf(e)) : e.match(/^-?[0-9]+$/) ? new Ce(jh, cf(new ml(e))) : ts.throwArgumentError("invalid BigNumber string", "value", e);
        if (typeof e == "number") return e % 1 && yn("underflow", "BigNumber.from", e), (e >= P1 || e <= -P1) && yn("overflow", "BigNumber.from", e), Ce.from(String(e));
        const r = e;
        if (typeof r == "bigint") return Ce.from(r.toString());
        if (cl(r)) return Ce.from(nt(r));
        if (r)
            if (r.toHexString) {
                const n = r.toHexString();
                if (typeof n == "string") return Ce.from(n)
            } else {
                let n = r._hex;
                if (n == null && r.type === "BigNumber" && (n = r.hex), typeof n == "string" && ($t(n) || n[0] === "-" && $t(n.substring(1)))) return Ce.from(n)
            }
        return ts.throwArgumentError("invalid BigNumber value", "value", e)
    }
    static isBigNumber(e) {
        return !!(e && e._isBigNumber)
    }
}

function cf(t) {
    if (typeof t != "string") return cf(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && ts.throwArgumentError("invalid hex", "value", t), t = cf(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00";) t = "0x" + t.substring(4);
    return t
}

function $r(t) {
    return Ce.from(cf(t))
}

function ht(t) {
    const e = Ce.from(t).toHexString();
    return e[0] === "-" ? new ml("-" + e.substring(3), 16) : new ml(e.substring(2), 16)
}

function yn(t, e, r) {
    const n = {
        fault: t,
        operation: e
    };
    return r != null && (n.value = r), ts.throwError(t, It.errors.NUMERIC_FAULT, n)
}

function yl(t) {
    return new ml(t, 36).toString(16)
}

function R1(t) {
    return "0x" + Ha.keccak_256(ze(t))
}
const tT = "logger/5.7.0";
let k1 = !1,
    O1 = !1;
const gl = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let C1 = gl.default,
    Wh = null;

function rT() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const F1 = rT();
var Vh;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(Vh || (Vh = {}));
var Yn;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(Yn || (Yn = {}));
const D1 = "0123456789abcdef";
class dt {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        gl[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(C1 > gl[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(dt.levels.DEBUG, e)
    }
    info(...e) {
        this._log(dt.levels.INFO, e)
    }
    warn(...e) {
        this._log(dt.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (O1) return this.makeError("censored error", r, {});
        r || (r = dt.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += D1[d[A] >> 4], p += D1[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case Yn.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case Yn.CALL_EXCEPTION:
            case Yn.INSUFFICIENT_FUNDS:
            case Yn.MISSING_NEW:
            case Yn.NONCE_EXPIRED:
            case Yn.REPLACEMENT_UNDERPRICED:
            case Yn.TRANSACTION_REPLACED:
            case Yn.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, dt.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        F1 && this.throwError("platform missing String.prototype.normalize", dt.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: F1
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, dt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, dt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, dt.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, dt.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", dt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", dt.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", dt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return Wh || (Wh = new dt(tT)), Wh
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", dt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), k1) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", dt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        O1 = !!e, k1 = !!r
    }
    static setLogLevel(e) {
        const r = gl[e.toLowerCase()];
        if (r == null) {
            dt.globalLogger().warn("invalid log level - " + e);
            return
        }
        C1 = r
    }
    static from(e) {
        return new dt(e)
    }
}
dt.errors = Yn;
dt.levels = Vh;
const nT = "rlp/5.7.0",
    $S = new dt(nT);
const iT = "address/5.7.0",
    hf = new dt(iT);

function U1(t) {
    $t(t, 20) || hf.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        r = new Uint8Array(40);
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
    const n = ze(R1(r));
    for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const sT = 9007199254740991;

function oT(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const Kh = {};
for (let t = 0; t < 10; t++) Kh[String(t)] = String(t);
for (let t = 0; t < 26; t++) Kh[String.fromCharCode(65 + t)] = String(10 + t);
const L1 = Math.floor(oT(sT));

function aT(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(n => Kh[n]).join("");
    for (; e.length >= L1;) {
        let n = e.substring(0, L1);
        e = parseInt(n, 10) % 97 + e.substring(n.length)
    }
    let r = String(98 - parseInt(e, 10) % 97);
    for (; r.length < 2;) r = "0" + r;
    return r
}

function fT(t) {
    let e = null;
    if (typeof t != "string" && hf.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = U1(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && hf.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== aT(t) && hf.throwArgumentError("bad icap checksum", "address", t), e = yl(t.substring(4)); e.length < 40;) e = "0" + e;
        e = U1("0x" + e)
    } else hf.throwArgumentError("invalid address", "address", t);
    return e
}
const uT = "properties/5.7.0";
var GS = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const zS = new dt(uT);

function Oi(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}
const lT = "abstract-provider/5.7.0";
var HS = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const qS = new dt(lT);
const cT = "logger/5.7.0";
let B1 = !1,
    $1 = !1;
const xl = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let G1 = xl.default,
    Xh = null;

function hT() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const z1 = hT();
var Jh;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(Jh || (Jh = {}));
var Qn;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(Qn || (Qn = {}));
const H1 = "0123456789abcdef";
class Tt {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        xl[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(G1 > xl[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(Tt.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Tt.levels.INFO, e)
    }
    warn(...e) {
        this._log(Tt.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if ($1) return this.makeError("censored error", r, {});
        r || (r = Tt.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += H1[d[A] >> 4], p += H1[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case Qn.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case Qn.CALL_EXCEPTION:
            case Qn.INSUFFICIENT_FUNDS:
            case Qn.MISSING_NEW:
            case Qn.NONCE_EXPIRED:
            case Qn.REPLACEMENT_UNDERPRICED:
            case Qn.TRANSACTION_REPLACED:
            case Qn.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, Tt.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        z1 && this.throwError("platform missing String.prototype.normalize", Tt.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: z1
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Tt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, Tt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Tt.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, Tt.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", Tt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Tt.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", Tt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return Xh || (Xh = new Tt(cT)), Xh
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Tt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), B1) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", Tt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        $1 = !!e, B1 = !!r
    }
    static setLogLevel(e) {
        const r = xl[e.toLowerCase()];
        if (r == null) {
            Tt.globalLogger().warn("invalid log level - " + e);
            return
        }
        G1 = r
    }
    static from(e) {
        return new Tt(e)
    }
}
Tt.errors = Qn;
Tt.levels = Jh;
const dT = "properties/5.7.0";
var pT = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
new Tt(dT);

function Zh(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}

function bl(t) {
    return pT(this, void 0, void 0, function*() {
        const e = Object.keys(t).map(n => {
            const i = t[n];
            return Promise.resolve(i).then(s => ({
                key: n,
                value: s
            }))
        });
        return (yield Promise.all(e)).reduce((n, i) => (n[i.key] = i.value, n), {})
    })
}

function mT(t) {
    const e = {};
    for (const r in t) e[r] = t[r];
    return e
}
const yT = "abstract-signer/5.7.0";
var ei = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const gn = new Tt(yT),
    gT = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
    xT = [Tt.errors.INSUFFICIENT_FUNDS, Tt.errors.NONCE_EXPIRED, Tt.errors.REPLACEMENT_UNDERPRICED];
class vl {
    constructor() {
        gn.checkAbstract(new.target, vl), Zh(this, "_isSigner", !0)
    }
    getBalance(e) {
        return ei(this, void 0, void 0, function*() {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e)
        })
    }
    getTransactionCount(e) {
        return ei(this, void 0, void 0, function*() {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e)
        })
    }
    estimateGas(e) {
        return ei(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const r = yield bl(this.checkTransaction(e));
            return yield this.provider.estimateGas(r)
        })
    }
    call(e, r) {
        return ei(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const n = yield bl(this.checkTransaction(e));
            return yield this.provider.call(n, r)
        })
    }
    sendTransaction(e) {
        return ei(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const r = yield this.populateTransaction(e), n = yield this.signTransaction(r);
            return yield this.provider.sendTransaction(n)
        })
    }
    getChainId() {
        return ei(this, void 0, void 0, function*() {
            return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId
        })
    }
    getGasPrice() {
        return ei(this, void 0, void 0, function*() {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice()
        })
    }
    getFeeData() {
        return ei(this, void 0, void 0, function*() {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData()
        })
    }
    resolveName(e) {
        return ei(this, void 0, void 0, function*() {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(e)
        })
    }
    checkTransaction(e) {
        for (const n in e) gT.indexOf(n) === -1 && gn.throwArgumentError("invalid transaction key: " + n, "transaction", e);
        const r = mT(e);
        return r.from == null ? r.from = this.getAddress() : r.from = Promise.all([Promise.resolve(r.from), this.getAddress()]).then(n => (n[0].toLowerCase() !== n[1].toLowerCase() && gn.throwArgumentError("from address mismatch", "transaction", e), n[0])), r
    }
    populateTransaction(e) {
        return ei(this, void 0, void 0, function*() {
            const r = yield bl(this.checkTransaction(e));
            r.to != null && (r.to = Promise.resolve(r.to).then(i => ei(this, void 0, void 0, function*() {
                if (i == null) return null;
                const s = yield this.resolveName(i);
                return s == null && gn.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s
            })), r.to.catch(i => {}));
            const n = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
            if (r.gasPrice != null && (r.type === 2 || n) ? gn.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (r.type === 0 || r.type === 1) && n && gn.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
            else if (r.type === 0 || r.type === 1) r.gasPrice == null && (r.gasPrice = this.getGasPrice());
            else {
                const i = yield this.getFeeData();
                if (r.type == null)
                    if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
                        if (r.type = 2, r.gasPrice != null) {
                            const s = r.gasPrice;
                            delete r.gasPrice, r.maxFeePerGas = s, r.maxPriorityFeePerGas = s
                        } else r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
                else i.gasPrice != null ? (n && gn.throwError("network does not support EIP-1559", Tt.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                }), r.gasPrice == null && (r.gasPrice = i.gasPrice), r.type = 0) : gn.throwError("failed to get consistent fee data", Tt.errors.UNSUPPORTED_OPERATION, {
                    operation: "signer.getFeeData"
                });
                else r.type === 2 && (r.maxFeePerGas == null && (r.maxFeePerGas = i.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = i.maxPriorityFeePerGas))
            }
            return r.nonce == null && (r.nonce = this.getTransactionCount("pending")), r.gasLimit == null && (r.gasLimit = this.estimateGas(r).catch(i => {
                if (xT.indexOf(i.code) >= 0) throw i;
                return gn.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Tt.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: i,
                    tx: r
                })
            })), r.chainId == null ? r.chainId = this.getChainId() : r.chainId = Promise.all([Promise.resolve(r.chainId), this.getChainId()]).then(i => (i[1] !== 0 && i[0] !== i[1] && gn.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield bl(r)
        })
    }
    _checkProvider(e) {
        this.provider || gn.throwError("missing provider", Tt.errors.UNSUPPORTED_OPERATION, {
            operation: e || "_checkProvider"
        })
    }
    static isSigner(e) {
        return !!(e && e._isSigner)
    }
}
class Yh extends vl {
    constructor(e, r) {
        super();
        Zh(this, "address", e), Zh(this, "provider", r || null)
    }
    getAddress() {
        return Promise.resolve(this.address)
    }
    _fail(e, r) {
        return Promise.resolve().then(() => {
            gn.throwError(e, Tt.errors.UNSUPPORTED_OPERATION, {
                operation: r
            })
        })
    }
    signMessage(e) {
        return this._fail("VoidSigner cannot sign messages", "signMessage")
    }
    signTransaction(e) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction")
    }
    _signTypedData(e, r, n) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData")
    }
    connect(e) {
        return new Yh(this.address, e)
    }
}

function Ts(t) {
    return "0x" + Ha.keccak_256(ze(t))
}
const bT = "logger/5.7.0";
let q1 = !1,
    j1 = !1;
const wl = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let W1 = wl.default,
    Qh = null;

function vT() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const V1 = vT();
var ed;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(ed || (ed = {}));
var ti;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(ti || (ti = {}));
const K1 = "0123456789abcdef";
class Rt {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        wl[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(W1 > wl[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(Rt.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Rt.levels.INFO, e)
    }
    warn(...e) {
        this._log(Rt.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (j1) return this.makeError("censored error", r, {});
        r || (r = Rt.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += K1[d[A] >> 4], p += K1[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case ti.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case ti.CALL_EXCEPTION:
            case ti.INSUFFICIENT_FUNDS:
            case ti.MISSING_NEW:
            case ti.NONCE_EXPIRED:
            case ti.REPLACEMENT_UNDERPRICED:
            case ti.TRANSACTION_REPLACED:
            case ti.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, Rt.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        V1 && this.throwError("platform missing String.prototype.normalize", Rt.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: V1
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Rt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, Rt.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Rt.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, Rt.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", Rt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Rt.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", Rt.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return Qh || (Qh = new Rt(bT)), Qh
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Rt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), q1) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", Rt.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        j1 = !!e, q1 = !!r
    }
    static setLogLevel(e) {
        const r = wl[e.toLowerCase()];
        if (r == null) {
            Rt.globalLogger().warn("invalid log level - " + e);
            return
        }
        W1 = r
    }
    static from(e) {
        return new Rt(e)
    }
}
Rt.errors = ti;
Rt.levels = ed;
const wT = "strings/5.7.0",
    X1 = new Rt(wT);
var El;
(function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD"
})(El || (El = {}));
var aa;
(function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation"
})(aa || (aa = {}));

function ET(t, e, r, n, i) {
    return X1.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
}

function J1(t, e, r, n, i) {
    if (t === aa.BAD_PREFIX || t === aa.UNEXPECTED_CONTINUE) {
        let s = 0;
        for (let o = e + 1; o < r.length && r[o] >> 6 == 2; o++) s++;
        return s
    }
    return t === aa.OVERRUN ? r.length - e - 1 : 0
}

function AT(t, e, r, n, i) {
    return t === aa.OVERLONG ? (n.push(i), 0) : (n.push(65533), J1(t, e, r))
}
Object.freeze({
    error: ET,
    ignore: J1,
    replace: AT
});

function _T(t, e = El.current) {
    e != El.current && (X1.checkNormalize(), t = t.normalize(e));
    let r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t.charCodeAt(n);
        if (i < 128) r.push(i);
        else if (i < 2048) r.push(i >> 6 | 192), r.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            n++;
            const s = t.charCodeAt(n);
            if (n >= t.length || (s & 64512) != 56320) throw new Error("invalid utf-8 string");
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128)
        } else r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128)
    }
    return ze(r)
}

function so(t) {
    return Ts(_T(t))
}
const TT = "hash/5.7.0";
const MT = "address/5.7.0",
    df = new Rt(MT);

function Z1(t) {
    $t(t, 20) || df.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        r = new Uint8Array(40);
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
    const n = ze(Ts(r));
    for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const NT = 9007199254740991;

function ST(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const td = {};
for (let t = 0; t < 10; t++) td[String(t)] = String(t);
for (let t = 0; t < 26; t++) td[String.fromCharCode(65 + t)] = String(10 + t);
const Y1 = Math.floor(ST(NT));

function PT(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(n => td[n]).join("");
    for (; e.length >= Y1;) {
        let n = e.substring(0, Y1);
        e = parseInt(n, 10) % 97 + e.substring(n.length)
    }
    let r = String(98 - parseInt(e, 10) % 97);
    for (; r.length < 2;) r = "0" + r;
    return r
}

function Q1(t) {
    let e = null;
    if (typeof t != "string" && df.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = Z1(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && df.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== PT(t) && df.throwArgumentError("bad icap checksum", "address", t), e = yl(t.substring(4)); e.length < 40;) e = "0" + e;
        e = Z1("0x" + e)
    } else df.throwArgumentError("invalid address", "address", t);
    return e
}
const IT = "properties/5.7.0";
globalThis && globalThis.__awaiter;
const eb = new Rt(IT);

function pf(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}

function tb(t) {
    const e = {};
    for (const r in t) e[r] = t[r];
    return e
}
const RT = {
    bigint: !0,
    boolean: !0,
    function: !0,
    number: !0,
    string: !0
};

function rb(t) {
    if (t == null || RT[typeof t]) return !0;
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1;
        const e = Object.keys(t);
        for (let r = 0; r < e.length; r++) {
            let n = null;
            try {
                n = t[e[r]]
            } catch {
                continue
            }
            if (!rb(n)) return !1
        }
        return !0
    }
    return eb.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function kT(t) {
    if (rb(t)) return t;
    if (Array.isArray(t)) return Object.freeze(t.map(e => rd(e)));
    if (typeof t == "object") {
        const e = {};
        for (const r in t) {
            const n = t[r];
            n !== void 0 && pf(e, r, rd(n))
        }
        return e
    }
    return eb.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function rd(t) {
    return kT(t)
}
var OT = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const Ft = new Rt(TT),
    nb = new Uint8Array(32);
nb.fill(0);
const CT = Ce.from(-1),
    ib = Ce.from(0),
    sb = Ce.from(1),
    FT = Ce.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function DT(t) {
    const e = ze(t),
        r = e.length % 32;
    return r ? pn([e, nb.slice(r)]) : nt(e)
}
const UT = mn(sb.toHexString(), 32),
    LT = mn(ib.toHexString(), 32),
    ob = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
    },
    nd = ["name", "version", "chainId", "verifyingContract", "salt"];

function ab(t) {
    return function(e) {
        return typeof e != "string" && Ft.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const BT = {
    name: ab("name"),
    version: ab("version"),
    chainId: function(t) {
        try {
            return Ce.from(t).toString()
        } catch {}
        return Ft.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t)
    },
    verifyingContract: function(t) {
        try {
            return Q1(t).toLowerCase()
        } catch {}
        return Ft.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function(t) {
        try {
            const e = ze(t);
            if (e.length !== 32) throw new Error("bad length");
            return nt(e)
        } catch {}
        return Ft.throwArgumentError('invalid domain value "salt"', "domain.salt", t)
    }
};

function id(t) {
    {
        const e = t.match(/^(u?)int(\d*)$/);
        if (e) {
            const r = e[1] === "",
                n = parseInt(e[2] || "256");
            (n % 8 != 0 || n > 256 || e[2] && e[2] !== String(n)) && Ft.throwArgumentError("invalid numeric width", "type", t);
            const i = FT.mask(r ? n - 1 : n),
                s = r ? i.add(sb).mul(CT) : ib;
            return function(o) {
                const f = Ce.from(o);
                return (f.lt(s) || f.gt(i)) && Ft.throwArgumentError(`value out-of-bounds for ${t}`, "value", o), mn(f.toTwos(256).toHexString(), 32)
            }
        }
    } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
            const r = parseInt(e[1]);
            return (r === 0 || r > 32 || e[1] !== String(r)) && Ft.throwArgumentError("invalid bytes width", "type", t),
                function(n) {
                    return ze(n).length !== r && Ft.throwArgumentError(`invalid length for ${t}`, "value", n), DT(n)
                }
        }
    }
    switch (t) {
        case "address":
            return function(e) {
                return mn(Q1(e), 32)
            };
        case "bool":
            return function(e) {
                return e ? UT : LT
            };
        case "bytes":
            return function(e) {
                return Ts(e)
            };
        case "string":
            return function(e) {
                return so(e)
            }
    }
    return null
}

function fb(t, e) {
    return `${t}(${e.map(({name:r,type:n})=>n+" "+r).join(",")})`
}
class Gr {
    constructor(e) {
        pf(this, "types", Object.freeze(rd(e))), pf(this, "_encoderCache", {}), pf(this, "_types", {});
        const r = {},
            n = {},
            i = {};
        Object.keys(e).forEach(f => {
            r[f] = {}, n[f] = [], i[f] = {}
        });
        for (const f in e) {
            const l = {};
            e[f].forEach(d => {
                l[d.name] && Ft.throwArgumentError(`duplicate variable name ${JSON.stringify(d.name)} in ${JSON.stringify(f)}`, "types", e), l[d.name] = !0;
                const p = d.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                p === f && Ft.throwArgumentError(`circular type reference to ${JSON.stringify(p)}`, "types", e), !id(p) && (n[p] || Ft.throwArgumentError(`unknown type ${JSON.stringify(p)}`, "types", e), n[p].push(f), r[f][p] = !0)
            })
        }
        const s = Object.keys(n).filter(f => n[f].length === 0);
        s.length === 0 ? Ft.throwArgumentError("missing primary type", "types", e) : s.length > 1 && Ft.throwArgumentError(`ambiguous primary types or unused types: ${s.map(f=>JSON.stringify(f)).join(", ")}`, "types", e), pf(this, "primaryType", s[0]);

        function o(f, l) {
            l[f] && Ft.throwArgumentError(`circular type reference to ${JSON.stringify(f)}`, "types", e), l[f] = !0, Object.keys(r[f]).forEach(d => {
                !n[d] || (o(d, l), Object.keys(l).forEach(p => {
                    i[p][d] = !0
                }))
            }), delete l[f]
        }
        o(this.primaryType, {});
        for (const f in i) {
            const l = Object.keys(i[f]);
            l.sort(), this._types[f] = fb(f, e[f]) + l.map(d => fb(d, e[d])).join("")
        }
    }
    getEncoder(e) {
        let r = this._encoderCache[e];
        return r || (r = this._encoderCache[e] = this._getEncoder(e)), r
    }
    _getEncoder(e) {
        {
            const i = id(e);
            if (i) return i
        }
        const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (r) {
            const i = r[1],
                s = this.getEncoder(i),
                o = parseInt(r[3]);
            return f => {
                o >= 0 && f.length !== o && Ft.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", f);
                let l = f.map(s);
                return this._types[i] && (l = l.map(Ts)), Ts(pn(l))
            }
        }
        const n = this.types[e];
        if (n) {
            const i = so(this._types[e]);
            return s => {
                const o = n.map(({
                    name: f,
                    type: l
                }) => {
                    const d = this.getEncoder(l)(s[f]);
                    return this._types[l] ? Ts(d) : d
                });
                return o.unshift(i), pn(o)
            }
        }
        return Ft.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const r = this._types[e];
        return r || Ft.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), r
    }
    encodeData(e, r) {
        return this.getEncoder(e)(r)
    }
    hashStruct(e, r) {
        return Ts(this.encodeData(e, r))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, r, n) {
        if (id(e)) return n(e, r);
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (i) {
            const o = i[1],
                f = parseInt(i[3]);
            return f >= 0 && r.length !== f && Ft.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", r), r.map(l => this._visit(o, l, n))
        }
        const s = this.types[e];
        return s ? s.reduce((o, {
            name: f,
            type: l
        }) => (o[f] = this._visit(l, r[f], n), o), {}) : Ft.throwArgumentError(`unknown type: ${e}`, "type", e)
    }
    visit(e, r) {
        return this._visit(this.primaryType, e, r)
    }
    static from(e) {
        return new Gr(e)
    }
    static getPrimaryType(e) {
        return Gr.from(e).primaryType
    }
    static hashStruct(e, r, n) {
        return Gr.from(r).hashStruct(e, n)
    }
    static hashDomain(e) {
        const r = [];
        for (const n in e) {
            const i = ob[n];
            i || Ft.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(n)}`, "domain", e), r.push({
                name: n,
                type: i
            })
        }
        return r.sort((n, i) => nd.indexOf(n.name) - nd.indexOf(i.name)), Gr.hashStruct("EIP712Domain", {
            EIP712Domain: r
        }, e)
    }
    static encode(e, r, n) {
        return pn(["0x1901", Gr.hashDomain(e), Gr.from(r).hash(n)])
    }
    static hash(e, r, n) {
        return Ts(Gr.encode(e, r, n))
    }
    static resolveNames(e, r, n, i) {
        return OT(this, void 0, void 0, function*() {
            e = tb(e);
            const s = {};
            e.verifyingContract && !$t(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
            const o = Gr.from(r);
            o.visit(n, (f, l) => (f === "address" && !$t(l, 20) && (s[l] = "0x"), l));
            for (const f in s) s[f] = yield i(f);
            return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), n = o.visit(n, (f, l) => f === "address" && s[l] ? s[l] : l), {
                domain: e,
                value: n
            }
        })
    }
    static getPayload(e, r, n) {
        Gr.hashDomain(e);
        const i = {},
            s = [];
        nd.forEach(l => {
            const d = e[l];
            d != null && (i[l] = BT[l](d), s.push({
                name: l,
                type: ob[l]
            }))
        });
        const o = Gr.from(r),
            f = tb(r);
        return f.EIP712Domain ? Ft.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", r) : f.EIP712Domain = s, o.encode(n), {
            types: f,
            domain: i,
            primaryType: o.primaryType,
            message: o.visit(n, (l, d) => {
                if (l.match(/^bytes(\d*)/)) return nt(ze(d));
                if (l.match(/^u?int/)) return Ce.from(d).toString();
                switch (l) {
                    case "address":
                        return d.toLowerCase();
                    case "bool":
                        return !!d;
                    case "string":
                        return typeof d != "string" && Ft.throwArgumentError("invalid string", "value", d), d
                }
                return Ft.throwArgumentError("unsupported type", "type", l)
            })
        }
    }
}
class ub {
    constructor(e) {
        Oi(this, "alphabet", e), Oi(this, "base", e.length), Oi(this, "_alphabetMap", {}), Oi(this, "_leader", e.charAt(0));
        for (let r = 0; r < e.length; r++) this._alphabetMap[e.charAt(r)] = r
    }
    encode(e) {
        let r = ze(e);
        if (r.length === 0) return "";
        let n = [0];
        for (let s = 0; s < r.length; ++s) {
            let o = r[s];
            for (let f = 0; f < n.length; ++f) o += n[f] << 8, n[f] = o % this.base, o = o / this.base | 0;
            for (; o > 0;) n.push(o % this.base), o = o / this.base | 0
        }
        let i = "";
        for (let s = 0; r[s] === 0 && s < r.length - 1; ++s) i += this._leader;
        for (let s = n.length - 1; s >= 0; --s) i += this.alphabet[n[s]];
        return i
    }
    decode(e) {
        if (typeof e != "string") throw new TypeError("Expected String");
        let r = [];
        if (e.length === 0) return new Uint8Array(r);
        r.push(0);
        for (let n = 0; n < e.length; n++) {
            let i = this._alphabetMap[e[n]];
            if (i === void 0) throw new Error("Non-base" + this.base + " character");
            let s = i;
            for (let o = 0; o < r.length; ++o) s += r[o] * this.base, r[o] = s & 255, s >>= 8;
            for (; s > 0;) r.push(s & 255), s >>= 8
        }
        for (let n = 0; e[n] === this._leader && n < e.length - 1; ++n) r.push(0);
        return ze(new Uint8Array(r.reverse()))
    }
}
new ub("abcdefghijklmnopqrstuvwxyz234567");
const jS = new ub("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),
    $T = "strings/5.7.0",
    lb = new dt($T);
var Al;
(function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD"
})(Al || (Al = {}));
var fa;
(function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation"
})(fa || (fa = {}));

function GT(t, e, r, n, i) {
    return lb.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
}

function cb(t, e, r, n, i) {
    if (t === fa.BAD_PREFIX || t === fa.UNEXPECTED_CONTINUE) {
        let s = 0;
        for (let o = e + 1; o < r.length && r[o] >> 6 == 2; o++) s++;
        return s
    }
    return t === fa.OVERRUN ? r.length - e - 1 : 0
}

function zT(t, e, r, n, i) {
    return t === fa.OVERLONG ? (n.push(i), 0) : (n.push(65533), cb(t, e, r))
}
Object.freeze({
    error: GT,
    ignore: cb,
    replace: zT
});

function HT(t, e = Al.current) {
    e != Al.current && (lb.checkNormalize(), t = t.normalize(e));
    let r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t.charCodeAt(n);
        if (i < 128) r.push(i);
        else if (i < 2048) r.push(i >> 6 | 192), r.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            n++;
            const s = t.charCodeAt(n);
            if (n >= t.length || (s & 64512) != 56320) throw new Error("invalid utf-8 string");
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128)
        } else r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128)
    }
    return ze(r)
}
var hb;
(function(t) {
    t.sha256 = "sha256", t.sha512 = "sha512"
})(hb || (hb = {}));
const qT = "sha2/5.7.0",
    WS = new dt(qT);
var db = {
    exports: {}
};
(function(t) {
    (function(e, r) {
        function n(m, a) {
            if (!m) throw new Error(a || "Assertion failed")
        }

        function i(m, a) {
            m.super_ = a;
            var c = function() {};
            c.prototype = a.prototype, m.prototype = new c, m.prototype.constructor = m
        }

        function s(m, a, c) {
            if (s.isBN(m)) return m;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((a === "le" || a === "be") && (c = a, a = 10), this._init(m || 0, a || 10, c || "be"))
        }
        typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
        var o;
        try {
            typeof window != "undefined" && typeof window.Buffer != "undefined" ? o = window.Buffer : o = require("buffer").Buffer
        } catch {}
        s.isBN = function(a) {
            return a instanceof s ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words)
        }, s.max = function(a, c) {
            return a.cmp(c) > 0 ? a : c
        }, s.min = function(a, c) {
            return a.cmp(c) < 0 ? a : c
        }, s.prototype._init = function(a, c, g) {
            if (typeof a == "number") return this._initNumber(a, c, g);
            if (typeof a == "object") return this._initArray(a, c, g);
            c === "hex" && (c = 16), n(c === (c | 0) && c >= 2 && c <= 36), a = a.toString().replace(/\s+/g, "");
            var v = 0;
            a[0] === "-" && (v++, this.negative = 1), v < a.length && (c === 16 ? this._parseHex(a, v, g) : (this._parseBase(a, c, v), g === "le" && this._initArray(this.toArray(), c, g)))
        }, s.prototype._initNumber = function(a, c, g) {
            a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [a & 67108863, a / 67108864 & 67108863], this.length = 2) : (n(a < 9007199254740992), this.words = [a & 67108863, a / 67108864 & 67108863, 1], this.length = 3), g === "le" && this._initArray(this.toArray(), c, g)
        }, s.prototype._initArray = function(a, c, g) {
            if (n(typeof a.length == "number"), a.length <= 0) return this.words = [0], this.length = 1, this;
            this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
            for (var v = 0; v < this.length; v++) this.words[v] = 0;
            var x, b, y = 0;
            if (g === "be")
                for (v = a.length - 1, x = 0; v >= 0; v -= 3) b = a[v] | a[v - 1] << 8 | a[v - 2] << 16, this.words[x] |= b << y & 67108863, this.words[x + 1] = b >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, x++);
            else if (g === "le")
                for (v = 0, x = 0; v < a.length; v += 3) b = a[v] | a[v + 1] << 8 | a[v + 2] << 16, this.words[x] |= b << y & 67108863, this.words[x + 1] = b >>> 26 - y & 67108863, y += 24, y >= 26 && (y -= 26, x++);
            return this._strip()
        };

        function f(m, a) {
            var c = m.charCodeAt(a);
            if (c >= 48 && c <= 57) return c - 48;
            if (c >= 65 && c <= 70) return c - 55;
            if (c >= 97 && c <= 102) return c - 87;
            n(!1, "Invalid character in " + m)
        }

        function l(m, a, c) {
            var g = f(m, c);
            return c - 1 >= a && (g |= f(m, c - 1) << 4), g
        }
        s.prototype._parseHex = function(a, c, g) {
            this.length = Math.ceil((a.length - c) / 6), this.words = new Array(this.length);
            for (var v = 0; v < this.length; v++) this.words[v] = 0;
            var x = 0,
                b = 0,
                y;
            if (g === "be")
                for (v = a.length - 1; v >= c; v -= 2) y = l(a, c, v) << x, this.words[b] |= y & 67108863, x >= 18 ? (x -= 18, b += 1, this.words[b] |= y >>> 26) : x += 8;
            else {
                var h = a.length - c;
                for (v = h % 2 == 0 ? c + 1 : c; v < a.length; v += 2) y = l(a, c, v) << x, this.words[b] |= y & 67108863, x >= 18 ? (x -= 18, b += 1, this.words[b] |= y >>> 26) : x += 8
            }
            this._strip()
        };

        function d(m, a, c, g) {
            for (var v = 0, x = 0, b = Math.min(m.length, c), y = a; y < b; y++) {
                var h = m.charCodeAt(y) - 48;
                v *= g, h >= 49 ? x = h - 49 + 10 : h >= 17 ? x = h - 17 + 10 : x = h, n(h >= 0 && x < g, "Invalid character"), v += x
            }
            return v
        }
        s.prototype._parseBase = function(a, c, g) {
            this.words = [0], this.length = 1;
            for (var v = 0, x = 1; x <= 67108863; x *= c) v++;
            v--, x = x / c | 0;
            for (var b = a.length - g, y = b % v, h = Math.min(b, b - y) + g, u = 0, _ = g; _ < h; _ += v) u = d(a, _, _ + v, c), this.imuln(x), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
            if (y !== 0) {
                var L = 1;
                for (u = d(a, _, a.length, c), _ = 0; _ < y; _++) L *= c;
                this.imuln(L), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u)
            }
            this._strip()
        }, s.prototype.copy = function(a) {
            a.words = new Array(this.length);
            for (var c = 0; c < this.length; c++) a.words[c] = this.words[c];
            a.length = this.length, a.negative = this.negative, a.red = this.red
        };

        function p(m, a) {
            m.words = a.words, m.length = a.length, m.negative = a.negative, m.red = a.red
        }
        if (s.prototype._move = function(a) {
                p(a, this)
            }, s.prototype.clone = function() {
                var a = new s(null);
                return this.copy(a), a
            }, s.prototype._expand = function(a) {
                for (; this.length < a;) this.words[this.length++] = 0;
                return this
            }, s.prototype._strip = function() {
                for (; this.length > 1 && this.words[this.length - 1] === 0;) this.length--;
                return this._normSign()
            }, s.prototype._normSign = function() {
                return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }, typeof Symbol != "undefined" && typeof Symbol.for == "function") try {
            s.prototype[Symbol.for("nodejs.util.inspect.custom")] = A
        } catch {
            s.prototype.inspect = A
        } else s.prototype.inspect = A;

        function A() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var T = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            N = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            P = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        s.prototype.toString = function(a, c) {
            a = a || 10, c = c | 0 || 1;
            var g;
            if (a === 16 || a === "hex") {
                g = "";
                for (var v = 0, x = 0, b = 0; b < this.length; b++) {
                    var y = this.words[b],
                        h = ((y << v | x) & 16777215).toString(16);
                    x = y >>> 24 - v & 16777215, v += 2, v >= 26 && (v -= 26, b--), x !== 0 || b !== this.length - 1 ? g = T[6 - h.length] + h + g : g = h + g
                }
                for (x !== 0 && (g = x.toString(16) + g); g.length % c != 0;) g = "0" + g;
                return this.negative !== 0 && (g = "-" + g), g
            }
            if (a === (a | 0) && a >= 2 && a <= 36) {
                var u = N[a],
                    _ = P[a];
                g = "";
                var L = this.clone();
                for (L.negative = 0; !L.isZero();) {
                    var E = L.modrn(_).toString(a);
                    L = L.idivn(_), L.isZero() ? g = E + g : g = T[u - E.length] + E + g
                }
                for (this.isZero() && (g = "0" + g); g.length % c != 0;) g = "0" + g;
                return this.negative !== 0 && (g = "-" + g), g
            }
            n(!1, "Base should be between 2 and 36")
        }, s.prototype.toNumber = function() {
            var a = this.words[0];
            return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a
        }, s.prototype.toJSON = function() {
            return this.toString(16, 2)
        }, o && (s.prototype.toBuffer = function(a, c) {
            return this.toArrayLike(o, a, c)
        }), s.prototype.toArray = function(a, c) {
            return this.toArrayLike(Array, a, c)
        };
        var C = function(a, c) {
            return a.allocUnsafe ? a.allocUnsafe(c) : new a(c)
        };
        s.prototype.toArrayLike = function(a, c, g) {
            this._strip();
            var v = this.byteLength(),
                x = g || Math.max(1, v);
            n(v <= x, "byte array longer than desired length"), n(x > 0, "Requested array length <= 0");
            var b = C(a, x),
                y = c === "le" ? "LE" : "BE";
            return this["_toArrayLike" + y](b, v), b
        }, s.prototype._toArrayLikeLE = function(a, c) {
            for (var g = 0, v = 0, x = 0, b = 0; x < this.length; x++) {
                var y = this.words[x] << b | v;
                a[g++] = y & 255, g < a.length && (a[g++] = y >> 8 & 255), g < a.length && (a[g++] = y >> 16 & 255), b === 6 ? (g < a.length && (a[g++] = y >> 24 & 255), v = 0, b = 0) : (v = y >>> 24, b += 2)
            }
            if (g < a.length)
                for (a[g++] = v; g < a.length;) a[g++] = 0
        }, s.prototype._toArrayLikeBE = function(a, c) {
            for (var g = a.length - 1, v = 0, x = 0, b = 0; x < this.length; x++) {
                var y = this.words[x] << b | v;
                a[g--] = y & 255, g >= 0 && (a[g--] = y >> 8 & 255), g >= 0 && (a[g--] = y >> 16 & 255), b === 6 ? (g >= 0 && (a[g--] = y >> 24 & 255), v = 0, b = 0) : (v = y >>> 24, b += 2)
            }
            if (g >= 0)
                for (a[g--] = v; g >= 0;) a[g--] = 0
        }, Math.clz32 ? s.prototype._countBits = function(a) {
            return 32 - Math.clz32(a)
        } : s.prototype._countBits = function(a) {
            var c = a,
                g = 0;
            return c >= 4096 && (g += 13, c >>>= 13), c >= 64 && (g += 7, c >>>= 7), c >= 8 && (g += 4, c >>>= 4), c >= 2 && (g += 2, c >>>= 2), g + c
        }, s.prototype._zeroBits = function(a) {
            if (a === 0) return 26;
            var c = a,
                g = 0;
            return (c & 8191) == 0 && (g += 13, c >>>= 13), (c & 127) == 0 && (g += 7, c >>>= 7), (c & 15) == 0 && (g += 4, c >>>= 4), (c & 3) == 0 && (g += 2, c >>>= 2), (c & 1) == 0 && g++, g
        }, s.prototype.bitLength = function() {
            var a = this.words[this.length - 1],
                c = this._countBits(a);
            return (this.length - 1) * 26 + c
        };

        function S(m) {
            for (var a = new Array(m.bitLength()), c = 0; c < a.length; c++) {
                var g = c / 26 | 0,
                    v = c % 26;
                a[c] = m.words[g] >>> v & 1
            }
            return a
        }
        s.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var a = 0, c = 0; c < this.length; c++) {
                var g = this._zeroBits(this.words[c]);
                if (a += g, g !== 26) break
            }
            return a
        }, s.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }, s.prototype.toTwos = function(a) {
            return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone()
        }, s.prototype.fromTwos = function(a) {
            return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone()
        }, s.prototype.isNeg = function() {
            return this.negative !== 0
        }, s.prototype.neg = function() {
            return this.clone().ineg()
        }, s.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
        }, s.prototype.iuor = function(a) {
            for (; this.length < a.length;) this.words[this.length++] = 0;
            for (var c = 0; c < a.length; c++) this.words[c] = this.words[c] | a.words[c];
            return this._strip()
        }, s.prototype.ior = function(a) {
            return n((this.negative | a.negative) == 0), this.iuor(a)
        }, s.prototype.or = function(a) {
            return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this)
        }, s.prototype.uor = function(a) {
            return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this)
        }, s.prototype.iuand = function(a) {
            var c;
            this.length > a.length ? c = a : c = this;
            for (var g = 0; g < c.length; g++) this.words[g] = this.words[g] & a.words[g];
            return this.length = c.length, this._strip()
        }, s.prototype.iand = function(a) {
            return n((this.negative | a.negative) == 0), this.iuand(a)
        }, s.prototype.and = function(a) {
            return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this)
        }, s.prototype.uand = function(a) {
            return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this)
        }, s.prototype.iuxor = function(a) {
            var c, g;
            this.length > a.length ? (c = this, g = a) : (c = a, g = this);
            for (var v = 0; v < g.length; v++) this.words[v] = c.words[v] ^ g.words[v];
            if (this !== c)
                for (; v < c.length; v++) this.words[v] = c.words[v];
            return this.length = c.length, this._strip()
        }, s.prototype.ixor = function(a) {
            return n((this.negative | a.negative) == 0), this.iuxor(a)
        }, s.prototype.xor = function(a) {
            return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this)
        }, s.prototype.uxor = function(a) {
            return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this)
        }, s.prototype.inotn = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = Math.ceil(a / 26) | 0,
                g = a % 26;
            this._expand(c), g > 0 && c--;
            for (var v = 0; v < c; v++) this.words[v] = ~this.words[v] & 67108863;
            return g > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - g), this._strip()
        }, s.prototype.notn = function(a) {
            return this.clone().inotn(a)
        }, s.prototype.setn = function(a, c) {
            n(typeof a == "number" && a >= 0);
            var g = a / 26 | 0,
                v = a % 26;
            return this._expand(g + 1), c ? this.words[g] = this.words[g] | 1 << v : this.words[g] = this.words[g] & ~(1 << v), this._strip()
        }, s.prototype.iadd = function(a) {
            var c;
            if (this.negative !== 0 && a.negative === 0) return this.negative = 0, c = this.isub(a), this.negative ^= 1, this._normSign();
            if (this.negative === 0 && a.negative !== 0) return a.negative = 0, c = this.isub(a), a.negative = 1, c._normSign();
            var g, v;
            this.length > a.length ? (g = this, v = a) : (g = a, v = this);
            for (var x = 0, b = 0; b < v.length; b++) c = (g.words[b] | 0) + (v.words[b] | 0) + x, this.words[b] = c & 67108863, x = c >>> 26;
            for (; x !== 0 && b < g.length; b++) c = (g.words[b] | 0) + x, this.words[b] = c & 67108863, x = c >>> 26;
            if (this.length = g.length, x !== 0) this.words[this.length] = x, this.length++;
            else if (g !== this)
                for (; b < g.length; b++) this.words[b] = g.words[b];
            return this
        }, s.prototype.add = function(a) {
            var c;
            return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, c = this.sub(a), a.negative ^= 1, c) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, c = a.sub(this), this.negative = 1, c) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this)
        }, s.prototype.isub = function(a) {
            if (a.negative !== 0) {
                a.negative = 0;
                var c = this.iadd(a);
                return a.negative = 1, c._normSign()
            } else if (this.negative !== 0) return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
            var g = this.cmp(a);
            if (g === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            var v, x;
            g > 0 ? (v = this, x = a) : (v = a, x = this);
            for (var b = 0, y = 0; y < x.length; y++) c = (v.words[y] | 0) - (x.words[y] | 0) + b, b = c >> 26, this.words[y] = c & 67108863;
            for (; b !== 0 && y < v.length; y++) c = (v.words[y] | 0) + b, b = c >> 26, this.words[y] = c & 67108863;
            if (b === 0 && y < v.length && v !== this)
                for (; y < v.length; y++) this.words[y] = v.words[y];
            return this.length = Math.max(this.length, y), v !== this && (this.negative = 1), this._strip()
        }, s.prototype.sub = function(a) {
            return this.clone().isub(a)
        };

        function k(m, a, c) {
            c.negative = a.negative ^ m.negative;
            var g = m.length + a.length | 0;
            c.length = g, g = g - 1 | 0;
            var v = m.words[0] | 0,
                x = a.words[0] | 0,
                b = v * x,
                y = b & 67108863,
                h = b / 67108864 | 0;
            c.words[0] = y;
            for (var u = 1; u < g; u++) {
                for (var _ = h >>> 26, L = h & 67108863, E = Math.min(u, a.length - 1), R = Math.max(0, u - m.length + 1); R <= E; R++) {
                    var G = u - R | 0;
                    v = m.words[G] | 0, x = a.words[R] | 0, b = v * x + L, _ += b / 67108864 | 0, L = b & 67108863
                }
                c.words[u] = L | 0, h = _ | 0
            }
            return h !== 0 ? c.words[u] = h | 0 : c.length--, c._strip()
        }
        var I = function(a, c, g) {
            var v = a.words,
                x = c.words,
                b = g.words,
                y = 0,
                h, u, _, L = v[0] | 0,
                E = L & 8191,
                R = L >>> 13,
                G = v[1] | 0,
                z = G & 8191,
                j = G >>> 13,
                re = v[2] | 0,
                ee = re & 8191,
                K = re >>> 13,
                B = v[3] | 0,
                $ = B & 8191,
                H = B >>> 13,
                ne = v[4] | 0,
                J = ne & 8191,
                Y = ne >>> 13,
                ue = v[5] | 0,
                te = ue & 8191,
                Z = ue >>> 13,
                se = v[6] | 0,
                fe = se & 8191,
                ie = se >>> 13,
                me = v[7] | 0,
                he = me & 8191,
                le = me >>> 13,
                Pe = v[8] | 0,
                xe = Pe & 8191,
                de = Pe >>> 13,
                je = v[9] | 0,
                Ie = je & 8191,
                be = je >>> 13,
                X = x[0] | 0,
                ae = X & 8191,
                oe = X >>> 13,
                ve = x[1] | 0,
                ye = ve & 8191,
                ge = ve >>> 13,
                Ve = x[2] | 0,
                ke = Ve & 8191,
                Ae = Ve >>> 13,
                et = x[3] | 0,
                Oe = et & 8191,
                we = et >>> 13,
                rt = x[4] | 0,
                Fe = rt & 8191,
                Ee = rt >>> 13,
                it = x[5] | 0,
                Le = it & 8191,
                _e = it >>> 13,
                bt = x[6] | 0,
                Be = bt & 8191,
                Te = bt >>> 13,
                vt = x[7] | 0,
                $e = vt & 8191,
                Me = vt >>> 13,
                wt = x[8] | 0,
                Ge = wt & 8191,
                Ne = wt >>> 13,
                Et = x[9] | 0,
                De = Et & 8191,
                Ue = Et >>> 13;
            g.negative = a.negative ^ c.negative, g.length = 19, h = Math.imul(E, ae), u = Math.imul(E, oe), u = u + Math.imul(R, ae) | 0, _ = Math.imul(R, oe);
            var pr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, h = Math.imul(z, ae), u = Math.imul(z, oe), u = u + Math.imul(j, ae) | 0, _ = Math.imul(j, oe), h = h + Math.imul(E, ye) | 0, u = u + Math.imul(E, ge) | 0, u = u + Math.imul(R, ye) | 0, _ = _ + Math.imul(R, ge) | 0;
            var mr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (mr >>> 26) | 0, mr &= 67108863, h = Math.imul(ee, ae), u = Math.imul(ee, oe), u = u + Math.imul(K, ae) | 0, _ = Math.imul(K, oe), h = h + Math.imul(z, ye) | 0, u = u + Math.imul(z, ge) | 0, u = u + Math.imul(j, ye) | 0, _ = _ + Math.imul(j, ge) | 0, h = h + Math.imul(E, ke) | 0, u = u + Math.imul(E, Ae) | 0, u = u + Math.imul(R, ke) | 0, _ = _ + Math.imul(R, Ae) | 0;
            var yr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, h = Math.imul($, ae), u = Math.imul($, oe), u = u + Math.imul(H, ae) | 0, _ = Math.imul(H, oe), h = h + Math.imul(ee, ye) | 0, u = u + Math.imul(ee, ge) | 0, u = u + Math.imul(K, ye) | 0, _ = _ + Math.imul(K, ge) | 0, h = h + Math.imul(z, ke) | 0, u = u + Math.imul(z, Ae) | 0, u = u + Math.imul(j, ke) | 0, _ = _ + Math.imul(j, Ae) | 0, h = h + Math.imul(E, Oe) | 0, u = u + Math.imul(E, we) | 0, u = u + Math.imul(R, Oe) | 0, _ = _ + Math.imul(R, we) | 0;
            var gr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, h = Math.imul(J, ae), u = Math.imul(J, oe), u = u + Math.imul(Y, ae) | 0, _ = Math.imul(Y, oe), h = h + Math.imul($, ye) | 0, u = u + Math.imul($, ge) | 0, u = u + Math.imul(H, ye) | 0, _ = _ + Math.imul(H, ge) | 0, h = h + Math.imul(ee, ke) | 0, u = u + Math.imul(ee, Ae) | 0, u = u + Math.imul(K, ke) | 0, _ = _ + Math.imul(K, Ae) | 0, h = h + Math.imul(z, Oe) | 0, u = u + Math.imul(z, we) | 0, u = u + Math.imul(j, Oe) | 0, _ = _ + Math.imul(j, we) | 0, h = h + Math.imul(E, Fe) | 0, u = u + Math.imul(E, Ee) | 0, u = u + Math.imul(R, Fe) | 0, _ = _ + Math.imul(R, Ee) | 0;
            var xr = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, h = Math.imul(te, ae), u = Math.imul(te, oe), u = u + Math.imul(Z, ae) | 0, _ = Math.imul(Z, oe), h = h + Math.imul(J, ye) | 0, u = u + Math.imul(J, ge) | 0, u = u + Math.imul(Y, ye) | 0, _ = _ + Math.imul(Y, ge) | 0, h = h + Math.imul($, ke) | 0, u = u + Math.imul($, Ae) | 0, u = u + Math.imul(H, ke) | 0, _ = _ + Math.imul(H, Ae) | 0, h = h + Math.imul(ee, Oe) | 0, u = u + Math.imul(ee, we) | 0, u = u + Math.imul(K, Oe) | 0, _ = _ + Math.imul(K, we) | 0, h = h + Math.imul(z, Fe) | 0, u = u + Math.imul(z, Ee) | 0, u = u + Math.imul(j, Fe) | 0, _ = _ + Math.imul(j, Ee) | 0, h = h + Math.imul(E, Le) | 0, u = u + Math.imul(E, _e) | 0, u = u + Math.imul(R, Le) | 0, _ = _ + Math.imul(R, _e) | 0;
            var Tn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Tn >>> 26) | 0, Tn &= 67108863, h = Math.imul(fe, ae), u = Math.imul(fe, oe), u = u + Math.imul(ie, ae) | 0, _ = Math.imul(ie, oe), h = h + Math.imul(te, ye) | 0, u = u + Math.imul(te, ge) | 0, u = u + Math.imul(Z, ye) | 0, _ = _ + Math.imul(Z, ge) | 0, h = h + Math.imul(J, ke) | 0, u = u + Math.imul(J, Ae) | 0, u = u + Math.imul(Y, ke) | 0, _ = _ + Math.imul(Y, Ae) | 0, h = h + Math.imul($, Oe) | 0, u = u + Math.imul($, we) | 0, u = u + Math.imul(H, Oe) | 0, _ = _ + Math.imul(H, we) | 0, h = h + Math.imul(ee, Fe) | 0, u = u + Math.imul(ee, Ee) | 0, u = u + Math.imul(K, Fe) | 0, _ = _ + Math.imul(K, Ee) | 0, h = h + Math.imul(z, Le) | 0, u = u + Math.imul(z, _e) | 0, u = u + Math.imul(j, Le) | 0, _ = _ + Math.imul(j, _e) | 0, h = h + Math.imul(E, Be) | 0, u = u + Math.imul(E, Te) | 0, u = u + Math.imul(R, Be) | 0, _ = _ + Math.imul(R, Te) | 0;
            var Mn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, h = Math.imul(he, ae), u = Math.imul(he, oe), u = u + Math.imul(le, ae) | 0, _ = Math.imul(le, oe), h = h + Math.imul(fe, ye) | 0, u = u + Math.imul(fe, ge) | 0, u = u + Math.imul(ie, ye) | 0, _ = _ + Math.imul(ie, ge) | 0, h = h + Math.imul(te, ke) | 0, u = u + Math.imul(te, Ae) | 0, u = u + Math.imul(Z, ke) | 0, _ = _ + Math.imul(Z, Ae) | 0, h = h + Math.imul(J, Oe) | 0, u = u + Math.imul(J, we) | 0, u = u + Math.imul(Y, Oe) | 0, _ = _ + Math.imul(Y, we) | 0, h = h + Math.imul($, Fe) | 0, u = u + Math.imul($, Ee) | 0, u = u + Math.imul(H, Fe) | 0, _ = _ + Math.imul(H, Ee) | 0, h = h + Math.imul(ee, Le) | 0, u = u + Math.imul(ee, _e) | 0, u = u + Math.imul(K, Le) | 0, _ = _ + Math.imul(K, _e) | 0, h = h + Math.imul(z, Be) | 0, u = u + Math.imul(z, Te) | 0, u = u + Math.imul(j, Be) | 0, _ = _ + Math.imul(j, Te) | 0, h = h + Math.imul(E, $e) | 0, u = u + Math.imul(E, Me) | 0, u = u + Math.imul(R, $e) | 0, _ = _ + Math.imul(R, Me) | 0;
            var Nn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, h = Math.imul(xe, ae), u = Math.imul(xe, oe), u = u + Math.imul(de, ae) | 0, _ = Math.imul(de, oe), h = h + Math.imul(he, ye) | 0, u = u + Math.imul(he, ge) | 0, u = u + Math.imul(le, ye) | 0, _ = _ + Math.imul(le, ge) | 0, h = h + Math.imul(fe, ke) | 0, u = u + Math.imul(fe, Ae) | 0, u = u + Math.imul(ie, ke) | 0, _ = _ + Math.imul(ie, Ae) | 0, h = h + Math.imul(te, Oe) | 0, u = u + Math.imul(te, we) | 0, u = u + Math.imul(Z, Oe) | 0, _ = _ + Math.imul(Z, we) | 0, h = h + Math.imul(J, Fe) | 0, u = u + Math.imul(J, Ee) | 0, u = u + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(Y, Ee) | 0, h = h + Math.imul($, Le) | 0, u = u + Math.imul($, _e) | 0, u = u + Math.imul(H, Le) | 0, _ = _ + Math.imul(H, _e) | 0, h = h + Math.imul(ee, Be) | 0, u = u + Math.imul(ee, Te) | 0, u = u + Math.imul(K, Be) | 0, _ = _ + Math.imul(K, Te) | 0, h = h + Math.imul(z, $e) | 0, u = u + Math.imul(z, Me) | 0, u = u + Math.imul(j, $e) | 0, _ = _ + Math.imul(j, Me) | 0, h = h + Math.imul(E, Ge) | 0, u = u + Math.imul(E, Ne) | 0, u = u + Math.imul(R, Ge) | 0, _ = _ + Math.imul(R, Ne) | 0;
            var Sn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, h = Math.imul(Ie, ae), u = Math.imul(Ie, oe), u = u + Math.imul(be, ae) | 0, _ = Math.imul(be, oe), h = h + Math.imul(xe, ye) | 0, u = u + Math.imul(xe, ge) | 0, u = u + Math.imul(de, ye) | 0, _ = _ + Math.imul(de, ge) | 0, h = h + Math.imul(he, ke) | 0, u = u + Math.imul(he, Ae) | 0, u = u + Math.imul(le, ke) | 0, _ = _ + Math.imul(le, Ae) | 0, h = h + Math.imul(fe, Oe) | 0, u = u + Math.imul(fe, we) | 0, u = u + Math.imul(ie, Oe) | 0, _ = _ + Math.imul(ie, we) | 0, h = h + Math.imul(te, Fe) | 0, u = u + Math.imul(te, Ee) | 0, u = u + Math.imul(Z, Fe) | 0, _ = _ + Math.imul(Z, Ee) | 0, h = h + Math.imul(J, Le) | 0, u = u + Math.imul(J, _e) | 0, u = u + Math.imul(Y, Le) | 0, _ = _ + Math.imul(Y, _e) | 0, h = h + Math.imul($, Be) | 0, u = u + Math.imul($, Te) | 0, u = u + Math.imul(H, Be) | 0, _ = _ + Math.imul(H, Te) | 0, h = h + Math.imul(ee, $e) | 0, u = u + Math.imul(ee, Me) | 0, u = u + Math.imul(K, $e) | 0, _ = _ + Math.imul(K, Me) | 0, h = h + Math.imul(z, Ge) | 0, u = u + Math.imul(z, Ne) | 0, u = u + Math.imul(j, Ge) | 0, _ = _ + Math.imul(j, Ne) | 0, h = h + Math.imul(E, De) | 0, u = u + Math.imul(E, Ue) | 0, u = u + Math.imul(R, De) | 0, _ = _ + Math.imul(R, Ue) | 0;
            var Pn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Pn >>> 26) | 0, Pn &= 67108863, h = Math.imul(Ie, ye), u = Math.imul(Ie, ge), u = u + Math.imul(be, ye) | 0, _ = Math.imul(be, ge), h = h + Math.imul(xe, ke) | 0, u = u + Math.imul(xe, Ae) | 0, u = u + Math.imul(de, ke) | 0, _ = _ + Math.imul(de, Ae) | 0, h = h + Math.imul(he, Oe) | 0, u = u + Math.imul(he, we) | 0, u = u + Math.imul(le, Oe) | 0, _ = _ + Math.imul(le, we) | 0, h = h + Math.imul(fe, Fe) | 0, u = u + Math.imul(fe, Ee) | 0, u = u + Math.imul(ie, Fe) | 0, _ = _ + Math.imul(ie, Ee) | 0, h = h + Math.imul(te, Le) | 0, u = u + Math.imul(te, _e) | 0, u = u + Math.imul(Z, Le) | 0, _ = _ + Math.imul(Z, _e) | 0, h = h + Math.imul(J, Be) | 0, u = u + Math.imul(J, Te) | 0, u = u + Math.imul(Y, Be) | 0, _ = _ + Math.imul(Y, Te) | 0, h = h + Math.imul($, $e) | 0, u = u + Math.imul($, Me) | 0, u = u + Math.imul(H, $e) | 0, _ = _ + Math.imul(H, Me) | 0, h = h + Math.imul(ee, Ge) | 0, u = u + Math.imul(ee, Ne) | 0, u = u + Math.imul(K, Ge) | 0, _ = _ + Math.imul(K, Ne) | 0, h = h + Math.imul(z, De) | 0, u = u + Math.imul(z, Ue) | 0, u = u + Math.imul(j, De) | 0, _ = _ + Math.imul(j, Ue) | 0;
            var In = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, h = Math.imul(Ie, ke), u = Math.imul(Ie, Ae), u = u + Math.imul(be, ke) | 0, _ = Math.imul(be, Ae), h = h + Math.imul(xe, Oe) | 0, u = u + Math.imul(xe, we) | 0, u = u + Math.imul(de, Oe) | 0, _ = _ + Math.imul(de, we) | 0, h = h + Math.imul(he, Fe) | 0, u = u + Math.imul(he, Ee) | 0, u = u + Math.imul(le, Fe) | 0, _ = _ + Math.imul(le, Ee) | 0, h = h + Math.imul(fe, Le) | 0, u = u + Math.imul(fe, _e) | 0, u = u + Math.imul(ie, Le) | 0, _ = _ + Math.imul(ie, _e) | 0, h = h + Math.imul(te, Be) | 0, u = u + Math.imul(te, Te) | 0, u = u + Math.imul(Z, Be) | 0, _ = _ + Math.imul(Z, Te) | 0, h = h + Math.imul(J, $e) | 0, u = u + Math.imul(J, Me) | 0, u = u + Math.imul(Y, $e) | 0, _ = _ + Math.imul(Y, Me) | 0, h = h + Math.imul($, Ge) | 0, u = u + Math.imul($, Ne) | 0, u = u + Math.imul(H, Ge) | 0, _ = _ + Math.imul(H, Ne) | 0, h = h + Math.imul(ee, De) | 0, u = u + Math.imul(ee, Ue) | 0, u = u + Math.imul(K, De) | 0, _ = _ + Math.imul(K, Ue) | 0;
            var Rn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Rn >>> 26) | 0, Rn &= 67108863, h = Math.imul(Ie, Oe), u = Math.imul(Ie, we), u = u + Math.imul(be, Oe) | 0, _ = Math.imul(be, we), h = h + Math.imul(xe, Fe) | 0, u = u + Math.imul(xe, Ee) | 0, u = u + Math.imul(de, Fe) | 0, _ = _ + Math.imul(de, Ee) | 0, h = h + Math.imul(he, Le) | 0, u = u + Math.imul(he, _e) | 0, u = u + Math.imul(le, Le) | 0, _ = _ + Math.imul(le, _e) | 0, h = h + Math.imul(fe, Be) | 0, u = u + Math.imul(fe, Te) | 0, u = u + Math.imul(ie, Be) | 0, _ = _ + Math.imul(ie, Te) | 0, h = h + Math.imul(te, $e) | 0, u = u + Math.imul(te, Me) | 0, u = u + Math.imul(Z, $e) | 0, _ = _ + Math.imul(Z, Me) | 0, h = h + Math.imul(J, Ge) | 0, u = u + Math.imul(J, Ne) | 0, u = u + Math.imul(Y, Ge) | 0, _ = _ + Math.imul(Y, Ne) | 0, h = h + Math.imul($, De) | 0, u = u + Math.imul($, Ue) | 0, u = u + Math.imul(H, De) | 0, _ = _ + Math.imul(H, Ue) | 0;
            var kn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, h = Math.imul(Ie, Fe), u = Math.imul(Ie, Ee), u = u + Math.imul(be, Fe) | 0, _ = Math.imul(be, Ee), h = h + Math.imul(xe, Le) | 0, u = u + Math.imul(xe, _e) | 0, u = u + Math.imul(de, Le) | 0, _ = _ + Math.imul(de, _e) | 0, h = h + Math.imul(he, Be) | 0, u = u + Math.imul(he, Te) | 0, u = u + Math.imul(le, Be) | 0, _ = _ + Math.imul(le, Te) | 0, h = h + Math.imul(fe, $e) | 0, u = u + Math.imul(fe, Me) | 0, u = u + Math.imul(ie, $e) | 0, _ = _ + Math.imul(ie, Me) | 0, h = h + Math.imul(te, Ge) | 0, u = u + Math.imul(te, Ne) | 0, u = u + Math.imul(Z, Ge) | 0, _ = _ + Math.imul(Z, Ne) | 0, h = h + Math.imul(J, De) | 0, u = u + Math.imul(J, Ue) | 0, u = u + Math.imul(Y, De) | 0, _ = _ + Math.imul(Y, Ue) | 0;
            var On = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (On >>> 26) | 0, On &= 67108863, h = Math.imul(Ie, Le), u = Math.imul(Ie, _e), u = u + Math.imul(be, Le) | 0, _ = Math.imul(be, _e), h = h + Math.imul(xe, Be) | 0, u = u + Math.imul(xe, Te) | 0, u = u + Math.imul(de, Be) | 0, _ = _ + Math.imul(de, Te) | 0, h = h + Math.imul(he, $e) | 0, u = u + Math.imul(he, Me) | 0, u = u + Math.imul(le, $e) | 0, _ = _ + Math.imul(le, Me) | 0, h = h + Math.imul(fe, Ge) | 0, u = u + Math.imul(fe, Ne) | 0, u = u + Math.imul(ie, Ge) | 0, _ = _ + Math.imul(ie, Ne) | 0, h = h + Math.imul(te, De) | 0, u = u + Math.imul(te, Ue) | 0, u = u + Math.imul(Z, De) | 0, _ = _ + Math.imul(Z, Ue) | 0;
            var Cn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, h = Math.imul(Ie, Be), u = Math.imul(Ie, Te), u = u + Math.imul(be, Be) | 0, _ = Math.imul(be, Te), h = h + Math.imul(xe, $e) | 0, u = u + Math.imul(xe, Me) | 0, u = u + Math.imul(de, $e) | 0, _ = _ + Math.imul(de, Me) | 0, h = h + Math.imul(he, Ge) | 0, u = u + Math.imul(he, Ne) | 0, u = u + Math.imul(le, Ge) | 0, _ = _ + Math.imul(le, Ne) | 0, h = h + Math.imul(fe, De) | 0, u = u + Math.imul(fe, Ue) | 0, u = u + Math.imul(ie, De) | 0, _ = _ + Math.imul(ie, Ue) | 0;
            var Fn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Fn >>> 26) | 0, Fn &= 67108863, h = Math.imul(Ie, $e), u = Math.imul(Ie, Me), u = u + Math.imul(be, $e) | 0, _ = Math.imul(be, Me), h = h + Math.imul(xe, Ge) | 0, u = u + Math.imul(xe, Ne) | 0, u = u + Math.imul(de, Ge) | 0, _ = _ + Math.imul(de, Ne) | 0, h = h + Math.imul(he, De) | 0, u = u + Math.imul(he, Ue) | 0, u = u + Math.imul(le, De) | 0, _ = _ + Math.imul(le, Ue) | 0;
            var Dn = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, h = Math.imul(Ie, Ge), u = Math.imul(Ie, Ne), u = u + Math.imul(be, Ge) | 0, _ = Math.imul(be, Ne), h = h + Math.imul(xe, De) | 0, u = u + Math.imul(xe, Ue) | 0, u = u + Math.imul(de, De) | 0, _ = _ + Math.imul(de, Ue) | 0;
            var Rs = (y + h | 0) + ((u & 8191) << 13) | 0;
            y = (_ + (u >>> 13) | 0) + (Rs >>> 26) | 0, Rs &= 67108863, h = Math.imul(Ie, De), u = Math.imul(Ie, Ue), u = u + Math.imul(be, De) | 0, _ = Math.imul(be, Ue);
            var ks = (y + h | 0) + ((u & 8191) << 13) | 0;
            return y = (_ + (u >>> 13) | 0) + (ks >>> 26) | 0, ks &= 67108863, b[0] = pr, b[1] = mr, b[2] = yr, b[3] = gr, b[4] = xr, b[5] = Tn, b[6] = Mn, b[7] = Nn, b[8] = Sn, b[9] = Pn, b[10] = In, b[11] = Rn, b[12] = kn, b[13] = On, b[14] = Cn, b[15] = Fn, b[16] = Dn, b[17] = Rs, b[18] = ks, y !== 0 && (b[19] = y, g.length++), g
        };
        Math.imul || (I = k);

        function U(m, a, c) {
            c.negative = a.negative ^ m.negative, c.length = m.length + a.length;
            for (var g = 0, v = 0, x = 0; x < c.length - 1; x++) {
                var b = v;
                v = 0;
                for (var y = g & 67108863, h = Math.min(x, a.length - 1), u = Math.max(0, x - m.length + 1); u <= h; u++) {
                    var _ = x - u,
                        L = m.words[_] | 0,
                        E = a.words[u] | 0,
                        R = L * E,
                        G = R & 67108863;
                    b = b + (R / 67108864 | 0) | 0, G = G + y | 0, y = G & 67108863, b = b + (G >>> 26) | 0, v += b >>> 26, b &= 67108863
                }
                c.words[x] = y, g = b, b = v
            }
            return g !== 0 ? c.words[x] = g : c.length--, c._strip()
        }

        function M(m, a, c) {
            return U(m, a, c)
        }
        s.prototype.mulTo = function(a, c) {
            var g, v = this.length + a.length;
            return this.length === 10 && a.length === 10 ? g = I(this, a, c) : v < 63 ? g = k(this, a, c) : v < 1024 ? g = U(this, a, c) : g = M(this, a, c), g
        }, s.prototype.mul = function(a) {
            var c = new s(null);
            return c.words = new Array(this.length + a.length), this.mulTo(a, c)
        }, s.prototype.mulf = function(a) {
            var c = new s(null);
            return c.words = new Array(this.length + a.length), M(this, a, c)
        }, s.prototype.imul = function(a) {
            return this.clone().mulTo(a, this)
        }, s.prototype.imuln = function(a) {
            var c = a < 0;
            c && (a = -a), n(typeof a == "number"), n(a < 67108864);
            for (var g = 0, v = 0; v < this.length; v++) {
                var x = (this.words[v] | 0) * a,
                    b = (x & 67108863) + (g & 67108863);
                g >>= 26, g += x / 67108864 | 0, g += b >>> 26, this.words[v] = b & 67108863
            }
            return g !== 0 && (this.words[v] = g, this.length++), c ? this.ineg() : this
        }, s.prototype.muln = function(a) {
            return this.clone().imuln(a)
        }, s.prototype.sqr = function() {
            return this.mul(this)
        }, s.prototype.isqr = function() {
            return this.imul(this.clone())
        }, s.prototype.pow = function(a) {
            var c = S(a);
            if (c.length === 0) return new s(1);
            for (var g = this, v = 0; v < c.length && c[v] === 0; v++, g = g.sqr());
            if (++v < c.length)
                for (var x = g.sqr(); v < c.length; v++, x = x.sqr()) c[v] !== 0 && (g = g.mul(x));
            return g
        }, s.prototype.iushln = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = a % 26,
                g = (a - c) / 26,
                v = 67108863 >>> 26 - c << 26 - c,
                x;
            if (c !== 0) {
                var b = 0;
                for (x = 0; x < this.length; x++) {
                    var y = this.words[x] & v,
                        h = (this.words[x] | 0) - y << c;
                    this.words[x] = h | b, b = y >>> 26 - c
                }
                b && (this.words[x] = b, this.length++)
            }
            if (g !== 0) {
                for (x = this.length - 1; x >= 0; x--) this.words[x + g] = this.words[x];
                for (x = 0; x < g; x++) this.words[x] = 0;
                this.length += g
            }
            return this._strip()
        }, s.prototype.ishln = function(a) {
            return n(this.negative === 0), this.iushln(a)
        }, s.prototype.iushrn = function(a, c, g) {
            n(typeof a == "number" && a >= 0);
            var v;
            c ? v = (c - c % 26) / 26 : v = 0;
            var x = a % 26,
                b = Math.min((a - x) / 26, this.length),
                y = 67108863 ^ 67108863 >>> x << x,
                h = g;
            if (v -= b, v = Math.max(0, v), h) {
                for (var u = 0; u < b; u++) h.words[u] = this.words[u];
                h.length = b
            }
            if (b !== 0)
                if (this.length > b)
                    for (this.length -= b, u = 0; u < this.length; u++) this.words[u] = this.words[u + b];
                else this.words[0] = 0, this.length = 1;
            var _ = 0;
            for (u = this.length - 1; u >= 0 && (_ !== 0 || u >= v); u--) {
                var L = this.words[u] | 0;
                this.words[u] = _ << 26 - x | L >>> x, _ = L & y
            }
            return h && _ !== 0 && (h.words[h.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip()
        }, s.prototype.ishrn = function(a, c, g) {
            return n(this.negative === 0), this.iushrn(a, c, g)
        }, s.prototype.shln = function(a) {
            return this.clone().ishln(a)
        }, s.prototype.ushln = function(a) {
            return this.clone().iushln(a)
        }, s.prototype.shrn = function(a) {
            return this.clone().ishrn(a)
        }, s.prototype.ushrn = function(a) {
            return this.clone().iushrn(a)
        }, s.prototype.testn = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = a % 26,
                g = (a - c) / 26,
                v = 1 << c;
            if (this.length <= g) return !1;
            var x = this.words[g];
            return !!(x & v)
        }, s.prototype.imaskn = function(a) {
            n(typeof a == "number" && a >= 0);
            var c = a % 26,
                g = (a - c) / 26;
            if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g) return this;
            if (c !== 0 && g++, this.length = Math.min(g, this.length), c !== 0) {
                var v = 67108863 ^ 67108863 >>> c << c;
                this.words[this.length - 1] &= v
            }
            return this._strip()
        }, s.prototype.maskn = function(a) {
            return this.clone().imaskn(a)
        }, s.prototype.iaddn = function(a) {
            return n(typeof a == "number"), n(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a)
        }, s.prototype._iaddn = function(a) {
            this.words[0] += a;
            for (var c = 0; c < this.length && this.words[c] >= 67108864; c++) this.words[c] -= 67108864, c === this.length - 1 ? this.words[c + 1] = 1 : this.words[c + 1]++;
            return this.length = Math.max(this.length, c + 1), this
        }, s.prototype.isubn = function(a) {
            if (n(typeof a == "number"), n(a < 67108864), a < 0) return this.iaddn(-a);
            if (this.negative !== 0) return this.negative = 0, this.iaddn(a), this.negative = 1, this;
            if (this.words[0] -= a, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
            else
                for (var c = 0; c < this.length && this.words[c] < 0; c++) this.words[c] += 67108864, this.words[c + 1] -= 1;
            return this._strip()
        }, s.prototype.addn = function(a) {
            return this.clone().iaddn(a)
        }, s.prototype.subn = function(a) {
            return this.clone().isubn(a)
        }, s.prototype.iabs = function() {
            return this.negative = 0, this
        }, s.prototype.abs = function() {
            return this.clone().iabs()
        }, s.prototype._ishlnsubmul = function(a, c, g) {
            var v = a.length + g,
                x;
            this._expand(v);
            var b, y = 0;
            for (x = 0; x < a.length; x++) {
                b = (this.words[x + g] | 0) + y;
                var h = (a.words[x] | 0) * c;
                b -= h & 67108863, y = (b >> 26) - (h / 67108864 | 0), this.words[x + g] = b & 67108863
            }
            for (; x < this.length - g; x++) b = (this.words[x + g] | 0) + y, y = b >> 26, this.words[x + g] = b & 67108863;
            if (y === 0) return this._strip();
            for (n(y === -1), y = 0, x = 0; x < this.length; x++) b = -(this.words[x] | 0) + y, y = b >> 26, this.words[x] = b & 67108863;
            return this.negative = 1, this._strip()
        }, s.prototype._wordDiv = function(a, c) {
            var g = this.length - a.length,
                v = this.clone(),
                x = a,
                b = x.words[x.length - 1] | 0,
                y = this._countBits(b);
            g = 26 - y, g !== 0 && (x = x.ushln(g), v.iushln(g), b = x.words[x.length - 1] | 0);
            var h = v.length - x.length,
                u;
            if (c !== "mod") {
                u = new s(null), u.length = h + 1, u.words = new Array(u.length);
                for (var _ = 0; _ < u.length; _++) u.words[_] = 0
            }
            var L = v.clone()._ishlnsubmul(x, 1, h);
            L.negative === 0 && (v = L, u && (u.words[h] = 1));
            for (var E = h - 1; E >= 0; E--) {
                var R = (v.words[x.length + E] | 0) * 67108864 + (v.words[x.length + E - 1] | 0);
                for (R = Math.min(R / b | 0, 67108863), v._ishlnsubmul(x, R, E); v.negative !== 0;) R--, v.negative = 0, v._ishlnsubmul(x, 1, E), v.isZero() || (v.negative ^= 1);
                u && (u.words[E] = R)
            }
            return u && u._strip(), v._strip(), c !== "div" && g !== 0 && v.iushrn(g), {
                div: u || null,
                mod: v
            }
        }, s.prototype.divmod = function(a, c, g) {
            if (n(!a.isZero()), this.isZero()) return {
                div: new s(0),
                mod: new s(0)
            };
            var v, x, b;
            return this.negative !== 0 && a.negative === 0 ? (b = this.neg().divmod(a, c), c !== "mod" && (v = b.div.neg()), c !== "div" && (x = b.mod.neg(), g && x.negative !== 0 && x.iadd(a)), {
                div: v,
                mod: x
            }) : this.negative === 0 && a.negative !== 0 ? (b = this.divmod(a.neg(), c), c !== "mod" && (v = b.div.neg()), {
                div: v,
                mod: b.mod
            }) : (this.negative & a.negative) != 0 ? (b = this.neg().divmod(a.neg(), c), c !== "div" && (x = b.mod.neg(), g && x.negative !== 0 && x.isub(a)), {
                div: b.div,
                mod: x
            }) : a.length > this.length || this.cmp(a) < 0 ? {
                div: new s(0),
                mod: this
            } : a.length === 1 ? c === "div" ? {
                div: this.divn(a.words[0]),
                mod: null
            } : c === "mod" ? {
                div: null,
                mod: new s(this.modrn(a.words[0]))
            } : {
                div: this.divn(a.words[0]),
                mod: new s(this.modrn(a.words[0]))
            } : this._wordDiv(a, c)
        }, s.prototype.div = function(a) {
            return this.divmod(a, "div", !1).div
        }, s.prototype.mod = function(a) {
            return this.divmod(a, "mod", !1).mod
        }, s.prototype.umod = function(a) {
            return this.divmod(a, "mod", !0).mod
        }, s.prototype.divRound = function(a) {
            var c = this.divmod(a);
            if (c.mod.isZero()) return c.div;
            var g = c.div.negative !== 0 ? c.mod.isub(a) : c.mod,
                v = a.ushrn(1),
                x = a.andln(1),
                b = g.cmp(v);
            return b < 0 || x === 1 && b === 0 ? c.div : c.div.negative !== 0 ? c.div.isubn(1) : c.div.iaddn(1)
        }, s.prototype.modrn = function(a) {
            var c = a < 0;
            c && (a = -a), n(a <= 67108863);
            for (var g = (1 << 26) % a, v = 0, x = this.length - 1; x >= 0; x--) v = (g * v + (this.words[x] | 0)) % a;
            return c ? -v : v
        }, s.prototype.modn = function(a) {
            return this.modrn(a)
        }, s.prototype.idivn = function(a) {
            var c = a < 0;
            c && (a = -a), n(a <= 67108863);
            for (var g = 0, v = this.length - 1; v >= 0; v--) {
                var x = (this.words[v] | 0) + g * 67108864;
                this.words[v] = x / a | 0, g = x % a
            }
            return this._strip(), c ? this.ineg() : this
        }, s.prototype.divn = function(a) {
            return this.clone().idivn(a)
        }, s.prototype.egcd = function(a) {
            n(a.negative === 0), n(!a.isZero());
            var c = this,
                g = a.clone();
            c.negative !== 0 ? c = c.umod(a) : c = c.clone();
            for (var v = new s(1), x = new s(0), b = new s(0), y = new s(1), h = 0; c.isEven() && g.isEven();) c.iushrn(1), g.iushrn(1), ++h;
            for (var u = g.clone(), _ = c.clone(); !c.isZero();) {
                for (var L = 0, E = 1;
                    (c.words[0] & E) == 0 && L < 26; ++L, E <<= 1);
                if (L > 0)
                    for (c.iushrn(L); L-- > 0;)(v.isOdd() || x.isOdd()) && (v.iadd(u), x.isub(_)), v.iushrn(1), x.iushrn(1);
                for (var R = 0, G = 1;
                    (g.words[0] & G) == 0 && R < 26; ++R, G <<= 1);
                if (R > 0)
                    for (g.iushrn(R); R-- > 0;)(b.isOdd() || y.isOdd()) && (b.iadd(u), y.isub(_)), b.iushrn(1), y.iushrn(1);
                c.cmp(g) >= 0 ? (c.isub(g), v.isub(b), x.isub(y)) : (g.isub(c), b.isub(v), y.isub(x))
            }
            return {
                a: b,
                b: y,
                gcd: g.iushln(h)
            }
        }, s.prototype._invmp = function(a) {
            n(a.negative === 0), n(!a.isZero());
            var c = this,
                g = a.clone();
            c.negative !== 0 ? c = c.umod(a) : c = c.clone();
            for (var v = new s(1), x = new s(0), b = g.clone(); c.cmpn(1) > 0 && g.cmpn(1) > 0;) {
                for (var y = 0, h = 1;
                    (c.words[0] & h) == 0 && y < 26; ++y, h <<= 1);
                if (y > 0)
                    for (c.iushrn(y); y-- > 0;) v.isOdd() && v.iadd(b), v.iushrn(1);
                for (var u = 0, _ = 1;
                    (g.words[0] & _) == 0 && u < 26; ++u, _ <<= 1);
                if (u > 0)
                    for (g.iushrn(u); u-- > 0;) x.isOdd() && x.iadd(b), x.iushrn(1);
                c.cmp(g) >= 0 ? (c.isub(g), v.isub(x)) : (g.isub(c), x.isub(v))
            }
            var L;
            return c.cmpn(1) === 0 ? L = v : L = x, L.cmpn(0) < 0 && L.iadd(a), L
        }, s.prototype.gcd = function(a) {
            if (this.isZero()) return a.abs();
            if (a.isZero()) return this.abs();
            var c = this.clone(),
                g = a.clone();
            c.negative = 0, g.negative = 0;
            for (var v = 0; c.isEven() && g.isEven(); v++) c.iushrn(1), g.iushrn(1);
            do {
                for (; c.isEven();) c.iushrn(1);
                for (; g.isEven();) g.iushrn(1);
                var x = c.cmp(g);
                if (x < 0) {
                    var b = c;
                    c = g, g = b
                } else if (x === 0 || g.cmpn(1) === 0) break;
                c.isub(g)
            } while (!0);
            return g.iushln(v)
        }, s.prototype.invm = function(a) {
            return this.egcd(a).a.umod(a)
        }, s.prototype.isEven = function() {
            return (this.words[0] & 1) == 0
        }, s.prototype.isOdd = function() {
            return (this.words[0] & 1) == 1
        }, s.prototype.andln = function(a) {
            return this.words[0] & a
        }, s.prototype.bincn = function(a) {
            n(typeof a == "number");
            var c = a % 26,
                g = (a - c) / 26,
                v = 1 << c;
            if (this.length <= g) return this._expand(g + 1), this.words[g] |= v, this;
            for (var x = v, b = g; x !== 0 && b < this.length; b++) {
                var y = this.words[b] | 0;
                y += x, x = y >>> 26, y &= 67108863, this.words[b] = y
            }
            return x !== 0 && (this.words[b] = x, this.length++), this
        }, s.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }, s.prototype.cmpn = function(a) {
            var c = a < 0;
            if (this.negative !== 0 && !c) return -1;
            if (this.negative === 0 && c) return 1;
            this._strip();
            var g;
            if (this.length > 1) g = 1;
            else {
                c && (a = -a), n(a <= 67108863, "Number is too big");
                var v = this.words[0] | 0;
                g = v === a ? 0 : v < a ? -1 : 1
            }
            return this.negative !== 0 ? -g | 0 : g
        }, s.prototype.cmp = function(a) {
            if (this.negative !== 0 && a.negative === 0) return -1;
            if (this.negative === 0 && a.negative !== 0) return 1;
            var c = this.ucmp(a);
            return this.negative !== 0 ? -c | 0 : c
        }, s.prototype.ucmp = function(a) {
            if (this.length > a.length) return 1;
            if (this.length < a.length) return -1;
            for (var c = 0, g = this.length - 1; g >= 0; g--) {
                var v = this.words[g] | 0,
                    x = a.words[g] | 0;
                if (v !== x) {
                    v < x ? c = -1 : v > x && (c = 1);
                    break
                }
            }
            return c
        }, s.prototype.gtn = function(a) {
            return this.cmpn(a) === 1
        }, s.prototype.gt = function(a) {
            return this.cmp(a) === 1
        }, s.prototype.gten = function(a) {
            return this.cmpn(a) >= 0
        }, s.prototype.gte = function(a) {
            return this.cmp(a) >= 0
        }, s.prototype.ltn = function(a) {
            return this.cmpn(a) === -1
        }, s.prototype.lt = function(a) {
            return this.cmp(a) === -1
        }, s.prototype.lten = function(a) {
            return this.cmpn(a) <= 0
        }, s.prototype.lte = function(a) {
            return this.cmp(a) <= 0
        }, s.prototype.eqn = function(a) {
            return this.cmpn(a) === 0
        }, s.prototype.eq = function(a) {
            return this.cmp(a) === 0
        }, s.red = function(a) {
            return new O(a)
        }, s.prototype.toRed = function(a) {
            return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a)
        }, s.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
        }, s.prototype._forceRed = function(a) {
            return this.red = a, this
        }, s.prototype.forceRed = function(a) {
            return n(!this.red, "Already a number in reduction context"), this._forceRed(a)
        }, s.prototype.redAdd = function(a) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, a)
        }, s.prototype.redIAdd = function(a) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a)
        }, s.prototype.redSub = function(a) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, a)
        }, s.prototype.redISub = function(a) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, a)
        }, s.prototype.redShl = function(a) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, a)
        }, s.prototype.redMul = function(a) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a)
        }, s.prototype.redIMul = function(a) {
            return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a)
        }, s.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
        }, s.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
        }, s.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
        }, s.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
        }, s.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
        }, s.prototype.redPow = function(a) {
            return n(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a)
        };
        var F = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };

        function D(m, a) {
            this.name = m, this.p = new s(a, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
        }
        D.prototype._tmp = function() {
            var a = new s(null);
            return a.words = new Array(Math.ceil(this.n / 13)), a
        }, D.prototype.ireduce = function(a) {
            var c = a,
                g;
            do this.split(c, this.tmp), c = this.imulK(c), c = c.iadd(this.tmp), g = c.bitLength(); while (g > this.n);
            var v = g < this.n ? -1 : c.ucmp(this.p);
            return v === 0 ? (c.words[0] = 0, c.length = 1) : v > 0 ? c.isub(this.p) : c.strip !== void 0 ? c.strip() : c._strip(), c
        }, D.prototype.split = function(a, c) {
            a.iushrn(this.n, 0, c)
        }, D.prototype.imulK = function(a) {
            return a.imul(this.k)
        };

        function q() {
            D.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        i(q, D), q.prototype.split = function(a, c) {
            for (var g = 4194303, v = Math.min(a.length, 9), x = 0; x < v; x++) c.words[x] = a.words[x];
            if (c.length = v, a.length <= 9) {
                a.words[0] = 0, a.length = 1;
                return
            }
            var b = a.words[9];
            for (c.words[c.length++] = b & g, x = 10; x < a.length; x++) {
                var y = a.words[x] | 0;
                a.words[x - 10] = (y & g) << 4 | b >>> 22, b = y
            }
            b >>>= 22, a.words[x - 10] = b, b === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9
        }, q.prototype.imulK = function(a) {
            a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
            for (var c = 0, g = 0; g < a.length; g++) {
                var v = a.words[g] | 0;
                c += v * 977, a.words[g] = c & 67108863, c = v * 64 + (c / 67108864 | 0)
            }
            return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a
        };

        function V() {
            D.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        i(V, D);

        function Q() {
            D.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        i(Q, D);

        function ce() {
            D.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        i(ce, D), ce.prototype.imulK = function(a) {
            for (var c = 0, g = 0; g < a.length; g++) {
                var v = (a.words[g] | 0) * 19 + c,
                    x = v & 67108863;
                v >>>= 26, a.words[g] = x, c = v
            }
            return c !== 0 && (a.words[a.length++] = c), a
        }, s._prime = function(a) {
            if (F[a]) return F[a];
            var c;
            if (a === "k256") c = new q;
            else if (a === "p224") c = new V;
            else if (a === "p192") c = new Q;
            else if (a === "p25519") c = new ce;
            else throw new Error("Unknown prime " + a);
            return F[a] = c, c
        };

        function O(m) {
            if (typeof m == "string") {
                var a = s._prime(m);
                this.m = a.p, this.prime = a
            } else n(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null
        }
        O.prototype._verify1 = function(a) {
            n(a.negative === 0, "red works only with positives"), n(a.red, "red works only with red numbers")
        }, O.prototype._verify2 = function(a, c) {
            n((a.negative | c.negative) == 0, "red works only with positives"), n(a.red && a.red === c.red, "red works only with red numbers")
        }, O.prototype.imod = function(a) {
            return this.prime ? this.prime.ireduce(a)._forceRed(this) : (p(a, a.umod(this.m)._forceRed(this)), a)
        }, O.prototype.neg = function(a) {
            return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this)
        }, O.prototype.add = function(a, c) {
            this._verify2(a, c);
            var g = a.add(c);
            return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this)
        }, O.prototype.iadd = function(a, c) {
            this._verify2(a, c);
            var g = a.iadd(c);
            return g.cmp(this.m) >= 0 && g.isub(this.m), g
        }, O.prototype.sub = function(a, c) {
            this._verify2(a, c);
            var g = a.sub(c);
            return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this)
        }, O.prototype.isub = function(a, c) {
            this._verify2(a, c);
            var g = a.isub(c);
            return g.cmpn(0) < 0 && g.iadd(this.m), g
        }, O.prototype.shl = function(a, c) {
            return this._verify1(a), this.imod(a.ushln(c))
        }, O.prototype.imul = function(a, c) {
            return this._verify2(a, c), this.imod(a.imul(c))
        }, O.prototype.mul = function(a, c) {
            return this._verify2(a, c), this.imod(a.mul(c))
        }, O.prototype.isqr = function(a) {
            return this.imul(a, a.clone())
        }, O.prototype.sqr = function(a) {
            return this.mul(a, a)
        }, O.prototype.sqrt = function(a) {
            if (a.isZero()) return a.clone();
            var c = this.m.andln(3);
            if (n(c % 2 == 1), c === 3) {
                var g = this.m.add(new s(1)).iushrn(2);
                return this.pow(a, g)
            }
            for (var v = this.m.subn(1), x = 0; !v.isZero() && v.andln(1) === 0;) x++, v.iushrn(1);
            n(!v.isZero());
            var b = new s(1).toRed(this),
                y = b.redNeg(),
                h = this.m.subn(1).iushrn(1),
                u = this.m.bitLength();
            for (u = new s(2 * u * u).toRed(this); this.pow(u, h).cmp(y) !== 0;) u.redIAdd(y);
            for (var _ = this.pow(u, v), L = this.pow(a, v.addn(1).iushrn(1)), E = this.pow(a, v), R = x; E.cmp(b) !== 0;) {
                for (var G = E, z = 0; G.cmp(b) !== 0; z++) G = G.redSqr();
                n(z < R);
                var j = this.pow(_, new s(1).iushln(R - z - 1));
                L = L.redMul(j), _ = j.redSqr(), E = E.redMul(_), R = z
            }
            return L
        }, O.prototype.invm = function(a) {
            var c = a._invmp(this.m);
            return c.negative !== 0 ? (c.negative = 0, this.imod(c).redNeg()) : this.imod(c)
        }, O.prototype.pow = function(a, c) {
            if (c.isZero()) return new s(1).toRed(this);
            if (c.cmpn(1) === 0) return a.clone();
            var g = 4,
                v = new Array(1 << g);
            v[0] = new s(1).toRed(this), v[1] = a;
            for (var x = 2; x < v.length; x++) v[x] = this.mul(v[x - 1], a);
            var b = v[0],
                y = 0,
                h = 0,
                u = c.bitLength() % 26;
            for (u === 0 && (u = 26), x = c.length - 1; x >= 0; x--) {
                for (var _ = c.words[x], L = u - 1; L >= 0; L--) {
                    var E = _ >> L & 1;
                    if (b !== v[0] && (b = this.sqr(b)), E === 0 && y === 0) {
                        h = 0;
                        continue
                    }
                    y <<= 1, y |= E, h++, !(h !== g && (x !== 0 || L !== 0)) && (b = this.mul(b, v[y]), h = 0, y = 0)
                }
                u = 26
            }
            return b
        }, O.prototype.convertTo = function(a) {
            var c = a.umod(this.m);
            return c === a ? c.clone() : c
        }, O.prototype.convertFrom = function(a) {
            var c = a.clone();
            return c.red = null, c
        }, s.mont = function(a) {
            return new w(a)
        };

        function w(m) {
            O.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
        }
        i(w, O), w.prototype.convertTo = function(a) {
            return this.imod(a.ushln(this.shift))
        }, w.prototype.convertFrom = function(a) {
            var c = this.imod(a.mul(this.rinv));
            return c.red = null, c
        }, w.prototype.imul = function(a, c) {
            if (a.isZero() || c.isZero()) return a.words[0] = 0, a.length = 1, a;
            var g = a.imul(c),
                v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                x = g.isub(v).iushrn(this.shift),
                b = x;
            return x.cmp(this.m) >= 0 ? b = x.isub(this.m) : x.cmpn(0) < 0 && (b = x.iadd(this.m)), b._forceRed(this)
        }, w.prototype.mul = function(a, c) {
            if (a.isZero() || c.isZero()) return new s(0)._forceRed(this);
            var g = a.mul(c),
                v = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                x = g.isub(v).iushrn(this.shift),
                b = x;
            return x.cmp(this.m) >= 0 ? b = x.isub(this.m) : x.cmpn(0) < 0 && (b = x.iadd(this.m)), b._forceRed(this)
        }, w.prototype.invm = function(a) {
            var c = this.imod(a._invmp(this.m).mul(this.r2));
            return c._forceRed(this)
        }
    })(t, vu)
})(db);
var Xe = db.exports;

function ua(t, e, r) {
    return r = {
        path: e,
        exports: {},
        require: function(n, i) {
            return jT(n, i == null ? r.path : i)
        }
    }, t(r, r.exports), r.exports
}

function jT() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var sd = pb;

function pb(t, e) {
    if (!t) throw new Error(e || "Assertion failed")
}
pb.equal = function(e, r, n) {
    if (e != r) throw new Error(n || "Assertion failed: " + e + " != " + r)
};
var ri = ua(function(t, e) {
        var r = e;

        function n(o, f) {
            if (Array.isArray(o)) return o.slice();
            if (!o) return [];
            var l = [];
            if (typeof o != "string") {
                for (var d = 0; d < o.length; d++) l[d] = o[d] | 0;
                return l
            }
            if (f === "hex") {
                o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 != 0 && (o = "0" + o);
                for (var d = 0; d < o.length; d += 2) l.push(parseInt(o[d] + o[d + 1], 16))
            } else
                for (var d = 0; d < o.length; d++) {
                    var p = o.charCodeAt(d),
                        A = p >> 8,
                        T = p & 255;
                    A ? l.push(A, T) : l.push(T)
                }
            return l
        }
        r.toArray = n;

        function i(o) {
            return o.length === 1 ? "0" + o : o
        }
        r.zero2 = i;

        function s(o) {
            for (var f = "", l = 0; l < o.length; l++) f += i(o[l].toString(16));
            return f
        }
        r.toHex = s, r.encode = function(f, l) {
            return l === "hex" ? s(f) : f
        }
    }),
    Yr = ua(function(t, e) {
        var r = e;
        r.assert = sd, r.toArray = ri.toArray, r.zero2 = ri.zero2, r.toHex = ri.toHex, r.encode = ri.encode;

        function n(l, d, p) {
            var A = new Array(Math.max(l.bitLength(), p) + 1);
            A.fill(0);
            for (var T = 1 << d + 1, N = l.clone(), P = 0; P < A.length; P++) {
                var C, S = N.andln(T - 1);
                N.isOdd() ? (S > (T >> 1) - 1 ? C = (T >> 1) - S : C = S, N.isubn(C)) : C = 0, A[P] = C, N.iushrn(1)
            }
            return A
        }
        r.getNAF = n;

        function i(l, d) {
            var p = [
                [],
                []
            ];
            l = l.clone(), d = d.clone();
            for (var A = 0, T = 0, N; l.cmpn(-A) > 0 || d.cmpn(-T) > 0;) {
                var P = l.andln(3) + A & 3,
                    C = d.andln(3) + T & 3;
                P === 3 && (P = -1), C === 3 && (C = -1);
                var S;
                (P & 1) == 0 ? S = 0 : (N = l.andln(7) + A & 7, (N === 3 || N === 5) && C === 2 ? S = -P : S = P), p[0].push(S);
                var k;
                (C & 1) == 0 ? k = 0 : (N = d.andln(7) + T & 7, (N === 3 || N === 5) && P === 2 ? k = -C : k = C), p[1].push(k), 2 * A === S + 1 && (A = 1 - A), 2 * T === k + 1 && (T = 1 - T), l.iushrn(1), d.iushrn(1)
            }
            return p
        }
        r.getJSF = i;

        function s(l, d, p) {
            var A = "_" + d;
            l.prototype[d] = function() {
                return this[A] !== void 0 ? this[A] : this[A] = p.call(this)
            }
        }
        r.cachedProperty = s;

        function o(l) {
            return typeof l == "string" ? r.toArray(l, "hex") : l
        }
        r.parseBytes = o;

        function f(l) {
            return new Xe(l, "hex", "le")
        }
        r.intFromLE = f
    }),
    _l = Yr.getNAF,
    WT = Yr.getJSF,
    Tl = Yr.assert;

function Ms(t, e) {
    this.type = t, this.p = new Xe(e.p, 16), this.red = e.prime ? Xe.red(e.prime) : Xe.mont(this.p), this.zero = new Xe(0).toRed(this.red), this.one = new Xe(1).toRed(this.red), this.two = new Xe(2).toRed(this.red), this.n = e.n && new Xe(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var r = this.n && this.p.div(this.n);
    !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
}
var oo = Ms;
Ms.prototype.point = function() {
    throw new Error("Not implemented")
};
Ms.prototype.validate = function() {
    throw new Error("Not implemented")
};
Ms.prototype._fixedNafMul = function(e, r) {
    Tl(e.precomputed);
    var n = e._getDoubles(),
        i = _l(r, 1, this._bitLength),
        s = (1 << n.step + 1) - (n.step % 2 == 0 ? 2 : 1);
    s /= 3;
    var o = [],
        f, l;
    for (f = 0; f < i.length; f += n.step) {
        l = 0;
        for (var d = f + n.step - 1; d >= f; d--) l = (l << 1) + i[d];
        o.push(l)
    }
    for (var p = this.jpoint(null, null, null), A = this.jpoint(null, null, null), T = s; T > 0; T--) {
        for (f = 0; f < o.length; f++) l = o[f], l === T ? A = A.mixedAdd(n.points[f]) : l === -T && (A = A.mixedAdd(n.points[f].neg()));
        p = p.add(A)
    }
    return p.toP()
};
Ms.prototype._wnafMul = function(e, r) {
    var n = 4,
        i = e._getNAFPoints(n);
    n = i.wnd;
    for (var s = i.points, o = _l(r, n, this._bitLength), f = this.jpoint(null, null, null), l = o.length - 1; l >= 0; l--) {
        for (var d = 0; l >= 0 && o[l] === 0; l--) d++;
        if (l >= 0 && d++, f = f.dblp(d), l < 0) break;
        var p = o[l];
        Tl(p !== 0), e.type === "affine" ? p > 0 ? f = f.mixedAdd(s[p - 1 >> 1]) : f = f.mixedAdd(s[-p - 1 >> 1].neg()) : p > 0 ? f = f.add(s[p - 1 >> 1]) : f = f.add(s[-p - 1 >> 1].neg())
    }
    return e.type === "affine" ? f.toP() : f
};
Ms.prototype._wnafMulAdd = function(e, r, n, i, s) {
    var o = this._wnafT1,
        f = this._wnafT2,
        l = this._wnafT3,
        d = 0,
        p, A, T;
    for (p = 0; p < i; p++) {
        T = r[p];
        var N = T._getNAFPoints(e);
        o[p] = N.wnd, f[p] = N.points
    }
    for (p = i - 1; p >= 1; p -= 2) {
        var P = p - 1,
            C = p;
        if (o[P] !== 1 || o[C] !== 1) {
            l[P] = _l(n[P], o[P], this._bitLength), l[C] = _l(n[C], o[C], this._bitLength), d = Math.max(l[P].length, d), d = Math.max(l[C].length, d);
            continue
        }
        var S = [r[P], null, null, r[C]];
        r[P].y.cmp(r[C].y) === 0 ? (S[1] = r[P].add(r[C]), S[2] = r[P].toJ().mixedAdd(r[C].neg())) : r[P].y.cmp(r[C].y.redNeg()) === 0 ? (S[1] = r[P].toJ().mixedAdd(r[C]), S[2] = r[P].add(r[C].neg())) : (S[1] = r[P].toJ().mixedAdd(r[C]), S[2] = r[P].toJ().mixedAdd(r[C].neg()));
        var k = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            I = WT(n[P], n[C]);
        for (d = Math.max(I[0].length, d), l[P] = new Array(d), l[C] = new Array(d), A = 0; A < d; A++) {
            var U = I[0][A] | 0,
                M = I[1][A] | 0;
            l[P][A] = k[(U + 1) * 3 + (M + 1)], l[C][A] = 0, f[P] = S
        }
    }
    var F = this.jpoint(null, null, null),
        D = this._wnafT4;
    for (p = d; p >= 0; p--) {
        for (var q = 0; p >= 0;) {
            var V = !0;
            for (A = 0; A < i; A++) D[A] = l[A][p] | 0, D[A] !== 0 && (V = !1);
            if (!V) break;
            q++, p--
        }
        if (p >= 0 && q++, F = F.dblp(q), p < 0) break;
        for (A = 0; A < i; A++) {
            var Q = D[A];
            Q !== 0 && (Q > 0 ? T = f[A][Q - 1 >> 1] : Q < 0 && (T = f[A][-Q - 1 >> 1].neg()), T.type === "affine" ? F = F.mixedAdd(T) : F = F.add(T))
        }
    }
    for (p = 0; p < i; p++) f[p] = null;
    return s ? F : F.toP()
};

function xn(t, e) {
    this.curve = t, this.type = e, this.precomputed = null
}
Ms.BasePoint = xn;
xn.prototype.eq = function() {
    throw new Error("Not implemented")
};
xn.prototype.validate = function() {
    return this.curve.validate(this)
};
Ms.prototype.decodePoint = function(e, r) {
    e = Yr.toArray(e, r);
    var n = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 == 2 * n) {
        e[0] === 6 ? Tl(e[e.length - 1] % 2 == 0) : e[0] === 7 && Tl(e[e.length - 1] % 2 == 1);
        var i = this.point(e.slice(1, 1 + n), e.slice(1 + n, 1 + 2 * n));
        return i
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n) return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
    throw new Error("Unknown point format")
};
xn.prototype.encodeCompressed = function(e) {
    return this.encode(e, !0)
};
xn.prototype._encode = function(e) {
    var r = this.curve.p.byteLength(),
        n = this.getX().toArray("be", r);
    return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r))
};
xn.prototype.encode = function(e, r) {
    return Yr.encode(this._encode(r), e)
};
xn.prototype.precompute = function(e) {
    if (this.precomputed) return this;
    var r = {
        doubles: null,
        naf: null,
        beta: null
    };
    return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this
};
xn.prototype._hasDoubles = function(e) {
    if (!this.precomputed) return !1;
    var r = this.precomputed.doubles;
    return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1
};
xn.prototype._getDoubles = function(e, r) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var n = [this], i = this, s = 0; s < r; s += e) {
        for (var o = 0; o < e; o++) i = i.dbl();
        n.push(i)
    }
    return {
        step: e,
        points: n
    }
};
xn.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++) r[s] = r[s - 1].add(i);
    return {
        wnd: e,
        points: r
    }
};
xn.prototype._getBeta = function() {
    return null
};
xn.prototype.dblp = function(e) {
    for (var r = this, n = 0; n < e; n++) r = r.dbl();
    return r
};
var od = ua(function(t) {
        typeof Object.create == "function" ? t.exports = function(r, n) {
            n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }))
        } : t.exports = function(r, n) {
            if (n) {
                r.super_ = n;
                var i = function() {};
                i.prototype = n.prototype, r.prototype = new i, r.prototype.constructor = r
            }
        }
    }),
    VT = Yr.assert;

function bn(t) {
    oo.call(this, "short", t), this.a = new Xe(t.a, 16).toRed(this.red), this.b = new Xe(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
}
od(bn, oo);
var KT = bn;
bn.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, n;
        if (e.beta) r = new Xe(e.beta, 16).toRed(this.red);
        else {
            var i = this._getEndoRoots(this.p);
            r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red)
        }
        if (e.lambda) n = new Xe(e.lambda, 16);
        else {
            var s = this._getEndoRoots(this.n);
            this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], VT(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0))
        }
        var o;
        return e.basis ? o = e.basis.map(function(f) {
            return {
                a: new Xe(f.a, 16),
                b: new Xe(f.b, 16)
            }
        }) : o = this._getEndoBasis(n), {
            beta: r,
            lambda: n,
            basis: o
        }
    }
};
bn.prototype._getEndoRoots = function(e) {
    var r = e === this.p ? this.red : Xe.mont(e),
        n = new Xe(2).toRed(r).redInvm(),
        i = n.redNeg(),
        s = new Xe(3).toRed(r).redNeg().redSqrt().redMul(n),
        o = i.redAdd(s).fromRed(),
        f = i.redSub(s).fromRed();
    return [o, f]
};
bn.prototype._getEndoBasis = function(e) {
    for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new Xe(1), o = new Xe(0), f = new Xe(0), l = new Xe(1), d, p, A, T, N, P, C, S = 0, k, I; n.cmpn(0) !== 0;) {
        var U = i.div(n);
        k = i.sub(U.mul(n)), I = f.sub(U.mul(s));
        var M = l.sub(U.mul(o));
        if (!A && k.cmp(r) < 0) d = C.neg(), p = s, A = k.neg(), T = I;
        else if (A && ++S == 2) break;
        C = k, i = n, n = k, f = s, s = I, l = o, o = M
    }
    N = k.neg(), P = I;
    var F = A.sqr().add(T.sqr()),
        D = N.sqr().add(P.sqr());
    return D.cmp(F) >= 0 && (N = d, P = p), A.negative && (A = A.neg(), T = T.neg()), N.negative && (N = N.neg(), P = P.neg()), [{
        a: A,
        b: T
    }, {
        a: N,
        b: P
    }]
};
bn.prototype._endoSplit = function(e) {
    var r = this.endo.basis,
        n = r[0],
        i = r[1],
        s = i.b.mul(e).divRound(this.n),
        o = n.b.neg().mul(e).divRound(this.n),
        f = s.mul(n.a),
        l = o.mul(i.a),
        d = s.mul(n.b),
        p = o.mul(i.b),
        A = e.sub(f).sub(l),
        T = d.add(p).neg();
    return {
        k1: A,
        k2: T
    }
};
bn.prototype.pointFromX = function(e, r) {
    e = new Xe(e, 16), e.red || (e = e.toRed(this.red));
    var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        i = n.redSqrt();
    if (i.redSqr().redSub(n).cmp(this.zero) !== 0) throw new Error("invalid point");
    var s = i.fromRed().isOdd();
    return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i)
};
bn.prototype.validate = function(e) {
    if (e.inf) return !0;
    var r = e.x,
        n = e.y,
        i = this.a.redMul(r),
        s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
    return n.redSqr().redISub(s).cmpn(0) === 0
};
bn.prototype._endoWnafMulAdd = function(e, r, n) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
        var f = this._endoSplit(r[o]),
            l = e[o],
            d = l._getBeta();
        f.k1.negative && (f.k1.ineg(), l = l.neg(!0)), f.k2.negative && (f.k2.ineg(), d = d.neg(!0)), i[o * 2] = l, i[o * 2 + 1] = d, s[o * 2] = f.k1, s[o * 2 + 1] = f.k2
    }
    for (var p = this._wnafMulAdd(1, i, s, o * 2, n), A = 0; A < o * 2; A++) i[A] = null, s[A] = null;
    return p
};

function or(t, e, r, n) {
    oo.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Xe(e, 16), this.y = new Xe(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
}
od(or, oo.BasePoint);
bn.prototype.point = function(e, r, n) {
    return new or(this, e, r, n)
};
bn.prototype.pointFromJSON = function(e, r) {
    return or.fromJSON(this, e, r)
};
or.prototype._getBeta = function() {
    if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta) return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
            var n = this.curve,
                i = function(s) {
                    return n.point(s.x.redMul(n.endo.beta), s.y)
                };
            e.beta = r, r.precomputed = {
                beta: null,
                naf: e.naf && {
                    wnd: e.naf.wnd,
                    points: e.naf.points.map(i)
                },
                doubles: e.doubles && {
                    step: e.doubles.step,
                    points: e.doubles.points.map(i)
                }
            }
        }
        return r
    }
};
or.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
        }
    }] : [this.x, this.y]
};
or.fromJSON = function(e, r, n) {
    typeof r == "string" && (r = JSON.parse(r));
    var i = e.point(r[0], r[1], n);
    if (!r[2]) return i;

    function s(f) {
        return e.point(f[0], f[1], n)
    }
    var o = r[2];
    return i.precomputed = {
        beta: null,
        doubles: o.doubles && {
            step: o.doubles.step,
            points: [i].concat(o.doubles.points.map(s))
        },
        naf: o.naf && {
            wnd: o.naf.wnd,
            points: [i].concat(o.naf.points.map(s))
        }
    }, i
};
or.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
};
or.prototype.isInfinity = function() {
    return this.inf
};
or.prototype.add = function(e) {
    if (this.inf) return e;
    if (e.inf) return this;
    if (this.eq(e)) return this.dbl();
    if (this.neg().eq(e)) return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
    var r = this.y.redSub(e.y);
    r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
    var n = r.redSqr().redISub(this.x).redISub(e.x),
        i = r.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, i)
};
or.prototype.dbl = function() {
    if (this.inf) return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0) return this.curve.point(null, null);
    var r = this.curve.a,
        n = this.x.redSqr(),
        i = e.redInvm(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i),
        o = s.redSqr().redISub(this.x.redAdd(this.x)),
        f = s.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, f)
};
or.prototype.getX = function() {
    return this.x.fromRed()
};
or.prototype.getY = function() {
    return this.y.fromRed()
};
or.prototype.mul = function(e) {
    return e = new Xe(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
};
or.prototype.mulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2)
};
or.prototype.jmulAdd = function(e, r, n) {
    var i = [this, r],
        s = [e, n];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0)
};
or.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)
};
or.prototype.neg = function(e) {
    if (this.inf) return this;
    var r = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
        var n = this.precomputed,
            i = function(s) {
                return s.neg()
            };
        r.precomputed = {
            naf: n.naf && {
                wnd: n.naf.wnd,
                points: n.naf.points.map(i)
            },
            doubles: n.doubles && {
                step: n.doubles.step,
                points: n.doubles.points.map(i)
            }
        }
    }
    return r
};
or.prototype.toJ = function() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e
};

function hr(t, e, r, n) {
    oo.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Xe(0)) : (this.x = new Xe(e, 16), this.y = new Xe(r, 16), this.z = new Xe(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
}
od(hr, oo.BasePoint);
bn.prototype.jpoint = function(e, r, n) {
    return new hr(this, e, r, n)
};
hr.prototype.toP = function() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var e = this.z.redInvm(),
        r = e.redSqr(),
        n = this.x.redMul(r),
        i = this.y.redMul(r).redMul(e);
    return this.curve.point(n, i)
};
hr.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
};
hr.prototype.add = function(e) {
    if (this.isInfinity()) return e;
    if (e.isInfinity()) return this;
    var r = e.z.redSqr(),
        n = this.z.redSqr(),
        i = this.x.redMul(r),
        s = e.x.redMul(n),
        o = this.y.redMul(r.redMul(e.z)),
        f = e.y.redMul(n.redMul(this.z)),
        l = i.redSub(s),
        d = o.redSub(f);
    if (l.cmpn(0) === 0) return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var p = l.redSqr(),
        A = p.redMul(l),
        T = i.redMul(p),
        N = d.redSqr().redIAdd(A).redISub(T).redISub(T),
        P = d.redMul(T.redISub(N)).redISub(o.redMul(A)),
        C = this.z.redMul(e.z).redMul(l);
    return this.curve.jpoint(N, P, C)
};
hr.prototype.mixedAdd = function(e) {
    if (this.isInfinity()) return e.toJ();
    if (e.isInfinity()) return this;
    var r = this.z.redSqr(),
        n = this.x,
        i = e.x.redMul(r),
        s = this.y,
        o = e.y.redMul(r).redMul(this.z),
        f = n.redSub(i),
        l = s.redSub(o);
    if (f.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var d = f.redSqr(),
        p = d.redMul(f),
        A = n.redMul(d),
        T = l.redSqr().redIAdd(p).redISub(A).redISub(A),
        N = l.redMul(A.redISub(T)).redISub(s.redMul(p)),
        P = this.z.redMul(f);
    return this.curve.jpoint(T, N, P)
};
hr.prototype.dblp = function(e) {
    if (e === 0) return this;
    if (this.isInfinity()) return this;
    if (!e) return this.dbl();
    var r;
    if (this.curve.zeroA || this.curve.threeA) {
        var n = this;
        for (r = 0; r < e; r++) n = n.dbl();
        return n
    }
    var i = this.curve.a,
        s = this.curve.tinv,
        o = this.x,
        f = this.y,
        l = this.z,
        d = l.redSqr().redSqr(),
        p = f.redAdd(f);
    for (r = 0; r < e; r++) {
        var A = o.redSqr(),
            T = p.redSqr(),
            N = T.redSqr(),
            P = A.redAdd(A).redIAdd(A).redIAdd(i.redMul(d)),
            C = o.redMul(T),
            S = P.redSqr().redISub(C.redAdd(C)),
            k = C.redISub(S),
            I = P.redMul(k);
        I = I.redIAdd(I).redISub(N);
        var U = p.redMul(l);
        r + 1 < e && (d = d.redMul(N)), o = S, l = U, p = I
    }
    return this.curve.jpoint(o, p.redMul(s), l)
};
hr.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
};
hr.prototype._zeroDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            f = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        f = f.redIAdd(f);
        var l = i.redAdd(i).redIAdd(i),
            d = l.redSqr().redISub(f).redISub(f),
            p = o.redIAdd(o);
        p = p.redIAdd(p), p = p.redIAdd(p), e = d, r = l.redMul(f.redISub(d)).redISub(p), n = this.y.redAdd(this.y)
    } else {
        var A = this.x.redSqr(),
            T = this.y.redSqr(),
            N = T.redSqr(),
            P = this.x.redAdd(T).redSqr().redISub(A).redISub(N);
        P = P.redIAdd(P);
        var C = A.redAdd(A).redIAdd(A),
            S = C.redSqr(),
            k = N.redIAdd(N);
        k = k.redIAdd(k), k = k.redIAdd(k), e = S.redISub(P).redISub(P), r = C.redMul(P.redISub(e)).redISub(k), n = this.y.redMul(this.z), n = n.redIAdd(n)
    }
    return this.curve.jpoint(e, r, n)
};
hr.prototype._threeDbl = function() {
    var e, r, n;
    if (this.zOne) {
        var i = this.x.redSqr(),
            s = this.y.redSqr(),
            o = s.redSqr(),
            f = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
        f = f.redIAdd(f);
        var l = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
            d = l.redSqr().redISub(f).redISub(f);
        e = d;
        var p = o.redIAdd(o);
        p = p.redIAdd(p), p = p.redIAdd(p), r = l.redMul(f.redISub(d)).redISub(p), n = this.y.redAdd(this.y)
    } else {
        var A = this.z.redSqr(),
            T = this.y.redSqr(),
            N = this.x.redMul(T),
            P = this.x.redSub(A).redMul(this.x.redAdd(A));
        P = P.redAdd(P).redIAdd(P);
        var C = N.redIAdd(N);
        C = C.redIAdd(C);
        var S = C.redAdd(C);
        e = P.redSqr().redISub(S), n = this.y.redAdd(this.z).redSqr().redISub(T).redISub(A);
        var k = T.redSqr();
        k = k.redIAdd(k), k = k.redIAdd(k), k = k.redIAdd(k), r = P.redMul(C.redISub(e)).redISub(k)
    }
    return this.curve.jpoint(e, r, n)
};
hr.prototype._dbl = function() {
    var e = this.curve.a,
        r = this.x,
        n = this.y,
        i = this.z,
        s = i.redSqr().redSqr(),
        o = r.redSqr(),
        f = n.redSqr(),
        l = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)),
        d = r.redAdd(r);
    d = d.redIAdd(d);
    var p = d.redMul(f),
        A = l.redSqr().redISub(p.redAdd(p)),
        T = p.redISub(A),
        N = f.redSqr();
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var P = l.redMul(T).redISub(N),
        C = n.redAdd(n).redMul(i);
    return this.curve.jpoint(A, P, C)
};
hr.prototype.trpl = function() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var e = this.x.redSqr(),
        r = this.y.redSqr(),
        n = this.z.redSqr(),
        i = r.redSqr(),
        s = e.redAdd(e).redIAdd(e),
        o = s.redSqr(),
        f = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
    f = f.redIAdd(f), f = f.redAdd(f).redIAdd(f), f = f.redISub(o);
    var l = f.redSqr(),
        d = i.redIAdd(i);
    d = d.redIAdd(d), d = d.redIAdd(d), d = d.redIAdd(d);
    var p = s.redIAdd(f).redSqr().redISub(o).redISub(l).redISub(d),
        A = r.redMul(p);
    A = A.redIAdd(A), A = A.redIAdd(A);
    var T = this.x.redMul(l).redISub(A);
    T = T.redIAdd(T), T = T.redIAdd(T);
    var N = this.y.redMul(p.redMul(d.redISub(p)).redISub(f.redMul(l)));
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var P = this.z.redAdd(f).redSqr().redISub(n).redISub(l);
    return this.curve.jpoint(T, N, P)
};
hr.prototype.mul = function(e, r) {
    return e = new Xe(e, r), this.curve._wnafMul(this, e)
};
hr.prototype.eq = function(e) {
    if (e.type === "affine") return this.eq(e.toJ());
    if (this === e) return !0;
    var r = this.z.redSqr(),
        n = e.z.redSqr();
    if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1;
    var i = r.redMul(this.z),
        s = n.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0
};
hr.prototype.eqXToP = function(e) {
    var r = this.z.redSqr(),
        n = e.toRed(this.curve.red).redMul(r);
    if (this.x.cmp(n) === 0) return !0;
    for (var i = e.clone(), s = this.curve.redN.redMul(r);;) {
        if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1;
        if (n.redIAdd(s), this.x.cmp(n) === 0) return !0
    }
};
hr.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
};
hr.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0
};
var Ml = ua(function(t, e) {
        var r = e;
        r.base = oo, r.short = KT, r.mont = null, r.edwards = null
    }),
    Nl = ua(function(t, e) {
        var r = e,
            n = Yr.assert;

        function i(f) {
            f.type === "short" ? this.curve = new Ml.short(f) : f.type === "edwards" ? this.curve = new Ml.edwards(f) : this.curve = new Ml.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }
        r.PresetCurve = i;

        function s(f, l) {
            Object.defineProperty(r, f, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    var d = new i(l);
                    return Object.defineProperty(r, f, {
                        configurable: !0,
                        enumerable: !0,
                        value: d
                    }), d
                }
            })
        }
        s("p192", {
            type: "short",
            prime: "p192",
            p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
            b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
            n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
            hash: Qt.sha256,
            gRed: !1,
            g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }), s("p224", {
            type: "short",
            prime: "p224",
            p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
            a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
            b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
            n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
            hash: Qt.sha256,
            gRed: !1,
            g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }), s("p256", {
            type: "short",
            prime: null,
            p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
            a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
            b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
            n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
            hash: Qt.sha256,
            gRed: !1,
            g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }), s("p384", {
            type: "short",
            prime: null,
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
            a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
            b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
            n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
            hash: Qt.sha384,
            gRed: !1,
            g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }), s("p521", {
            type: "short",
            prime: null,
            p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
            a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
            b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
            n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
            hash: Qt.sha512,
            gRed: !1,
            g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }), s("curve25519", {
            type: "mont",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "76d06",
            b: "1",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: Qt.sha256,
            gRed: !1,
            g: ["9"]
        }), s("ed25519", {
            type: "edwards",
            prime: "p25519",
            p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
            a: "-1",
            c: "1",
            d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
            n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
            hash: Qt.sha256,
            gRed: !1,
            g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        var o;
        try {
            o = null.crash()
        } catch {
            o = void 0
        }
        s("secp256k1", {
            type: "short",
            prime: "k256",
            p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
            a: "0",
            b: "7",
            n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
            h: "1",
            hash: Qt.sha256,
            beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
            lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
            basis: [{
                a: "3086d221a7d46bcde86c90e49284eb15",
                b: "-e4437ed6010e88286f547fa90abfe4c3"
            }, {
                a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
                b: "3086d221a7d46bcde86c90e49284eb15"
            }],
            gRed: !1,
            g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", o]
        })
    });

function Ns(t) {
    if (!(this instanceof Ns)) return new Ns(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = ri.toArray(t.entropy, t.entropyEnc || "hex"),
        r = ri.toArray(t.nonce, t.nonceEnc || "hex"),
        n = ri.toArray(t.pers, t.persEnc || "hex");
    sd(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, n)
}
var mb = Ns;
Ns.prototype._init = function(e, r, n) {
    var i = e.concat(r).concat(n);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656
};
Ns.prototype._hmac = function() {
    return new Qt.hmac(this.hash, this.K)
};
Ns.prototype._update = function(e) {
    var r = this._hmac().update(this.V).update([0]);
    e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), !!e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
};
Ns.prototype.reseed = function(e, r, n, i) {
    typeof r != "string" && (i = n, n = r, r = null), e = ri.toArray(e, r), n = ri.toArray(n, i), sd(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(n || [])), this._reseed = 1
};
Ns.prototype.generate = function(e, r, n, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof r != "string" && (i = n, n = r, r = null), n && (n = ri.toArray(n, i || "hex"), this._update(n));
    for (var s = []; s.length < e;) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
    var o = s.slice(0, e);
    return this._update(n), this._reseed++, ri.encode(o, r)
};
var ad = Yr.assert;

function Tr(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc)
}
var fd = Tr;
Tr.fromPublic = function(e, r, n) {
    return r instanceof Tr ? r : new Tr(e, {
        pub: r,
        pubEnc: n
    })
};
Tr.fromPrivate = function(e, r, n) {
    return r instanceof Tr ? r : new Tr(e, {
        priv: r,
        privEnc: n
    })
};
Tr.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
    } : {
        result: !1,
        reason: "Public key * N != O"
    } : {
        result: !1,
        reason: "Public key is not a point"
    }
};
Tr.prototype.getPublic = function(e, r) {
    return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub
};
Tr.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv
};
Tr.prototype._importPrivate = function(e, r) {
    this.priv = new Xe(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n)
};
Tr.prototype._importPublic = function(e, r) {
    if (e.x || e.y) {
        this.ec.curve.type === "mont" ? ad(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ad(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return
    }
    this.pub = this.ec.curve.decodePoint(e, r)
};
Tr.prototype.derive = function(e) {
    return e.validate() || ad(e.validate(), "public point not validated"), e.mul(this.priv).getX()
};
Tr.prototype.sign = function(e, r, n) {
    return this.ec.sign(e, this, r, n)
};
Tr.prototype.verify = function(e, r) {
    return this.ec.verify(e, r, this)
};
Tr.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
};
var XT = Yr.assert;

function Sl(t, e) {
    if (t instanceof Sl) return t;
    this._importDER(t, e) || (XT(t.r && t.s, "Signature without r or s"), this.r = new Xe(t.r, 16), this.s = new Xe(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam)
}
var Pl = Sl;

function JT() {
    this.place = 0
}

function ud(t, e) {
    var r = t[e.place++];
    if (!(r & 128)) return r;
    var n = r & 15;
    if (n === 0 || n > 4) return !1;
    for (var i = 0, s = 0, o = e.place; s < n; s++, o++) i <<= 8, i |= t[o], i >>>= 0;
    return i <= 127 ? !1 : (e.place = o, i)
}

function yb(t) {
    for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r;) e++;
    return e === 0 ? t : t.slice(e)
}
Sl.prototype._importDER = function(e, r) {
    e = Yr.toArray(e, r);
    var n = new JT;
    if (e[n.place++] !== 48) return !1;
    var i = ud(e, n);
    if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2) return !1;
    var s = ud(e, n);
    if (s === !1) return !1;
    var o = e.slice(n.place, s + n.place);
    if (n.place += s, e[n.place++] !== 2) return !1;
    var f = ud(e, n);
    if (f === !1 || e.length !== f + n.place) return !1;
    var l = e.slice(n.place, f + n.place);
    if (o[0] === 0)
        if (o[1] & 128) o = o.slice(1);
        else return !1;
    if (l[0] === 0)
        if (l[1] & 128) l = l.slice(1);
        else return !1;
    return this.r = new Xe(o), this.s = new Xe(l), this.recoveryParam = null, !0
};

function ld(t, e) {
    if (e < 128) {
        t.push(e);
        return
    }
    var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(r | 128); --r;) t.push(e >>> (r << 3) & 255);
    t.push(e)
}
Sl.prototype.toDER = function(e) {
    var r = this.r.toArray(),
        n = this.s.toArray();
    for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = yb(r), n = yb(n); !n[0] && !(n[1] & 128);) n = n.slice(1);
    var i = [2];
    ld(i, r.length), i = i.concat(r), i.push(2), ld(i, n.length);
    var s = i.concat(n),
        o = [48];
    return ld(o, s.length), o = o.concat(s), Yr.encode(o, e)
};
var ZT = function() {
        throw new Error("unsupported")
    },
    gb = Yr.assert;

function vn(t) {
    if (!(this instanceof vn)) return new vn(t);
    typeof t == "string" && (gb(Object.prototype.hasOwnProperty.call(Nl, t), "Unknown curve " + t), t = Nl[t]), t instanceof Nl.PresetCurve && (t = {
        curve: t
    }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash
}
var YT = vn;
vn.prototype.keyPair = function(e) {
    return new fd(this, e)
};
vn.prototype.keyFromPrivate = function(e, r) {
    return fd.fromPrivate(this, e, r)
};
vn.prototype.keyFromPublic = function(e, r) {
    return fd.fromPublic(this, e, r)
};
vn.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var r = new mb({
            hash: this.hash,
            pers: e.pers,
            persEnc: e.persEnc || "utf8",
            entropy: e.entropy || ZT(this.hash.hmacStrength),
            entropyEnc: e.entropy && e.entropyEnc || "utf8",
            nonce: this.n.toArray()
        }), n = this.n.byteLength(), i = this.n.sub(new Xe(2));;) {
        var s = new Xe(r.generate(n));
        if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s)
    }
};
vn.prototype._truncateToN = function(e, r) {
    var n = e.byteLength() * 8 - this.n.bitLength();
    return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
};
vn.prototype.sign = function(e, r, n, i) {
    typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new Xe(e, 16));
    for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), f = e.toArray("be", s), l = new mb({
            hash: this.hash,
            entropy: o,
            nonce: f,
            pers: i.pers,
            persEnc: i.persEnc || "utf8"
        }), d = this.n.sub(new Xe(1)), p = 0;; p++) {
        var A = i.k ? i.k(p) : new Xe(l.generate(this.n.byteLength()));
        if (A = this._truncateToN(A, !0), !(A.cmpn(1) <= 0 || A.cmp(d) >= 0)) {
            var T = this.g.mul(A);
            if (!T.isInfinity()) {
                var N = T.getX(),
                    P = N.umod(this.n);
                if (P.cmpn(0) !== 0) {
                    var C = A.invm(this.n).mul(P.mul(r.getPrivate()).iadd(e));
                    if (C = C.umod(this.n), C.cmpn(0) !== 0) {
                        var S = (T.getY().isOdd() ? 1 : 0) | (N.cmp(P) !== 0 ? 2 : 0);
                        return i.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), S ^= 1), new Pl({
                            r: P,
                            s: C,
                            recoveryParam: S
                        })
                    }
                }
            }
        }
    }
};
vn.prototype.verify = function(e, r, n, i) {
    e = this._truncateToN(new Xe(e, 16)), n = this.keyFromPublic(n, i), r = new Pl(r, "hex");
    var s = r.r,
        o = r.s;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
    var f = o.invm(this.n),
        l = f.mul(e).umod(this.n),
        d = f.mul(s).umod(this.n),
        p;
    return this.curve._maxwellTrick ? (p = this.g.jmulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.eqXToP(s)) : (p = this.g.mulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(s) === 0)
};
vn.prototype.recoverPubKey = function(t, e, r, n) {
    gb((3 & r) === r, "The recovery param is more than two bits"), e = new Pl(e, n);
    var i = this.n,
        s = new Xe(t),
        o = e.r,
        f = e.s,
        l = r & 1,
        d = r >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && d) throw new Error("Unable to find sencond key candinate");
    d ? o = this.curve.pointFromX(o.add(this.curve.n), l) : o = this.curve.pointFromX(o, l);
    var p = e.r.invm(i),
        A = i.sub(s).mul(p).umod(i),
        T = f.mul(p).umod(i);
    return this.g.mulAdd(A, o, T)
};
vn.prototype.getKeyRecoveryParam = function(t, e, r, n) {
    if (e = new Pl(e, n), e.recoveryParam !== null) return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
        var s;
        try {
            s = this.recoverPubKey(t, e, i)
        } catch {
            continue
        }
        if (s.eq(r)) return i
    }
    throw new Error("Unable to find valid recovery factor")
};
var QT = ua(function(t, e) {
        var r = e;
        r.version = "6.5.4", r.utils = Yr, r.rand = function() {
            throw new Error("unsupported")
        }, r.curve = Ml, r.curves = Nl, r.ec = YT, r.eddsa = null
    }),
    e7 = QT.ec;
const t7 = "signing-key/5.7.0",
    cd = new dt(t7);
let hd = null;

function Ci() {
    return hd || (hd = new e7("secp256k1")), hd
}
class r7 {
    constructor(e) {
        Oi(this, "curve", "secp256k1"), Oi(this, "privateKey", nt(e)), hl(this.privateKey) !== 32 && cd.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        const r = Ci().keyFromPrivate(ze(this.privateKey));
        Oi(this, "publicKey", "0x" + r.getPublic(!1, "hex")), Oi(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), Oi(this, "_isSigningKey", !0)
    }
    _addPoint(e) {
        const r = Ci().keyFromPublic(ze(this.publicKey)),
            n = Ci().keyFromPublic(ze(e));
        return "0x" + r.pub.add(n.pub).encodeCompressed("hex")
    }
    signDigest(e) {
        const r = Ci().keyFromPrivate(ze(this.privateKey)),
            n = ze(e);
        n.length !== 32 && cd.throwArgumentError("bad digest length", "digest", e);
        const i = r.sign(n, {
            canonical: !0
        });
        return dl({
            recoveryParam: i.recoveryParam,
            r: mn("0x" + i.r.toString(16), 32),
            s: mn("0x" + i.s.toString(16), 32)
        })
    }
    computeSharedSecret(e) {
        const r = Ci().keyFromPrivate(ze(this.privateKey)),
            n = Ci().keyFromPublic(ze(xb(e)));
        return mn("0x" + r.derive(n.getPublic()).toString(16), 32)
    }
    static isSigningKey(e) {
        return !!(e && e._isSigningKey)
    }
}

function n7(t, e) {
    const r = dl(e),
        n = {
            r: ze(r.r),
            s: ze(r.s)
        };
    return "0x" + Ci().recoverPubKey(ze(t), n, r.recoveryParam).encode("hex", !1)
}

function xb(t, e) {
    const r = ze(t);
    if (r.length === 32) {
        const n = new r7(r);
        return e ? "0x" + Ci().keyFromPrivate(r).getPublic(!0, "hex") : n.publicKey
    } else {
        if (r.length === 33) return e ? nt(r) : "0x" + Ci().keyFromPublic(r).getPublic(!1, "hex");
        if (r.length === 65) return e ? "0x" + Ci().keyFromPublic(r).getPublic(!0, "hex") : nt(r)
    }
    return cd.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
}
const i7 = "transactions/5.7.0",
    VS = new dt(i7);
var bb;
(function(t) {
    t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559"
})(bb || (bb = {}));

function s7(t) {
    const e = xb(t);
    return fT(Ir(R1(Ir(e, 1)), 12))
}

function o7(t, e) {
    return s7(n7(ze(t), e))
}
const a7 = "wordlists/5.7.0",
    f7 = new dt(a7);
class mf {
    constructor(e) {
        f7.checkAbstract(new.target, mf), Oi(this, "locale", e)
    }
    split(e) {
        return e.toLowerCase().split(/ +/g)
    }
    join(e) {
        return e.join(" ")
    }
    static check(e) {
        const r = [];
        for (let n = 0; n < 2048; n++) {
            const i = e.getWord(n);
            if (n !== e.getWordIndex(i)) return "0x";
            r.push(i)
        }
        return so(r.join(`
`) + `
`)
    }
    static register(e, r) {}
}
const u7 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let yf = null;

function vb(t) {
    if (yf == null && (yf = u7.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), mf.check(t) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")) throw yf = null, new Error("BIP39 Wordlist for en (English) FAILED")
}
class l7 extends mf {
    constructor() {
        super("en")
    }
    getWord(e) {
        return vb(this), yf[e]
    }
    getWordIndex(e) {
        return vb(this), yf.indexOf(e)
    }
}
const c7 = new l7;
mf.register(c7);
const h7 = "hdnode/5.7.0",
    KS = new dt(h7),
    XS = Ce.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    JS = HT("Bitcoin seed");
const d7 = "random/5.7.0",
    wb = new dt(d7);

function p7() {
    if (typeof self != "undefined") return self;
    if (typeof window != "undefined") return window;
    if (typeof global != "undefined") return global;
    throw new Error("unable to locate global object")
}
const Eb = p7();
let dd = Eb.crypto || Eb.msCrypto;
(!dd || !dd.getRandomValues) && (wb.warn("WARNING: Missing strong random number source"), dd = {
    getRandomValues: function(t) {
        return wb.throwError("no secure random source avaialble", dt.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
        })
    }
});
const Ab = "json-wallets/5.7.0";
const ZS = new dt(Ab);
var YS = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const QS = new dt(Ab);
const m7 = "wallet/5.7.0";
var eP = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const tP = new dt(m7);

function y7(t, e, r, n) {
    return o7(Gr.hash(t, e, r), n)
}
const g7 = "logger/5.7.0";
let _b = !1,
    Tb = !1;
const Il = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let Mb = Il.default,
    pd = null;

function x7() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const Nb = x7();
var md;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(md || (md = {}));
var ni;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(ni || (ni = {}));
const Sb = "0123456789abcdef";
class Ke {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        Il[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(Mb > Il[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(Ke.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Ke.levels.INFO, e)
    }
    warn(...e) {
        this._log(Ke.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (Tb) return this.makeError("censored error", r, {});
        r || (r = Ke.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += Sb[d[A] >> 4], p += Sb[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case ni.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case ni.CALL_EXCEPTION:
            case ni.INSUFFICIENT_FUNDS:
            case ni.MISSING_NEW:
            case ni.NONCE_EXPIRED:
            case ni.REPLACEMENT_UNDERPRICED:
            case ni.TRANSACTION_REPLACED:
            case ni.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, Ke.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        Nb && this.throwError("platform missing String.prototype.normalize", Ke.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: Nb
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Ke.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, Ke.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Ke.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, Ke.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", Ke.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Ke.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", Ke.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return pd || (pd = new Ke(g7)), pd
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Ke.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), _b) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", Ke.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        Tb = !!e, _b = !!r
    }
    static setLogLevel(e) {
        const r = Il[e.toLowerCase()];
        if (r == null) {
            Ke.globalLogger().warn("invalid log level - " + e);
            return
        }
        Mb = r
    }
    static from(e) {
        return new Ke(e)
    }
}
Ke.errors = ni;
Ke.levels = md;
const b7 = "properties/5.7.0";
globalThis && globalThis.__awaiter;
const Pb = new Ke(b7);

function dr(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}

function Rl(t, e) {
    for (let r = 0; r < 32; r++) {
        if (t[e]) return t[e];
        if (!t.prototype || typeof t.prototype != "object") break;
        t = Object.getPrototypeOf(t.prototype).constructor
    }
    return null
}
const v7 = {
    bigint: !0,
    boolean: !0,
    function: !0,
    number: !0,
    string: !0
};

function Ib(t) {
    if (t == null || v7[typeof t]) return !0;
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1;
        const e = Object.keys(t);
        for (let r = 0; r < e.length; r++) {
            let n = null;
            try {
                n = t[e[r]]
            } catch {
                continue
            }
            if (!Ib(n)) return !1
        }
        return !0
    }
    return Pb.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function w7(t) {
    if (Ib(t)) return t;
    if (Array.isArray(t)) return Object.freeze(t.map(e => yd(e)));
    if (typeof t == "object") {
        const e = {};
        for (const r in t) {
            const n = t[r];
            n !== void 0 && dr(e, r, yd(n))
        }
        return e
    }
    return Pb.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function yd(t) {
    return w7(t)
}
class kl {
    constructor(e) {
        for (const r in e) this[r] = yd(e[r])
    }
}
const gf = "abi/5.7.0",
    mt = new Ke(gf),
    ao = {};
let Rb = {
        calldata: !0,
        memory: !0,
        storage: !0
    },
    E7 = {
        calldata: !0,
        memory: !0
    };

function Ol(t, e) {
    if (t === "bytes" || t === "string") {
        if (Rb[e]) return !0
    } else if (t === "address") {
        if (e === "payable") return !0
    } else if ((t.indexOf("[") >= 0 || t === "tuple") && E7[e]) return !0;
    return (Rb[e] || e === "payable") && mt.throwArgumentError("invalid modifier", "name", e), !1
}

function A7(t, e) {
    let r = t;

    function n(f) {
        mt.throwArgumentError(`unexpected character at position ${f}`, "param", t)
    }
    t = t.replace(/\s/g, " ");

    function i(f) {
        let l = {
            type: "",
            name: "",
            parent: f,
            state: {
                allowType: !0
            }
        };
        return e && (l.indexed = !1), l
    }
    let s = {
            type: "",
            name: "",
            state: {
                allowType: !0
            }
        },
        o = s;
    for (let f = 0; f < t.length; f++) {
        let l = t[f];
        switch (l) {
            case "(":
                o.state.allowType && o.type === "" ? o.type = "tuple" : o.state.allowParams || n(f), o.state.allowType = !1, o.type = la(o.type), o.components = [i(o)], o = o.components[0];
                break;
            case ")":
                delete o.state, o.name === "indexed" && (e || n(f), o.indexed = !0, o.name = ""), Ol(o.type, o.name) && (o.name = ""), o.type = la(o.type);
                let d = o;
                o = o.parent, o || n(f), delete d.parent, o.state.allowParams = !1, o.state.allowName = !0, o.state.allowArray = !0;
                break;
            case ",":
                delete o.state, o.name === "indexed" && (e || n(f), o.indexed = !0, o.name = ""), Ol(o.type, o.name) && (o.name = ""), o.type = la(o.type);
                let p = i(o.parent);
                o.parent.components.push(p), delete o.parent, o = p;
                break;
            case " ":
                o.state.allowType && o.type !== "" && (o.type = la(o.type), delete o.state.allowType, o.state.allowName = !0, o.state.allowParams = !0), o.state.allowName && o.name !== "" && (o.name === "indexed" ? (e || n(f), o.indexed && n(f), o.indexed = !0, o.name = "") : Ol(o.type, o.name) ? o.name = "" : o.state.allowName = !1);
                break;
            case "[":
                o.state.allowArray || n(f), o.type += l, o.state.allowArray = !1, o.state.allowName = !1, o.state.readArray = !0;
                break;
            case "]":
                o.state.readArray || n(f), o.type += l, o.state.readArray = !1, o.state.allowArray = !0, o.state.allowName = !0;
                break;
            default:
                o.state.allowType ? (o.type += l, o.state.allowParams = !0, o.state.allowArray = !0) : o.state.allowName ? (o.name += l, delete o.state.allowArray) : o.state.readArray ? o.type += l : n(f)
        }
    }
    return o.parent && mt.throwArgumentError("unexpected eof", "param", t), delete s.state, o.name === "indexed" ? (e || n(r.length - 7), o.indexed && n(r.length - 7), o.indexed = !0, o.name = "") : Ol(o.type, o.name) && (o.name = ""), s.type = la(s.type), s
}

function Cl(t, e) {
    for (let r in e) dr(t, r, e[r])
}
const xt = Object.freeze({
        sighash: "sighash",
        minimal: "minimal",
        full: "full",
        json: "json"
    }),
    _7 = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ar {
    constructor(e, r) {
        e !== ao && mt.throwError("use fromString", Ke.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
        }), Cl(this, r);
        let n = this.type.match(_7);
        n ? Cl(this, {
            arrayLength: parseInt(n[2] || "-1"),
            arrayChildren: ar.fromObject({
                type: n[1],
                components: this.components
            }),
            baseType: "array"
        }) : Cl(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
        }), this._isParamType = !0, Object.freeze(this)
    }
    format(e) {
        if (e || (e = xt.sighash), xt[e] || mt.throwArgumentError("invalid format type", "format", e), e === xt.json) {
            let n = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || void 0
            };
            return typeof this.indexed == "boolean" && (n.indexed = this.indexed), this.components && (n.components = this.components.map(i => JSON.parse(i.format(e)))), JSON.stringify(n)
        }
        let r = "";
        return this.baseType === "array" ? (r += this.arrayChildren.format(e), r += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== xt.sighash && (r += this.type), r += "(" + this.components.map(n => n.format(e)).join(e === xt.full ? ", " : ",") + ")") : r += this.type, e !== xt.sighash && (this.indexed === !0 && (r += " indexed"), e === xt.full && this.name && (r += " " + this.name)), r
    }
    static from(e, r) {
        return typeof e == "string" ? ar.fromString(e, r) : ar.fromObject(e)
    }
    static fromObject(e) {
        return ar.isParamType(e) ? e : new ar(ao, {
            name: e.name || null,
            type: la(e.type),
            indexed: e.indexed == null ? null : !!e.indexed,
            components: e.components ? e.components.map(ar.fromObject) : null
        })
    }
    static fromString(e, r) {
        function n(i) {
            return ar.fromObject({
                name: i.name,
                type: i.type,
                indexed: i.indexed,
                components: i.components
            })
        }
        return n(A7(e, !!r))
    }
    static isParamType(e) {
        return !!(e != null && e._isParamType)
    }
}

function xf(t, e) {
    return M7(t).map(r => ar.fromString(r, e))
}
class rs {
    constructor(e, r) {
        e !== ao && mt.throwError("use a static from method", Ke.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
        }), Cl(this, r), this._isFragment = !0, Object.freeze(this)
    }
    static from(e) {
        return rs.isFragment(e) ? e : typeof e == "string" ? rs.fromString(e) : rs.fromObject(e)
    }
    static fromObject(e) {
        if (rs.isFragment(e)) return e;
        switch (e.type) {
            case "function":
                return Di.fromObject(e);
            case "event":
                return ns.fromObject(e);
            case "constructor":
                return Fi.fromObject(e);
            case "error":
                return Ss.fromObject(e);
            case "fallback":
            case "receive":
                return null
        }
        return mt.throwArgumentError("invalid fragment object", "value", e)
    }
    static fromString(e) {
        return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? ns.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? Di.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? Fi.fromString(e.trim()) : e.split(" ")[0] === "error" ? Ss.fromString(e.substring(5).trim()) : mt.throwArgumentError("unsupported fragment", "value", e)
    }
    static isFragment(e) {
        return !!(e && e._isFragment)
    }
}
class ns extends rs {
    format(e) {
        if (e || (e = xt.sighash), xt[e] || mt.throwArgumentError("invalid format type", "format", e), e === xt.json) return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(n => JSON.parse(n.format(e)))
        });
        let r = "";
        return e !== xt.sighash && (r += "event "), r += this.name + "(" + this.inputs.map(n => n.format(e)).join(e === xt.full ? ", " : ",") + ") ", e !== xt.sighash && this.anonymous && (r += "anonymous "), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? ns.fromString(e) : ns.fromObject(e)
    }
    static fromObject(e) {
        if (ns.isEventFragment(e)) return e;
        e.type !== "event" && mt.throwArgumentError("invalid event object", "value", e);
        const r = {
            name: bf(e.name),
            anonymous: e.anonymous,
            inputs: e.inputs ? e.inputs.map(ar.fromObject) : [],
            type: "event"
        };
        return new ns(ao, r)
    }
    static fromString(e) {
        let r = e.match(vf);
        r || mt.throwArgumentError("invalid event string", "value", e);
        let n = !1;
        return r[3].split(" ").forEach(i => {
            switch (i.trim()) {
                case "anonymous":
                    n = !0;
                    break;
                case "":
                    break;
                default:
                    mt.warn("unknown modifier: " + i)
            }
        }), ns.fromObject({
            name: r[1].trim(),
            anonymous: n,
            inputs: xf(r[2], !0),
            type: "event"
        })
    }
    static isEventFragment(e) {
        return e && e._isFragment && e.type === "event"
    }
}

function kb(t, e) {
    e.gas = null;
    let r = t.split("@");
    return r.length !== 1 ? (r.length > 2 && mt.throwArgumentError("invalid human-readable ABI signature", "value", t), r[1].match(/^[0-9]+$/) || mt.throwArgumentError("invalid human-readable ABI signature gas", "value", t), e.gas = Ce.from(r[1]), r[0]) : t
}

function Ob(t, e) {
    e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", t.split(" ").forEach(r => {
        switch (r.trim()) {
            case "constant":
                e.constant = !0;
                break;
            case "payable":
                e.payable = !0, e.stateMutability = "payable";
                break;
            case "nonpayable":
                e.payable = !1, e.stateMutability = "nonpayable";
                break;
            case "pure":
                e.constant = !0, e.stateMutability = "pure";
                break;
            case "view":
                e.constant = !0, e.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + r)
        }
    })
}

function Cb(t) {
    let e = {
        constant: !1,
        payable: !0,
        stateMutability: "payable"
    };
    return t.stateMutability != null ? (e.stateMutability = t.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", t.constant != null && !!t.constant !== e.constant && mt.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t), e.payable = e.stateMutability === "payable", t.payable != null && !!t.payable !== e.payable && mt.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t)) : t.payable != null ? (e.payable = !!t.payable, t.constant == null && !e.payable && t.type !== "constructor" && mt.throwArgumentError("unable to determine stateMutability", "value", t), e.constant = !!t.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && mt.throwArgumentError("cannot have constant payable function", "value", t)) : t.constant != null ? (e.constant = !!t.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : t.type !== "constructor" && mt.throwArgumentError("unable to determine stateMutability", "value", t), e
}
class Fi extends rs {
    format(e) {
        if (e || (e = xt.sighash), xt[e] || mt.throwArgumentError("invalid format type", "format", e), e === xt.json) return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(n => JSON.parse(n.format(e)))
        });
        e === xt.sighash && mt.throwError("cannot format a constructor for sighash", Ke.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
        });
        let r = "constructor(" + this.inputs.map(n => n.format(e)).join(e === xt.full ? ", " : ",") + ") ";
        return this.stateMutability && this.stateMutability !== "nonpayable" && (r += this.stateMutability + " "), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? Fi.fromString(e) : Fi.fromObject(e)
    }
    static fromObject(e) {
        if (Fi.isConstructorFragment(e)) return e;
        e.type !== "constructor" && mt.throwArgumentError("invalid constructor object", "value", e);
        let r = Cb(e);
        r.constant && mt.throwArgumentError("constructor cannot be constant", "value", e);
        const n = {
            name: null,
            type: e.type,
            inputs: e.inputs ? e.inputs.map(ar.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: e.gas ? Ce.from(e.gas) : null
        };
        return new Fi(ao, n)
    }
    static fromString(e) {
        let r = {
            type: "constructor"
        };
        e = kb(e, r);
        let n = e.match(vf);
        return (!n || n[1].trim() !== "constructor") && mt.throwArgumentError("invalid constructor string", "value", e), r.inputs = xf(n[2].trim(), !1), Ob(n[3].trim(), r), Fi.fromObject(r)
    }
    static isConstructorFragment(e) {
        return e && e._isFragment && e.type === "constructor"
    }
}
class Di extends Fi {
    format(e) {
        if (e || (e = xt.sighash), xt[e] || mt.throwArgumentError("invalid format type", "format", e), e === xt.json) return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(n => JSON.parse(n.format(e))),
            outputs: this.outputs.map(n => JSON.parse(n.format(e)))
        });
        let r = "";
        return e !== xt.sighash && (r += "function "), r += this.name + "(" + this.inputs.map(n => n.format(e)).join(e === xt.full ? ", " : ",") + ") ", e !== xt.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (r += this.stateMutability + " ") : this.constant && (r += "view "), this.outputs && this.outputs.length && (r += "returns (" + this.outputs.map(n => n.format(e)).join(", ") + ") "), this.gas != null && (r += "@" + this.gas.toString() + " ")), r.trim()
    }
    static from(e) {
        return typeof e == "string" ? Di.fromString(e) : Di.fromObject(e)
    }
    static fromObject(e) {
        if (Di.isFunctionFragment(e)) return e;
        e.type !== "function" && mt.throwArgumentError("invalid function object", "value", e);
        let r = Cb(e);
        const n = {
            type: e.type,
            name: bf(e.name),
            constant: r.constant,
            inputs: e.inputs ? e.inputs.map(ar.fromObject) : [],
            outputs: e.outputs ? e.outputs.map(ar.fromObject) : [],
            payable: r.payable,
            stateMutability: r.stateMutability,
            gas: e.gas ? Ce.from(e.gas) : null
        };
        return new Di(ao, n)
    }
    static fromString(e) {
        let r = {
            type: "function"
        };
        e = kb(e, r);
        let n = e.split(" returns ");
        n.length > 2 && mt.throwArgumentError("invalid function string", "value", e);
        let i = n[0].match(vf);
        if (i || mt.throwArgumentError("invalid function signature", "value", e), r.name = i[1].trim(), r.name && bf(r.name), r.inputs = xf(i[2], !1), Ob(i[3].trim(), r), n.length > 1) {
            let s = n[1].match(vf);
            (s[1].trim() != "" || s[3].trim() != "") && mt.throwArgumentError("unexpected tokens", "value", e), r.outputs = xf(s[2], !1)
        } else r.outputs = [];
        return Di.fromObject(r)
    }
    static isFunctionFragment(e) {
        return e && e._isFragment && e.type === "function"
    }
}

function Fb(t) {
    const e = t.format();
    return (e === "Error(string)" || e === "Panic(uint256)") && mt.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", t), t
}
class Ss extends rs {
    format(e) {
        if (e || (e = xt.sighash), xt[e] || mt.throwArgumentError("invalid format type", "format", e), e === xt.json) return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(n => JSON.parse(n.format(e)))
        });
        let r = "";
        return e !== xt.sighash && (r += "error "), r += this.name + "(" + this.inputs.map(n => n.format(e)).join(e === xt.full ? ", " : ",") + ") ", r.trim()
    }
    static from(e) {
        return typeof e == "string" ? Ss.fromString(e) : Ss.fromObject(e)
    }
    static fromObject(e) {
        if (Ss.isErrorFragment(e)) return e;
        e.type !== "error" && mt.throwArgumentError("invalid error object", "value", e);
        const r = {
            type: e.type,
            name: bf(e.name),
            inputs: e.inputs ? e.inputs.map(ar.fromObject) : []
        };
        return Fb(new Ss(ao, r))
    }
    static fromString(e) {
        let r = {
                type: "error"
            },
            n = e.match(vf);
        return n || mt.throwArgumentError("invalid error signature", "value", e), r.name = n[1].trim(), r.name && bf(r.name), r.inputs = xf(n[2], !1), Fb(Ss.fromObject(r))
    }
    static isErrorFragment(e) {
        return e && e._isFragment && e.type === "error"
    }
}

function la(t) {
    return t.match(/^uint($|[^1-9])/) ? t = "uint256" + t.substring(4) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t
}
const T7 = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

function bf(t) {
    return (!t || !t.match(T7)) && mt.throwArgumentError(`invalid identifier "${t}"`, "value", t), t
}
const vf = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

function M7(t) {
    t = t.trim();
    let e = [],
        r = "",
        n = 0;
    for (let i = 0; i < t.length; i++) {
        let s = t[i];
        s === "," && n === 0 ? (e.push(r), r = "") : (r += s, s === "(" ? n++ : s === ")" && (n--, n === -1 && mt.throwArgumentError("unbalanced parenthesis", "value", t)))
    }
    return r && e.push(r), e
}
const gd = new Ke(gf);

function N7(t) {
    const e = [],
        r = function(n, i) {
            if (!!Array.isArray(i))
                for (let s in i) {
                    const o = n.slice();
                    o.push(s);
                    try {
                        r(o, i[s])
                    } catch (f) {
                        e.push({
                            path: o,
                            error: f
                        })
                    }
                }
        };
    return r([], t), e
}
class is {
    constructor(e, r, n, i) {
        this.name = e, this.type = r, this.localName = n, this.dynamic = i
    }
    _throwError(e, r) {
        gd.throwArgumentError(e, this.localName, r)
    }
}
class xd {
    constructor(e) {
        dr(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e)
    }
    get data() {
        return pn(this._data)
    }
    get length() {
        return this._dataLength
    }
    _writeData(e) {
        return this._data.push(e), this._dataLength += e.length, e.length
    }
    appendWriter(e) {
        return this._writeData(io(e._data))
    }
    writeBytes(e) {
        let r = ze(e);
        const n = r.length % this.wordSize;
        return n && (r = io([r, this._padding.slice(n)])), this._writeData(r)
    }
    _getValue(e) {
        let r = ze(Ce.from(e));
        return r.length > this.wordSize && gd.throwError("value out-of-bounds", Ke.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: r.length
        }), r.length % this.wordSize && (r = io([this._padding.slice(r.length % this.wordSize), r])), r
    }
    writeValue(e) {
        return this._writeData(this._getValue(e))
    }
    writeUpdatableValue() {
        const e = this._data.length;
        return this._data.push(this._padding), this._dataLength += this.wordSize, r => {
            this._data[e] = this._getValue(r)
        }
    }
}
class Fl {
    constructor(e, r, n, i) {
        dr(this, "_data", ze(e)), dr(this, "wordSize", r || 32), dr(this, "_coerceFunc", n), dr(this, "allowLoose", i), this._offset = 0
    }
    get data() {
        return nt(this._data)
    }
    get consumed() {
        return this._offset
    }
    static coerce(e, r) {
        let n = e.match("^u?int([0-9]+)$");
        return n && parseInt(n[1]) <= 48 && (r = r.toNumber()), r
    }
    coerce(e, r) {
        return this._coerceFunc ? this._coerceFunc(e, r) : Fl.coerce(e, r)
    }
    _peekBytes(e, r, n) {
        let i = Math.ceil(r / this.wordSize) * this.wordSize;
        return this._offset + i > this._data.length && (this.allowLoose && n && this._offset + r <= this._data.length ? i = r : gd.throwError("data out-of-bounds", Ke.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + i
        })), this._data.slice(this._offset, this._offset + i)
    }
    subReader(e) {
        return new Fl(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose)
    }
    readBytes(e, r) {
        let n = this._peekBytes(0, e, !!r);
        return this._offset += n.length, n.slice(0, e)
    }
    readValue() {
        return Ce.from(this.readBytes(this.wordSize))
    }
}

function bd(t) {
    return "0x" + Ha.keccak_256(ze(t))
}
const S7 = "address/5.7.0",
    wf = new Ke(S7);

function Db(t) {
    $t(t, 20) || wf.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        r = new Uint8Array(40);
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
    const n = ze(bd(r));
    for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const P7 = 9007199254740991;

function I7(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const vd = {};
for (let t = 0; t < 10; t++) vd[String(t)] = String(t);
for (let t = 0; t < 26; t++) vd[String.fromCharCode(65 + t)] = String(10 + t);
const Ub = Math.floor(I7(P7));

function R7(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(n => vd[n]).join("");
    for (; e.length >= Ub;) {
        let n = e.substring(0, Ub);
        e = parseInt(n, 10) % 97 + e.substring(n.length)
    }
    let r = String(98 - parseInt(e, 10) % 97);
    for (; r.length < 2;) r = "0" + r;
    return r
}

function wd(t) {
    let e = null;
    if (typeof t != "string" && wf.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = Db(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && wf.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== R7(t) && wf.throwArgumentError("bad icap checksum", "address", t), e = yl(t.substring(4)); e.length < 40;) e = "0" + e;
        e = Db("0x" + e)
    } else wf.throwArgumentError("invalid address", "address", t);
    return e
}
class k7 extends is {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, r) {
        try {
            r = wd(r)
        } catch (n) {
            this._throwError(n.message, r)
        }
        return e.writeValue(r)
    }
    decode(e) {
        return wd(mn(e.readValue().toHexString(), 20))
    }
}
class O7 extends is {
    constructor(e) {
        super(e.name, e.type, void 0, e.dynamic);
        this.coder = e
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, r) {
        return this.coder.encode(e, r)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}
const ca = new Ke(gf);

function Lb(t, e, r) {
    let n = null;
    if (Array.isArray(r)) n = r;
    else if (r && typeof r == "object") {
        let l = {};
        n = e.map(d => {
            const p = d.localName;
            return p || ca.throwError("cannot encode object for signature with missing names", Ke.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: d,
                value: r
            }), l[p] && ca.throwError("cannot encode object for signature with duplicate names", Ke.errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: d,
                value: r
            }), l[p] = !0, r[p]
        })
    } else ca.throwArgumentError("invalid tuple value", "tuple", r);
    e.length !== n.length && ca.throwArgumentError("types/value length mismatch", "tuple", r);
    let i = new xd(t.wordSize),
        s = new xd(t.wordSize),
        o = [];
    e.forEach((l, d) => {
        let p = n[d];
        if (l.dynamic) {
            let A = s.length;
            l.encode(s, p);
            let T = i.writeUpdatableValue();
            o.push(N => {
                T(N + A)
            })
        } else l.encode(i, p)
    }), o.forEach(l => {
        l(i.length)
    });
    let f = t.appendWriter(i);
    return f += t.appendWriter(s), f
}

function Bb(t, e) {
    let r = [],
        n = t.subReader(0);
    e.forEach(s => {
        let o = null;
        if (s.dynamic) {
            let f = t.readValue(),
                l = n.subReader(f.toNumber());
            try {
                o = s.decode(l)
            } catch (d) {
                if (d.code === Ke.errors.BUFFER_OVERRUN) throw d;
                o = d, o.baseType = s.name, o.name = s.localName, o.type = s.type
            }
        } else try {
            o = s.decode(t)
        } catch (f) {
            if (f.code === Ke.errors.BUFFER_OVERRUN) throw f;
            o = f, o.baseType = s.name, o.name = s.localName, o.type = s.type
        }
        o != null && r.push(o)
    });
    const i = e.reduce((s, o) => {
        const f = o.localName;
        return f && (s[f] || (s[f] = 0), s[f]++), s
    }, {});
    e.forEach((s, o) => {
        let f = s.localName;
        if (!f || i[f] !== 1 || (f === "length" && (f = "_length"), r[f] != null)) return;
        const l = r[o];
        l instanceof Error ? Object.defineProperty(r, f, {
            enumerable: !0,
            get: () => {
                throw l
            }
        }) : r[f] = l
    });
    for (let s = 0; s < r.length; s++) {
        const o = r[s];
        o instanceof Error && Object.defineProperty(r, s, {
            enumerable: !0,
            get: () => {
                throw o
            }
        })
    }
    return Object.freeze(r)
}
class C7 extends is {
    constructor(e, r, n) {
        const i = e.type + "[" + (r >= 0 ? r : "") + "]",
            s = r === -1 || e.dynamic;
        super("array", i, n, s);
        this.coder = e, this.length = r
    }
    defaultValue() {
        const e = this.coder.defaultValue(),
            r = [];
        for (let n = 0; n < this.length; n++) r.push(e);
        return r
    }
    encode(e, r) {
        Array.isArray(r) || this._throwError("expected array value", r);
        let n = this.length;
        n === -1 && (n = r.length, e.writeValue(r.length)), ca.checkArgumentCount(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
        let i = [];
        for (let s = 0; s < r.length; s++) i.push(this.coder);
        return Lb(e, i, r)
    }
    decode(e) {
        let r = this.length;
        r === -1 && (r = e.readValue().toNumber(), r * 32 > e._data.length && ca.throwError("insufficient data length", Ke.errors.BUFFER_OVERRUN, {
            length: e._data.length,
            count: r
        }));
        let n = [];
        for (let i = 0; i < r; i++) n.push(new O7(this.coder));
        return e.coerce(this.name, Bb(e, n))
    }
}
class F7 extends is {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, r) {
        return e.writeValue(r ? 1 : 0)
    }
    decode(e) {
        return e.coerce(this.type, !e.readValue().isZero())
    }
}
class $b extends is {
    constructor(e, r) {
        super(e, e, r, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, r) {
        r = ze(r);
        let n = e.writeValue(r.length);
        return n += e.writeBytes(r), n
    }
    decode(e) {
        return e.readBytes(e.readValue().toNumber(), !0)
    }
}
class D7 extends $b {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return e.coerce(this.name, nt(super.decode(e)))
    }
}
class U7 extends is {
    constructor(e, r) {
        let n = "bytes" + String(e);
        super(n, n, r, !1);
        this.size = e
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, r) {
        let n = ze(r);
        return n.length !== this.size && this._throwError("incorrect data length", r), e.writeBytes(n)
    }
    decode(e) {
        return e.coerce(this.name, nt(e.readBytes(this.size)))
    }
}
class L7 extends is {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, r) {
        return r != null && this._throwError("not null", r), e.writeBytes([])
    }
    decode(e) {
        return e.readBytes(0), e.coerce(this.name, null)
    }
}
const B7 = Ce.from(-1),
    $7 = Ce.from(0),
    G7 = Ce.from(1),
    z7 = Ce.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class H7 extends is {
    constructor(e, r, n) {
        const i = (r ? "int" : "uint") + e * 8;
        super(i, i, n, !1);
        this.size = e, this.signed = r
    }
    defaultValue() {
        return 0
    }
    encode(e, r) {
        let n = Ce.from(r),
            i = z7.mask(e.wordSize * 8);
        if (this.signed) {
            let s = i.mask(this.size * 8 - 1);
            (n.gt(s) || n.lt(s.add(G7).mul(B7))) && this._throwError("value out-of-bounds", r)
        } else(n.lt($7) || n.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", r);
        return n = n.toTwos(this.size * 8).mask(this.size * 8), this.signed && (n = n.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(n)
    }
    decode(e) {
        let r = e.readValue().mask(this.size * 8);
        return this.signed && (r = r.fromTwos(this.size * 8)), e.coerce(this.name, r)
    }
}
const q7 = "strings/5.7.0",
    Gb = new Ke(q7);
var Dl;
(function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD"
})(Dl || (Dl = {}));
var Qr;
(function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation"
})(Qr || (Qr = {}));

function j7(t, e, r, n, i) {
    return Gb.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", r)
}

function zb(t, e, r, n, i) {
    if (t === Qr.BAD_PREFIX || t === Qr.UNEXPECTED_CONTINUE) {
        let s = 0;
        for (let o = e + 1; o < r.length && r[o] >> 6 == 2; o++) s++;
        return s
    }
    return t === Qr.OVERRUN ? r.length - e - 1 : 0
}

function W7(t, e, r, n, i) {
    return t === Qr.OVERLONG ? (n.push(i), 0) : (n.push(65533), zb(t, e, r))
}
const V7 = Object.freeze({
    error: j7,
    ignore: zb,
    replace: W7
});

function K7(t, e) {
    e == null && (e = V7.error), t = ze(t);
    const r = [];
    let n = 0;
    for (; n < t.length;) {
        const i = t[n++];
        if (i >> 7 == 0) {
            r.push(i);
            continue
        }
        let s = null,
            o = null;
        if ((i & 224) == 192) s = 1, o = 127;
        else if ((i & 240) == 224) s = 2, o = 2047;
        else if ((i & 248) == 240) s = 3, o = 65535;
        else {
            (i & 192) == 128 ? n += e(Qr.UNEXPECTED_CONTINUE, n - 1, t, r) : n += e(Qr.BAD_PREFIX, n - 1, t, r);
            continue
        }
        if (n - 1 + s >= t.length) {
            n += e(Qr.OVERRUN, n - 1, t, r);
            continue
        }
        let f = i & (1 << 8 - s - 1) - 1;
        for (let l = 0; l < s; l++) {
            let d = t[n];
            if ((d & 192) != 128) {
                n += e(Qr.MISSING_CONTINUE, n, t, r), f = null;
                break
            }
            f = f << 6 | d & 63, n++
        }
        if (f !== null) {
            if (f > 1114111) {
                n += e(Qr.OUT_OF_RANGE, n - 1 - s, t, r, f);
                continue
            }
            if (f >= 55296 && f <= 57343) {
                n += e(Qr.UTF16_SURROGATE, n - 1 - s, t, r, f);
                continue
            }
            if (f <= o) {
                n += e(Qr.OVERLONG, n - 1 - s, t, r, f);
                continue
            }
            r.push(f)
        }
    }
    return r
}

function X7(t, e = Dl.current) {
    e != Dl.current && (Gb.checkNormalize(), t = t.normalize(e));
    let r = [];
    for (let n = 0; n < t.length; n++) {
        const i = t.charCodeAt(n);
        if (i < 128) r.push(i);
        else if (i < 2048) r.push(i >> 6 | 192), r.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            n++;
            const s = t.charCodeAt(n);
            if (n >= t.length || (s & 64512) != 56320) throw new Error("invalid utf-8 string");
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128)
        } else r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128)
    }
    return ze(r)
}

function J7(t) {
    return t.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}

function Z7(t, e) {
    return J7(K7(t, e))
}
class Y7 extends $b {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, r) {
        return super.encode(e, X7(r))
    }
    decode(e) {
        return Z7(super.decode(e))
    }
}
class Ul extends is {
    constructor(e, r) {
        let n = !1;
        const i = [];
        e.forEach(o => {
            o.dynamic && (n = !0), i.push(o.type)
        });
        const s = "tuple(" + i.join(",") + ")";
        super("tuple", s, r, n);
        this.coders = e
    }
    defaultValue() {
        const e = [];
        this.coders.forEach(n => {
            e.push(n.defaultValue())
        });
        const r = this.coders.reduce((n, i) => {
            const s = i.localName;
            return s && (n[s] || (n[s] = 0), n[s]++), n
        }, {});
        return this.coders.forEach((n, i) => {
            let s = n.localName;
            !s || r[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]))
        }), Object.freeze(e)
    }
    encode(e, r) {
        return Lb(e, this.coders, r)
    }
    decode(e) {
        return e.coerce(this.name, Bb(e, this.coders))
    }
}
const Ll = new Ke(gf),
    Q7 = new RegExp(/^bytes([0-9]*)$/),
    e9 = new RegExp(/^(u?int)([0-9]*)$/);
class t9 {
    constructor(e) {
        dr(this, "coerceFunc", e || null)
    }
    _getCoder(e) {
        switch (e.baseType) {
            case "address":
                return new k7(e.name);
            case "bool":
                return new F7(e.name);
            case "string":
                return new Y7(e.name);
            case "bytes":
                return new D7(e.name);
            case "array":
                return new C7(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
            case "tuple":
                return new Ul((e.components || []).map(n => this._getCoder(n)), e.name);
            case "":
                return new L7(e.name)
        }
        let r = e.type.match(e9);
        if (r) {
            let n = parseInt(r[2] || "256");
            return (n === 0 || n > 256 || n % 8 != 0) && Ll.throwArgumentError("invalid " + r[1] + " bit length", "param", e), new H7(n / 8, r[1] === "int", e.name)
        }
        if (r = e.type.match(Q7), r) {
            let n = parseInt(r[1]);
            return (n === 0 || n > 32) && Ll.throwArgumentError("invalid bytes length", "param", e), new U7(n, e.name)
        }
        return Ll.throwArgumentError("invalid type", "type", e.type)
    }
    _getWordSize() {
        return 32
    }
    _getReader(e, r) {
        return new Fl(e, this._getWordSize(), this.coerceFunc, r)
    }
    _getWriter() {
        return new xd(this._getWordSize())
    }
    getDefaultValue(e) {
        const r = e.map(i => this._getCoder(ar.from(i)));
        return new Ul(r, "_").defaultValue()
    }
    encode(e, r) {
        e.length !== r.length && Ll.throwError("types/values length mismatch", Ke.errors.INVALID_ARGUMENT, {
            count: {
                types: e.length,
                values: r.length
            },
            value: {
                types: e,
                values: r
            }
        });
        const n = e.map(o => this._getCoder(ar.from(o))),
            i = new Ul(n, "_"),
            s = this._getWriter();
        return i.encode(s, r), s.data
    }
    decode(e, r, n) {
        const i = e.map(o => this._getCoder(ar.from(o)));
        return new Ul(i, "_").decode(this._getReader(ze(r), n))
    }
}
const ss = new t9,
    Dt = new Ke(gf);
class r9 extends kl {}
class n9 extends kl {}
class i9 extends kl {}
class Ed extends kl {
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
}
const s9 = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: !0
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"]
    }
};

function Hb(t, e) {
    const r = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
    return r.error = e, r
}
class Ps {
    constructor(e) {
        let r = [];
        typeof e == "string" ? r = JSON.parse(e) : r = e, dr(this, "fragments", r.map(n => rs.from(n)).filter(n => n != null)), dr(this, "_abiCoder", Rl(new.target, "getAbiCoder")()), dr(this, "functions", {}), dr(this, "errors", {}), dr(this, "events", {}), dr(this, "structs", {}), this.fragments.forEach(n => {
            let i = null;
            switch (n.type) {
                case "constructor":
                    if (this.deploy) {
                        Dt.warn("duplicate definition - constructor");
                        return
                    }
                    dr(this, "deploy", n);
                    return;
                case "function":
                    i = this.functions;
                    break;
                case "event":
                    i = this.events;
                    break;
                case "error":
                    i = this.errors;
                    break;
                default:
                    return
            }
            let s = n.format();
            if (i[s]) {
                Dt.warn("duplicate definition - " + s);
                return
            }
            i[s] = n
        }), this.deploy || dr(this, "deploy", Fi.from({
            payable: !1,
            type: "constructor"
        })), dr(this, "_isInterface", !0)
    }
    format(e) {
        e || (e = xt.full), e === xt.sighash && Dt.throwArgumentError("interface does not support formatting sighash", "format", e);
        const r = this.fragments.map(n => n.format(e));
        return e === xt.json ? JSON.stringify(r.map(n => JSON.parse(n))) : r
    }
    static getAbiCoder() {
        return ss
    }
    static getAddress(e) {
        return wd(e)
    }
    static getSighash(e) {
        return Ir(so(e.format()), 0, 4)
    }
    static getEventTopic(e) {
        return so(e.format())
    }
    getFunction(e) {
        if ($t(e)) {
            for (const n in this.functions)
                if (e === this.getSighash(n)) return this.functions[n];
            Dt.throwArgumentError("no matching function", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.functions).filter(s => s.split("(")[0] === n);
            return i.length === 0 ? Dt.throwArgumentError("no matching function", "name", n) : i.length > 1 && Dt.throwArgumentError("multiple matching functions", "name", n), this.functions[i[0]]
        }
        const r = this.functions[Di.fromString(e).format()];
        return r || Dt.throwArgumentError("no matching function", "signature", e), r
    }
    getEvent(e) {
        if ($t(e)) {
            const n = e.toLowerCase();
            for (const i in this.events)
                if (n === this.getEventTopic(i)) return this.events[i];
            Dt.throwArgumentError("no matching event", "topichash", n)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.events).filter(s => s.split("(")[0] === n);
            return i.length === 0 ? Dt.throwArgumentError("no matching event", "name", n) : i.length > 1 && Dt.throwArgumentError("multiple matching events", "name", n), this.events[i[0]]
        }
        const r = this.events[ns.fromString(e).format()];
        return r || Dt.throwArgumentError("no matching event", "signature", e), r
    }
    getError(e) {
        if ($t(e)) {
            const n = Rl(this.constructor, "getSighash");
            for (const i in this.errors) {
                const s = this.errors[i];
                if (e === n(s)) return this.errors[i]
            }
            Dt.throwArgumentError("no matching error", "sighash", e)
        }
        if (e.indexOf("(") === -1) {
            const n = e.trim(),
                i = Object.keys(this.errors).filter(s => s.split("(")[0] === n);
            return i.length === 0 ? Dt.throwArgumentError("no matching error", "name", n) : i.length > 1 && Dt.throwArgumentError("multiple matching errors", "name", n), this.errors[i[0]]
        }
        const r = this.errors[Di.fromString(e).format()];
        return r || Dt.throwArgumentError("no matching error", "signature", e), r
    }
    getSighash(e) {
        if (typeof e == "string") try {
            e = this.getFunction(e)
        } catch (r) {
            try {
                e = this.getError(e)
            } catch {
                throw r
            }
        }
        return Rl(this.constructor, "getSighash")(e)
    }
    getEventTopic(e) {
        return typeof e == "string" && (e = this.getEvent(e)), Rl(this.constructor, "getEventTopic")(e)
    }
    _decodeParams(e, r) {
        return this._abiCoder.decode(e, r)
    }
    _encodeParams(e, r) {
        return this._abiCoder.encode(e, r)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, r) {
        typeof e == "string" && (e = this.getError(e));
        const n = ze(r);
        return nt(n.slice(0, 4)) !== this.getSighash(e) && Dt.throwArgumentError(`data signature does not match error ${e.name}.`, "data", nt(n)), this._decodeParams(e.inputs, n.slice(4))
    }
    encodeErrorResult(e, r) {
        return typeof e == "string" && (e = this.getError(e)), nt(io([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    }
    decodeFunctionData(e, r) {
        typeof e == "string" && (e = this.getFunction(e));
        const n = ze(r);
        return nt(n.slice(0, 4)) !== this.getSighash(e) && Dt.throwArgumentError(`data signature does not match function ${e.name}.`, "data", nt(n)), this._decodeParams(e.inputs, n.slice(4))
    }
    encodeFunctionData(e, r) {
        return typeof e == "string" && (e = this.getFunction(e)), nt(io([this.getSighash(e), this._encodeParams(e.inputs, r || [])]))
    }
    decodeFunctionResult(e, r) {
        typeof e == "string" && (e = this.getFunction(e));
        let n = ze(r),
            i = null,
            s = "",
            o = null,
            f = null,
            l = null;
        switch (n.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(e.outputs, n)
                } catch {}
                break;
            case 4:
                {
                    const d = nt(n.slice(0, 4)),
                        p = s9[d];
                    if (p) o = this._abiCoder.decode(p.inputs, n.slice(4)),
                    f = p.name,
                    l = p.signature,
                    p.reason && (i = o[0]),
                    f === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}` : f === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`);
                    else try {
                        const A = this.getError(d);
                        o = this._abiCoder.decode(A.inputs, n.slice(4)), f = A.name, l = A.format()
                    } catch {}
                    break
                }
        }
        return Dt.throwError("call revert exception" + s, Ke.errors.CALL_EXCEPTION, {
            method: e.format(),
            data: nt(r),
            errorArgs: o,
            errorName: f,
            errorSignature: l,
            reason: i
        })
    }
    encodeFunctionResult(e, r) {
        return typeof e == "string" && (e = this.getFunction(e)), nt(this._abiCoder.encode(e.outputs, r || []))
    }
    encodeFilterTopics(e, r) {
        typeof e == "string" && (e = this.getEvent(e)), r.length > e.inputs.length && Dt.throwError("too many arguments for " + e.format(), Ke.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: r
        });
        let n = [];
        e.anonymous || n.push(this.getEventTopic(e));
        const i = (s, o) => s.type === "string" ? so(o) : s.type === "bytes" ? bd(nt(o)) : (s.type === "bool" && typeof o == "boolean" && (o = o ? "0x01" : "0x00"), s.type.match(/^u?int/) && (o = Ce.from(o).toHexString()), s.type === "address" && this._abiCoder.encode(["address"], [o]), mn(nt(o), 32));
        for (r.forEach((s, o) => {
                let f = e.inputs[o];
                if (!f.indexed) {
                    s != null && Dt.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + f.name, s);
                    return
                }
                s == null ? n.push(null) : f.baseType === "array" || f.baseType === "tuple" ? Dt.throwArgumentError("filtering with tuples or arrays not supported", "contract." + f.name, s) : Array.isArray(s) ? n.push(s.map(l => i(f, l))) : n.push(i(f, s))
            }); n.length && n[n.length - 1] === null;) n.pop();
        return n
    }
    encodeEventLog(e, r) {
        typeof e == "string" && (e = this.getEvent(e));
        const n = [],
            i = [],
            s = [];
        return e.anonymous || n.push(this.getEventTopic(e)), r.length !== e.inputs.length && Dt.throwArgumentError("event arguments/values mismatch", "values", r), e.inputs.forEach((o, f) => {
            const l = r[f];
            if (o.indexed)
                if (o.type === "string") n.push(so(l));
                else if (o.type === "bytes") n.push(bd(l));
            else {
                if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
                n.push(this._abiCoder.encode([o.type], [l]))
            } else i.push(o), s.push(l)
        }), {
            data: this._abiCoder.encode(i, s),
            topics: n
        }
    }
    decodeEventLog(e, r, n) {
        if (typeof e == "string" && (e = this.getEvent(e)), n != null && !e.anonymous) {
            let T = this.getEventTopic(e);
            (!$t(n[0], 32) || n[0].toLowerCase() !== T) && Dt.throwError("fragment/topic mismatch", Ke.errors.INVALID_ARGUMENT, {
                argument: "topics[0]",
                expected: T,
                value: n[0]
            }), n = n.slice(1)
        }
        let i = [],
            s = [],
            o = [];
        e.inputs.forEach((T, N) => {
            T.indexed ? T.type === "string" || T.type === "bytes" || T.baseType === "tuple" || T.baseType === "array" ? (i.push(ar.fromObject({
                type: "bytes32",
                name: T.name
            })), o.push(!0)) : (i.push(T), o.push(!1)) : (s.push(T), o.push(!1))
        });
        let f = n != null ? this._abiCoder.decode(i, io(n)) : null,
            l = this._abiCoder.decode(s, r, !0),
            d = [],
            p = 0,
            A = 0;
        e.inputs.forEach((T, N) => {
            if (T.indexed)
                if (f == null) d[N] = new Ed({
                    _isIndexed: !0,
                    hash: null
                });
                else if (o[N]) d[N] = new Ed({
                _isIndexed: !0,
                hash: f[A++]
            });
            else try {
                d[N] = f[A++]
            } catch (P) {
                d[N] = P
            } else try {
                d[N] = l[p++]
            } catch (P) {
                d[N] = P
            }
            if (T.name && d[T.name] == null) {
                const P = d[N];
                P instanceof Error ? Object.defineProperty(d, T.name, {
                    enumerable: !0,
                    get: () => {
                        throw Hb(`property ${JSON.stringify(T.name)}`, P)
                    }
                }) : d[T.name] = P
            }
        });
        for (let T = 0; T < d.length; T++) {
            const N = d[T];
            N instanceof Error && Object.defineProperty(d, T, {
                enumerable: !0,
                get: () => {
                    throw Hb(`index ${T}`, N)
                }
            })
        }
        return Object.freeze(d)
    }
    parseTransaction(e) {
        let r = this.getFunction(e.data.substring(0, 10).toLowerCase());
        return r ? new n9({
            args: this._abiCoder.decode(r.inputs, "0x" + e.data.substring(10)),
            functionFragment: r,
            name: r.name,
            signature: r.format(),
            sighash: this.getSighash(r),
            value: Ce.from(e.value || "0")
        }) : null
    }
    parseLog(e) {
        let r = this.getEvent(e.topics[0]);
        return !r || r.anonymous ? null : new r9({
            eventFragment: r,
            name: r.name,
            signature: r.format(),
            topic: this.getEventTopic(r),
            args: this.decodeEventLog(r, e.data, e.topics)
        })
    }
    parseError(e) {
        const r = nt(e);
        let n = this.getError(r.substring(0, 10).toLowerCase());
        return n ? new i9({
            args: this._abiCoder.decode(n.inputs, "0x" + r.substring(10)),
            errorFragment: n,
            name: n.name,
            signature: n.format(),
            sighash: this.getSighash(n)
        }) : null
    }
    static isInterface(e) {
        return !!(e && e._isInterface)
    }
}

function Ad(t, e) {
    if (e.length < t) throw new TypeError(t + " argument" + (t > 1 ? "s" : "") + " required, but only " + e.length + " present")
}

function Bl(t) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Bl = function(r) {
        return typeof r
    } : Bl = function(r) {
        return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
    }, Bl(t)
}

function o9(t) {
    Ad(1, arguments);
    var e = Object.prototype.toString.call(t);
    return t instanceof Date || Bl(t) === "object" && e === "[object Date]" ? new Date(t.getTime()) : typeof t == "number" || e === "[object Number]" ? new Date(t) : ((typeof t == "string" || e === "[object String]") && typeof console != "undefined" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN))
}

function a9(t) {
    Ad(1, arguments);
    var e = o9(t),
        r = e.getTime();
    return r
}

function qb(t) {
    return Ad(1, arguments), Math.floor(a9(t) / 1e3)
}

function jb(t) {
    return "0x" + Ha.keccak_256(ze(t))
}
const f9 = "logger/5.7.0";
let Wb = !1,
    Vb = !1;
const $l = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let Kb = $l.default,
    _d = null;

function u9() {
    try {
        const t = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
                try {
                    if ("test".normalize(e) !== "test") throw new Error("bad normalize")
                } catch {
                    t.push(e)
                }
            }), t.length) throw new Error("missing " + t.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
    } catch (t) {
        return t.message
    }
    return null
}
const Xb = u9();
var Td;
(function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF"
})(Td || (Td = {}));
var ii;
(function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED"
})(ii || (ii = {}));
const Jb = "0123456789abcdef";
class Ye {
    constructor(e) {
        Object.defineProperty(this, "version", {
            enumerable: !0,
            value: e,
            writable: !1
        })
    }
    _log(e, r) {
        const n = e.toLowerCase();
        $l[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(Kb > $l[n]) && console.log.apply(console, r)
    }
    debug(...e) {
        this._log(Ye.levels.DEBUG, e)
    }
    info(...e) {
        this._log(Ye.levels.INFO, e)
    }
    warn(...e) {
        this._log(Ye.levels.WARNING, e)
    }
    makeError(e, r, n) {
        if (Vb) return this.makeError("censored error", r, {});
        r || (r = Ye.errors.UNKNOWN_ERROR), n || (n = {});
        const i = [];
        Object.keys(n).forEach(l => {
            const d = n[l];
            try {
                if (d instanceof Uint8Array) {
                    let p = "";
                    for (let A = 0; A < d.length; A++) p += Jb[d[A] >> 4], p += Jb[d[A] & 15];
                    i.push(l + "=Uint8Array(0x" + p + ")")
                } else i.push(l + "=" + JSON.stringify(d))
            } catch {
                i.push(l + "=" + JSON.stringify(n[l].toString()))
            }
        }), i.push(`code=${r}`), i.push(`version=${this.version}`);
        const s = e;
        let o = "";
        switch (r) {
            case ii.NUMERIC_FAULT:
                {
                    o = "NUMERIC_FAULT";
                    const l = e;
                    switch (l) {
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            o += "-" + l;
                            break;
                        case "negative-power":
                        case "negative-width":
                            o += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            o += "-unbound-result";
                            break
                    }
                    break
                }
            case ii.CALL_EXCEPTION:
            case ii.INSUFFICIENT_FUNDS:
            case ii.MISSING_NEW:
            case ii.NONCE_EXPIRED:
            case ii.REPLACEMENT_UNDERPRICED:
            case ii.TRANSACTION_REPLACED:
            case ii.UNPREDICTABLE_GAS_LIMIT:
                o = r;
                break
        }
        o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
        const f = new Error(e);
        return f.reason = s, f.code = r, Object.keys(n).forEach(function(l) {
            f[l] = n[l]
        }), f
    }
    throwError(e, r, n) {
        throw this.makeError(e, r, n)
    }
    throwArgumentError(e, r, n) {
        return this.throwError(e, Ye.errors.INVALID_ARGUMENT, {
            argument: r,
            value: n
        })
    }
    assert(e, r, n, i) {
        e || this.throwError(r, n, i)
    }
    assertArgument(e, r, n, i) {
        e || this.throwArgumentError(r, n, i)
    }
    checkNormalize(e) {
        Xb && this.throwError("platform missing String.prototype.normalize", Ye.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: Xb
        })
    }
    checkSafeUint53(e, r) {
        typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Ye.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: e
        }), e % 1 && this.throwError(r, Ye.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: e
        }))
    }
    checkArgumentCount(e, r, n) {
        n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Ye.errors.MISSING_ARGUMENT, {
            count: e,
            expectedCount: r
        }), e > r && this.throwError("too many arguments" + n, Ye.errors.UNEXPECTED_ARGUMENT, {
            count: e,
            expectedCount: r
        })
    }
    checkNew(e, r) {
        (e === Object || e == null) && this.throwError("missing new", Ye.errors.MISSING_NEW, {
            name: r.name
        })
    }
    checkAbstract(e, r) {
        e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Ye.errors.UNSUPPORTED_OPERATION, {
            name: e.name,
            operation: "new"
        }) : (e === Object || e == null) && this.throwError("missing new", Ye.errors.MISSING_NEW, {
            name: r.name
        })
    }
    static globalLogger() {
        return _d || (_d = new Ye(f9)), _d
    }
    static setCensorship(e, r) {
        if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            }), Wb) {
            if (!e) return;
            this.globalLogger().throwError("error censorship permanent", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            })
        }
        Vb = !!e, Wb = !!r
    }
    static setLogLevel(e) {
        const r = $l[e.toLowerCase()];
        if (r == null) {
            Ye.globalLogger().warn("invalid log level - " + e);
            return
        }
        Kb = r
    }
    static from(e) {
        return new Ye(e)
    }
}
Ye.errors = ii;
Ye.levels = Td;
const l9 = "rlp/5.7.0",
    c9 = new Ye(l9);

function Zb(t) {
    const e = [];
    for (; t;) e.unshift(t & 255), t >>= 8;
    return e
}

function Yb(t) {
    if (Array.isArray(t)) {
        let n = [];
        if (t.forEach(function(s) {
                n = n.concat(Yb(s))
            }), n.length <= 55) return n.unshift(192 + n.length), n;
        const i = Zb(n.length);
        return i.unshift(247 + i.length), i.concat(n)
    }
    w1(t) || c9.throwArgumentError("RLP object must be BytesLike", "object", t);
    const e = Array.prototype.slice.call(ze(t));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const r = Zb(e.length);
    return r.unshift(183 + r.length), r.concat(e)
}

function h9(t) {
    return nt(Yb(t))
}
const d9 = "address/5.7.0",
    ha = new Ye(d9);

function Qb(t) {
    $t(t, 20) || ha.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""),
        r = new Uint8Array(40);
    for (let i = 0; i < 40; i++) r[i] = e[i].charCodeAt(0);
    const n = ze(jb(r));
    for (let i = 0; i < 40; i += 2) n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const p9 = 9007199254740991;

function m9(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10
}
const Md = {};
for (let t = 0; t < 10; t++) Md[String(t)] = String(t);
for (let t = 0; t < 26; t++) Md[String.fromCharCode(65 + t)] = String(10 + t);
const ev = Math.floor(m9(p9));

function y9(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(n => Md[n]).join("");
    for (; e.length >= ev;) {
        let n = e.substring(0, ev);
        e = parseInt(n, 10) % 97 + e.substring(n.length)
    }
    let r = String(98 - parseInt(e, 10) % 97);
    for (; r.length < 2;) r = "0" + r;
    return r
}

function da(t) {
    let e = null;
    if (typeof t != "string" && ha.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = Qb(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && ha.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (t.substring(2, 4) !== y9(t) && ha.throwArgumentError("bad icap checksum", "address", t), e = yl(t.substring(4)); e.length < 40;) e = "0" + e;
        e = Qb("0x" + e)
    } else ha.throwArgumentError("invalid address", "address", t);
    return e
}

function g9(t) {
    let e = null;
    try {
        e = da(t.from)
    } catch {
        ha.throwArgumentError("missing from address", "transaction", t)
    }
    const r = K_(ze(Ce.from(t.nonce).toHexString()));
    return da(Ir(jb(h9([e, r])), 12))
}
const x9 = "properties/5.7.0";
var b9 = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const tv = new Ye(x9);

function tt(t, e, r) {
    Object.defineProperty(t, e, {
        enumerable: !0,
        value: r,
        writable: !1
    })
}

function v9(t, e) {
    for (let r = 0; r < 32; r++) {
        if (t[e]) return t[e];
        if (!t.prototype || typeof t.prototype != "object") break;
        t = Object.getPrototypeOf(t.prototype).constructor
    }
    return null
}

function Gl(t) {
    return b9(this, void 0, void 0, function*() {
        const e = Object.keys(t).map(n => {
            const i = t[n];
            return Promise.resolve(i).then(s => ({
                key: n,
                value: s
            }))
        });
        return (yield Promise.all(e)).reduce((n, i) => (n[i.key] = i.value, n), {})
    })
}

function Ef(t) {
    const e = {};
    for (const r in t) e[r] = t[r];
    return e
}
const w9 = {
    bigint: !0,
    boolean: !0,
    function: !0,
    number: !0,
    string: !0
};

function rv(t) {
    if (t == null || w9[typeof t]) return !0;
    if (Array.isArray(t) || typeof t == "object") {
        if (!Object.isFrozen(t)) return !1;
        const e = Object.keys(t);
        for (let r = 0; r < e.length; r++) {
            let n = null;
            try {
                n = t[e[r]]
            } catch {
                continue
            }
            if (!rv(n)) return !1
        }
        return !0
    }
    return tv.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function E9(t) {
    if (rv(t)) return t;
    if (Array.isArray(t)) return Object.freeze(t.map(e => zl(e)));
    if (typeof t == "object") {
        const e = {};
        for (const r in t) {
            const n = t[r];
            n !== void 0 && tt(e, r, zl(n))
        }
        return e
    }
    return tv.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t)
}

function zl(t) {
    return E9(t)
}
const A9 = "abstract-provider/5.7.0";
var _9 = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const T9 = new Ye(A9);
class Nd {
    constructor() {
        T9.checkAbstract(new.target, Nd), tt(this, "_isProvider", !0)
    }
    getFeeData() {
        return _9(this, void 0, void 0, function*() {
            const {
                block: e,
                gasPrice: r
            } = yield Gl({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch(o => null)
            });
            let n = null,
                i = null,
                s = null;
            return e && e.baseFeePerGas && (n = e.baseFeePerGas, s = Ce.from("1500000000"), i = e.baseFeePerGas.mul(2).add(s)), {
                lastBaseFeePerGas: n,
                maxFeePerGas: i,
                maxPriorityFeePerGas: s,
                gasPrice: r
            }
        })
    }
    addListener(e, r) {
        return this.on(e, r)
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
    static isProvider(e) {
        return !!(e && e._isProvider)
    }
}
const M9 = "transactions/5.7.0",
    nv = new Ye(M9);
var iv;
(function(t) {
    t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559"
})(iv || (iv = {}));

function Sd(t, e) {
    return {
        address: da(t),
        storageKeys: (e || []).map((r, n) => (hl(r) !== 32 && nv.throwArgumentError("invalid access list storageKey", `accessList[${t}:${n}]`, r), r.toLowerCase()))
    }
}

function N9(t) {
    if (Array.isArray(t)) return t.map((r, n) => Array.isArray(r) ? (r.length > 2 && nv.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${n}]`, r), Sd(r[0], r[1])) : Sd(r.address, r.storageKeys));
    const e = Object.keys(t).map(r => {
        const n = t[r].reduce((i, s) => (i[s] = !0, i), {});
        return Sd(r, Object.keys(n).sort())
    });
    return e.sort((r, n) => r.address.localeCompare(n.address)), e
}
const S9 = "contracts/5.7.0";
var fo = globalThis && globalThis.__awaiter || function(t, e, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function f(p) {
            try {
                d(n.next(p))
            } catch (A) {
                o(A)
            }
        }

        function l(p) {
            try {
                d(n.throw(p))
            } catch (A) {
                o(A)
            }
        }

        function d(p) {
            p.done ? s(p.value) : i(p.value).then(f, l)
        }
        d((n = n.apply(t, e || [])).next())
    })
};
const jt = new Ye(S9);

function Hl(t, e) {
    return fo(this, void 0, void 0, function*() {
        const r = yield e;
        typeof r != "string" && jt.throwArgumentError("invalid address or ENS name", "name", r);
        try {
            return da(r)
        } catch {}
        t || jt.throwError("a provider or signer is needed to resolve ENS names", Ye.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName"
        });
        const n = yield t.resolveName(r);
        return n == null && jt.throwArgumentError("resolver or addr is not configured for ENS name", "name", r), n
    })
}

function ql(t, e, r) {
    return fo(this, void 0, void 0, function*() {
        return Array.isArray(r) ? yield Promise.all(r.map((n, i) => ql(t, Array.isArray(e) ? e[i] : e[n.name], n))): r.type === "address" ? yield Hl(t, e): r.type === "tuple" ? yield ql(t, e, r.components): r.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map(n => ql(t, n, r.arrayChildren))): Promise.reject(jt.makeError("invalid value for array", Ye.errors.INVALID_ARGUMENT, {
            argument: "value",
            value: e
        })): e
    })
}

function jl(t, e, r) {
    return fo(this, void 0, void 0, function*() {
        let n = {};
        r.length === e.inputs.length + 1 && typeof r[r.length - 1] == "object" && (n = Ef(r.pop())), jt.checkArgumentCount(r.length, e.inputs.length, "passed to contract"), t.signer ? n.from ? n.from = Gl({
            override: Hl(t.signer, n.from),
            signer: t.signer.getAddress()
        }).then(d => fo(this, void 0, void 0, function*() {
            return da(d.signer) !== d.override && jt.throwError("Contract with a Signer cannot override from", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.from"
            }), d.override
        })) : n.from = t.signer.getAddress() : n.from && (n.from = Hl(t.provider, n.from));
        const i = yield Gl({
            args: ql(t.signer || t.provider, r, e.inputs),
            address: t.resolvedAddress,
            overrides: Gl(n) || {}
        }), s = t.interface.encodeFunctionData(e, i.args), o = {
            data: s,
            to: i.address
        }, f = i.overrides;
        if (f.nonce != null && (o.nonce = Ce.from(f.nonce).toNumber()), f.gasLimit != null && (o.gasLimit = Ce.from(f.gasLimit)), f.gasPrice != null && (o.gasPrice = Ce.from(f.gasPrice)), f.maxFeePerGas != null && (o.maxFeePerGas = Ce.from(f.maxFeePerGas)), f.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = Ce.from(f.maxPriorityFeePerGas)), f.from != null && (o.from = f.from), f.type != null && (o.type = f.type), f.accessList != null && (o.accessList = N9(f.accessList)), o.gasLimit == null && e.gas != null) {
            let d = 21e3;
            const p = ze(s);
            for (let A = 0; A < p.length; A++) d += 4, p[A] && (d += 64);
            o.gasLimit = Ce.from(e.gas).add(d)
        }
        if (f.value) {
            const d = Ce.from(f.value);
            !d.isZero() && !e.payable && jt.throwError("non-payable method cannot override value", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: n.value
            }), o.value = d
        }
        f.customData && (o.customData = Ef(f.customData)), f.ccipReadEnabled && (o.ccipReadEnabled = !!f.ccipReadEnabled), delete n.nonce, delete n.gasLimit, delete n.gasPrice, delete n.from, delete n.value, delete n.type, delete n.accessList, delete n.maxFeePerGas, delete n.maxPriorityFeePerGas, delete n.customData, delete n.ccipReadEnabled;
        const l = Object.keys(n).filter(d => n[d] != null);
        return l.length && jt.throwError(`cannot override ${l.map(d=>JSON.stringify(d)).join(",")}`, Ye.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides",
            overrides: l
        }), o
    })
}

function P9(t, e) {
    return function(...r) {
        return jl(t, e, r)
    }
}

function I9(t, e) {
    const r = t.signer || t.provider;
    return function(...n) {
        return fo(this, void 0, void 0, function*() {
            r || jt.throwError("estimate require a provider or signer", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "estimateGas"
            });
            const i = yield jl(t, e, n);
            return yield r.estimateGas(i)
        })
    }
}

function R9(t, e) {
    const r = e.wait.bind(e);
    e.wait = n => r(n).then(i => (i.events = i.logs.map(s => {
        let o = zl(s),
            f = null;
        try {
            f = t.interface.parseLog(s)
        } catch {}
        return f && (o.args = f.args, o.decode = (l, d) => t.interface.decodeEventLog(f.eventFragment, l, d), o.event = f.name, o.eventSignature = f.signature), o.removeListener = () => t.provider, o.getBlock = () => t.provider.getBlock(i.blockHash), o.getTransaction = () => t.provider.getTransaction(i.transactionHash), o.getTransactionReceipt = () => Promise.resolve(i), o
    }), i))
}

function sv(t, e, r) {
    const n = t.signer || t.provider;
    return function(...i) {
        return fo(this, void 0, void 0, function*() {
            let s;
            if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
                const l = Ef(i.pop());
                l.blockTag != null && (s = yield l.blockTag), delete l.blockTag, i.push(l)
            }
            t.deployTransaction != null && (yield t._deployed(s));
            const o = yield jl(t, e, i), f = yield n.call(o, s);
            try {
                let l = t.interface.decodeFunctionResult(e, f);
                return r && e.outputs.length === 1 && (l = l[0]), l
            } catch (l) {
                throw l.code === Ye.errors.CALL_EXCEPTION && (l.address = t.address, l.args = i, l.transaction = o), l
            }
        })
    }
}

function k9(t, e) {
    return function(...r) {
        return fo(this, void 0, void 0, function*() {
            t.signer || jt.throwError("sending a transaction requires a signer", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "sendTransaction"
            }), t.deployTransaction != null && (yield t._deployed());
            const n = yield jl(t, e, r), i = yield t.signer.sendTransaction(n);
            return R9(t, i), i
        })
    }
}

function ov(t, e, r) {
    return e.constant ? sv(t, e, r) : k9(t, e)
}

function av(t) {
    return t.address && (t.topics == null || t.topics.length === 0) ? "*" : (t.address || "*") + "@" + (t.topics ? t.topics.map(e => Array.isArray(e) ? e.join("|") : e).join(":") : "")
}
class Af {
    constructor(e, r) {
        tt(this, "tag", e), tt(this, "filter", r), this._listeners = []
    }
    addListener(e, r) {
        this._listeners.push({
            listener: e,
            once: r
        })
    }
    removeListener(e) {
        let r = !1;
        this._listeners = this._listeners.filter(n => r || n.listener !== e ? !0 : (r = !0, !1))
    }
    removeAllListeners() {
        this._listeners = []
    }
    listeners() {
        return this._listeners.map(e => e.listener)
    }
    listenerCount() {
        return this._listeners.length
    }
    run(e) {
        const r = this.listenerCount();
        return this._listeners = this._listeners.filter(n => {
            const i = e.slice();
            return setTimeout(() => {
                n.listener.apply(this, i)
            }, 0), !n.once
        }), r
    }
    prepareEvent(e) {}
    getEmit(e) {
        return [e]
    }
}
class O9 extends Af {
    constructor() {
        super("error", null)
    }
}
class fv extends Af {
    constructor(e, r, n, i) {
        const s = {
            address: e
        };
        let o = r.getEventTopic(n);
        i ? (o !== i[0] && jt.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [o];
        super(av(s), s);
        tt(this, "address", e), tt(this, "interface", r), tt(this, "fragment", n)
    }
    prepareEvent(e) {
        super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (r, n) => this.interface.decodeEventLog(this.fragment, r, n);
        try {
            e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics)
        } catch (r) {
            e.args = null, e.decodeError = r
        }
    }
    getEmit(e) {
        const r = N7(e.args);
        if (r.length) throw r[0].error;
        const n = (e.args || []).slice();
        return n.push(e), n
    }
}
class uv extends Af {
    constructor(e, r) {
        super("*", {
            address: e
        });
        tt(this, "address", e), tt(this, "interface", r)
    }
    prepareEvent(e) {
        super.prepareEvent(e);
        try {
            const r = this.interface.parseLog(e);
            e.event = r.name, e.eventSignature = r.signature, e.decode = (n, i) => this.interface.decodeEventLog(r.eventFragment, n, i), e.args = r.args
        } catch {}
    }
}
class C9 {
    constructor(e, r, n) {
        tt(this, "interface", v9(new.target, "getInterface")(r)), n == null ? (tt(this, "provider", null), tt(this, "signer", null)) : vl.isSigner(n) ? (tt(this, "provider", n.provider || null), tt(this, "signer", n)) : Nd.isProvider(n) ? (tt(this, "provider", n), tt(this, "signer", null)) : jt.throwArgumentError("invalid signer or provider", "signerOrProvider", n), tt(this, "callStatic", {}), tt(this, "estimateGas", {}), tt(this, "functions", {}), tt(this, "populateTransaction", {}), tt(this, "filters", {}); {
            const o = {};
            Object.keys(this.interface.events).forEach(f => {
                const l = this.interface.events[f];
                tt(this.filters, f, (...d) => ({
                    address: this.address,
                    topics: this.interface.encodeFilterTopics(l, d)
                })), o[l.name] || (o[l.name] = []), o[l.name].push(f)
            }), Object.keys(o).forEach(f => {
                const l = o[f];
                l.length === 1 ? tt(this.filters, f, this.filters[l[0]]) : jt.warn(`Duplicate definition of ${f} (${l.join(", ")})`)
            })
        }
        if (tt(this, "_runningEvents", {}), tt(this, "_wrappedEmits", {}), e == null && jt.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), tt(this, "address", e), this.provider) tt(this, "resolvedAddress", Hl(this.provider, e));
        else try {
            tt(this, "resolvedAddress", Promise.resolve(da(e)))
        } catch {
            jt.throwError("provider is required to use ENS name as contract address", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "new Contract"
            })
        }
        this.resolvedAddress.catch(o => {});
        const i = {},
            s = {};
        Object.keys(this.interface.functions).forEach(o => {
            const f = this.interface.functions[o];
            if (s[o]) {
                jt.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`);
                return
            }
            s[o] = !0; {
                const l = f.name;
                i[`%${l}`] || (i[`%${l}`] = []), i[`%${l}`].push(o)
            }
            this[o] == null && tt(this, o, ov(this, f, !0)), this.functions[o] == null && tt(this.functions, o, ov(this, f, !1)), this.callStatic[o] == null && tt(this.callStatic, o, sv(this, f, !0)), this.populateTransaction[o] == null && tt(this.populateTransaction, o, P9(this, f)), this.estimateGas[o] == null && tt(this.estimateGas, o, I9(this, f))
        }), Object.keys(i).forEach(o => {
            const f = i[o];
            if (f.length > 1) return;
            o = o.substring(1);
            const l = f[0];
            try {
                this[o] == null && tt(this, o, this[l])
            } catch {}
            this.functions[o] == null && tt(this.functions, o, this.functions[l]), this.callStatic[o] == null && tt(this.callStatic, o, this.callStatic[l]), this.populateTransaction[o] == null && tt(this.populateTransaction, o, this.populateTransaction[l]), this.estimateGas[o] == null && tt(this.estimateGas, o, this.estimateGas[l])
        })
    }
    static getContractAddress(e) {
        return g9(e)
    }
    static getInterface(e) {
        return Ps.isInterface(e) ? e : new Ps(e)
    }
    deployed() {
        return this._deployed()
    }
    _deployed(e) {
        return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, e).then(r => (r === "0x" && jt.throwError("contract not deployed", Ye.errors.UNSUPPORTED_OPERATION, {
            contractAddress: this.address,
            operation: "getDeployed"
        }), this))), this._deployedPromise
    }
    fallback(e) {
        this.signer || jt.throwError("sending a transactions require a signer", Ye.errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction(fallback)"
        });
        const r = Ef(e || {});
        return ["from", "to"].forEach(function(n) {
            r[n] != null && jt.throwError("cannot override " + n, Ye.errors.UNSUPPORTED_OPERATION, {
                operation: n
            })
        }), r.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(r))
    }
    connect(e) {
        typeof e == "string" && (e = new Yh(e, this.provider));
        const r = new this.constructor(this.address, this.interface, e);
        return this.deployTransaction && tt(r, "deployTransaction", this.deployTransaction), r
    }
    attach(e) {
        return new this.constructor(e, this.interface, this.signer || this.provider)
    }
    static isIndexed(e) {
        return Ed.isIndexed(e)
    }
    _normalizeRunningEvent(e) {
        return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e
    }
    _getRunningEvent(e) {
        if (typeof e == "string") {
            if (e === "error") return this._normalizeRunningEvent(new O9);
            if (e === "event") return this._normalizeRunningEvent(new Af("event", null));
            if (e === "*") return this._normalizeRunningEvent(new uv(this.address, this.interface));
            const r = this.interface.getEvent(e);
            return this._normalizeRunningEvent(new fv(this.address, this.interface, r))
        }
        if (e.topics && e.topics.length > 0) {
            try {
                const n = e.topics[0];
                if (typeof n != "string") throw new Error("invalid topic");
                const i = this.interface.getEvent(n);
                return this._normalizeRunningEvent(new fv(this.address, this.interface, i, e.topics))
            } catch {}
            const r = {
                address: this.address,
                topics: e.topics
            };
            return this._normalizeRunningEvent(new Af(av(r), r))
        }
        return this._normalizeRunningEvent(new uv(this.address, this.interface))
    }
    _checkRunningEvents(e) {
        if (e.listenerCount() === 0) {
            delete this._runningEvents[e.tag];
            const r = this._wrappedEmits[e.tag];
            r && e.filter && (this.provider.off(e.filter, r), delete this._wrappedEmits[e.tag])
        }
    }
    _wrapEvent(e, r, n) {
        const i = zl(r);
        return i.removeListener = () => {
            !n || (e.removeListener(n), this._checkRunningEvents(e))
        }, i.getBlock = () => this.provider.getBlock(r.blockHash), i.getTransaction = () => this.provider.getTransaction(r.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(r.transactionHash), e.prepareEvent(i), i
    }
    _addEventListener(e, r, n) {
        if (this.provider || jt.throwError("events require a provider or a signer with a provider", Ye.errors.UNSUPPORTED_OPERATION, {
                operation: "once"
            }), e.addListener(r, n), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
            const i = s => {
                let o = this._wrapEvent(e, s, r);
                if (o.decodeError == null) try {
                    const f = e.getEmit(o);
                    this.emit(e.filter, ...f)
                } catch (f) {
                    o.decodeError = f.error
                }
                e.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o)
            };
            this._wrappedEmits[e.tag] = i, e.filter != null && this.provider.on(e.filter, i)
        }
    }
    queryFilter(e, r, n) {
        const i = this._getRunningEvent(e),
            s = Ef(i.filter);
        return typeof r == "string" && $t(r, 32) ? (n != null && jt.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", n), s.blockHash = r) : (s.fromBlock = r != null ? r : 0, s.toBlock = n != null ? n : "latest"), this.provider.getLogs(s).then(o => o.map(f => this._wrapEvent(i, f, null)))
    }
    on(e, r) {
        return this._addEventListener(this._getRunningEvent(e), r, !1), this
    }
    once(e, r) {
        return this._addEventListener(this._getRunningEvent(e), r, !0), this
    }
    emit(e, ...r) {
        if (!this.provider) return !1;
        const n = this._getRunningEvent(e),
            i = n.run(r) > 0;
        return this._checkRunningEvents(n), i
    }
    listenerCount(e) {
        return this.provider ? e == null ? Object.keys(this._runningEvents).reduce((r, n) => r + this._runningEvents[n].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0
    }
    listeners(e) {
        if (!this.provider) return [];
        if (e == null) {
            const r = [];
            for (let n in this._runningEvents) this._runningEvents[n].listeners().forEach(i => {
                r.push(i)
            });
            return r
        }
        return this._getRunningEvent(e).listeners()
    }
    removeAllListeners(e) {
        if (!this.provider) return this;
        if (e == null) {
            for (const n in this._runningEvents) {
                const i = this._runningEvents[n];
                i.removeAllListeners(), this._checkRunningEvents(i)
            }
            return this
        }
        const r = this._getRunningEvent(e);
        return r.removeAllListeners(), this._checkRunningEvents(r), this
    }
    off(e, r) {
        if (!this.provider) return this;
        const n = this._getRunningEvent(e);
        return n.removeListener(r), this._checkRunningEvents(n), this
    }
    removeListener(e, r) {
        return this.off(e, r)
    }
}
class _f extends C9 {}
const F9 = "ethers/5.7.2";
new Ye(F9);

function D9(t, e) {
    return e = e || {}, new Promise(function(r, n) {
        var i = new XMLHttpRequest,
            s = [],
            o = [],
            f = {},
            l = function() {
                return {
                    ok: (i.status / 100 | 0) == 2,
                    statusText: i.statusText,
                    status: i.status,
                    url: i.responseURL,
                    text: function() {
                        return Promise.resolve(i.responseText)
                    },
                    json: function() {
                        return Promise.resolve(i.responseText).then(JSON.parse)
                    },
                    blob: function() {
                        return Promise.resolve(new Blob([i.response]))
                    },
                    clone: l,
                    headers: {
                        keys: function() {
                            return s
                        },
                        entries: function() {
                            return o
                        },
                        get: function(p) {
                            return f[p.toLowerCase()]
                        },
                        has: function(p) {
                            return p.toLowerCase() in f
                        }
                    }
                }
            };
        for (var d in i.open(e.method || "get", t, !0), i.onload = function() {
                i.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(p, A, T) {
                    s.push(A = A.toLowerCase()), o.push([A, T]), f[A] = f[A] ? f[A] + "," + T : T
                }), r(l())
            }, i.onerror = n, i.withCredentials = e.credentials == "include", e.headers) i.setRequestHeader(d, e.headers[d]);
        i.send(e.body || null)
    })
}
var U9 = Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: "Module",
        default: D9
    }),
    lv = V3(U9);
self.fetch || (self.fetch = lv.default || lv);
var L9 = {},
    B9 = t => encodeURIComponent(t).replace(/[!'()*]/g, e => `%${e.charCodeAt(0).toString(16).toUpperCase()}`),
    cv = "%[a-f0-9]{2}",
    hv = new RegExp(cv, "gi"),
    dv = new RegExp("(" + cv + ")+", "gi");

function Pd(t, e) {
    try {
        return decodeURIComponent(t.join(""))
    } catch {}
    if (t.length === 1) return t;
    e = e || 1;
    var r = t.slice(0, e),
        n = t.slice(e);
    return Array.prototype.concat.call([], Pd(r), Pd(n))
}

function $9(t) {
    try {
        return decodeURIComponent(t)
    } catch {
        for (var e = t.match(hv), r = 1; r < e.length; r++) t = Pd(e, r).join(""), e = t.match(hv);
        return t
    }
}

function G9(t) {
    for (var e = {
            "%FE%FF": "\uFFFD\uFFFD",
            "%FF%FE": "\uFFFD\uFFFD"
        }, r = dv.exec(t); r;) {
        try {
            e[r[0]] = decodeURIComponent(r[0])
        } catch {
            var n = $9(r[0]);
            n !== r[0] && (e[r[0]] = n)
        }
        r = dv.exec(t)
    }
    e["%C2"] = "\uFFFD";
    for (var i = Object.keys(e), s = 0; s < i.length; s++) {
        var o = i[s];
        t = t.replace(new RegExp(o, "g"), e[o])
    }
    return t
}
var z9 = function(t) {
        if (typeof t != "string") throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
        try {
            return t = t.replace(/\+/g, " "), decodeURIComponent(t)
        } catch {
            return G9(t)
        }
    },
    H9 = (t, e) => {
        if (!(typeof t == "string" && typeof e == "string")) throw new TypeError("Expected the arguments to be of type `string`");
        if (e === "") return [t];
        const r = t.indexOf(e);
        return r === -1 ? [t] : [t.slice(0, r), t.slice(r + e.length)]
    },
    q9 = function(t, e) {
        for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
            var o = n[s],
                f = t[o];
            (i ? e.indexOf(o) !== -1 : e(o, f, t)) && (r[o] = f)
        }
        return r
    };
(function(t) {
    const e = B9,
        r = z9,
        n = H9,
        i = q9,
        s = I => I == null,
        o = Symbol("encodeFragmentIdentifier");

    function f(I) {
        switch (I.arrayFormat) {
            case "index":
                return U => (M, F) => {
                    const D = M.length;
                    return F === void 0 || I.skipNull && F === null || I.skipEmptyString && F === "" ? M : F === null ? [...M, [p(U, I), "[", D, "]"].join("")] : [...M, [p(U, I), "[", p(D, I), "]=", p(F, I)].join("")]
                };
            case "bracket":
                return U => (M, F) => F === void 0 || I.skipNull && F === null || I.skipEmptyString && F === "" ? M : F === null ? [...M, [p(U, I), "[]"].join("")] : [...M, [p(U, I), "[]=", p(F, I)].join("")];
            case "colon-list-separator":
                return U => (M, F) => F === void 0 || I.skipNull && F === null || I.skipEmptyString && F === "" ? M : F === null ? [...M, [p(U, I), ":list="].join("")] : [...M, [p(U, I), ":list=", p(F, I)].join("")];
            case "comma":
            case "separator":
            case "bracket-separator":
                {
                    const U = I.arrayFormat === "bracket-separator" ? "[]=" : "=";
                    return M => (F, D) => D === void 0 || I.skipNull && D === null || I.skipEmptyString && D === "" ? F : (D = D === null ? "" : D, F.length === 0 ? [
                        [p(M, I), U, p(D, I)].join("")
                    ] : [
                        [F, p(D, I)].join(I.arrayFormatSeparator)
                    ])
                }
            default:
                return U => (M, F) => F === void 0 || I.skipNull && F === null || I.skipEmptyString && F === "" ? M : F === null ? [...M, p(U, I)] : [...M, [p(U, I), "=", p(F, I)].join("")]
        }
    }

    function l(I) {
        let U;
        switch (I.arrayFormat) {
            case "index":
                return (M, F, D) => {
                    if (U = /\[(\d*)\]$/.exec(M), M = M.replace(/\[\d*\]$/, ""), !U) {
                        D[M] = F;
                        return
                    }
                    D[M] === void 0 && (D[M] = {}), D[M][U[1]] = F
                };
            case "bracket":
                return (M, F, D) => {
                    if (U = /(\[\])$/.exec(M), M = M.replace(/\[\]$/, ""), !U) {
                        D[M] = F;
                        return
                    }
                    if (D[M] === void 0) {
                        D[M] = [F];
                        return
                    }
                    D[M] = [].concat(D[M], F)
                };
            case "colon-list-separator":
                return (M, F, D) => {
                    if (U = /(:list)$/.exec(M), M = M.replace(/:list$/, ""), !U) {
                        D[M] = F;
                        return
                    }
                    if (D[M] === void 0) {
                        D[M] = [F];
                        return
                    }
                    D[M] = [].concat(D[M], F)
                };
            case "comma":
            case "separator":
                return (M, F, D) => {
                    const q = typeof F == "string" && F.includes(I.arrayFormatSeparator),
                        V = typeof F == "string" && !q && A(F, I).includes(I.arrayFormatSeparator);
                    F = V ? A(F, I) : F;
                    const Q = q || V ? F.split(I.arrayFormatSeparator).map(ce => A(ce, I)) : F === null ? F : A(F, I);
                    D[M] = Q
                };
            case "bracket-separator":
                return (M, F, D) => {
                    const q = /(\[\])$/.test(M);
                    if (M = M.replace(/\[\]$/, ""), !q) {
                        D[M] = F && A(F, I);
                        return
                    }
                    const V = F === null ? [] : F.split(I.arrayFormatSeparator).map(Q => A(Q, I));
                    if (D[M] === void 0) {
                        D[M] = V;
                        return
                    }
                    D[M] = [].concat(D[M], V)
                };
            default:
                return (M, F, D) => {
                    if (D[M] === void 0) {
                        D[M] = F;
                        return
                    }
                    D[M] = [].concat(D[M], F)
                }
        }
    }

    function d(I) {
        if (typeof I != "string" || I.length !== 1) throw new TypeError("arrayFormatSeparator must be single character string")
    }

    function p(I, U) {
        return U.encode ? U.strict ? e(I) : encodeURIComponent(I) : I
    }

    function A(I, U) {
        return U.decode ? r(I) : I
    }

    function T(I) {
        return Array.isArray(I) ? I.sort() : typeof I == "object" ? T(Object.keys(I)).sort((U, M) => Number(U) - Number(M)).map(U => I[U]) : I
    }

    function N(I) {
        const U = I.indexOf("#");
        return U !== -1 && (I = I.slice(0, U)), I
    }

    function P(I) {
        let U = "";
        const M = I.indexOf("#");
        return M !== -1 && (U = I.slice(M)), U
    }

    function C(I) {
        I = N(I);
        const U = I.indexOf("?");
        return U === -1 ? "" : I.slice(U + 1)
    }

    function S(I, U) {
        return U.parseNumbers && !Number.isNaN(Number(I)) && typeof I == "string" && I.trim() !== "" ? I = Number(I) : U.parseBooleans && I !== null && (I.toLowerCase() === "true" || I.toLowerCase() === "false") && (I = I.toLowerCase() === "true"), I
    }

    function k(I, U) {
        U = Object.assign({
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1
        }, U), d(U.arrayFormatSeparator);
        const M = l(U),
            F = Object.create(null);
        if (typeof I != "string" || (I = I.trim().replace(/^[?#&]/, ""), !I)) return F;
        for (const D of I.split("&")) {
            if (D === "") continue;
            let [q, V] = n(U.decode ? D.replace(/\+/g, " ") : D, "=");
            V = V === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(U.arrayFormat) ? V : A(V, U), M(A(q, U), V, F)
        }
        for (const D of Object.keys(F)) {
            const q = F[D];
            if (typeof q == "object" && q !== null)
                for (const V of Object.keys(q)) q[V] = S(q[V], U);
            else F[D] = S(q, U)
        }
        return U.sort === !1 ? F : (U.sort === !0 ? Object.keys(F).sort() : Object.keys(F).sort(U.sort)).reduce((D, q) => {
            const V = F[q];
            return Boolean(V) && typeof V == "object" && !Array.isArray(V) ? D[q] = T(V) : D[q] = V, D
        }, Object.create(null))
    }
    t.extract = C, t.parse = k, t.stringify = (I, U) => {
        if (!I) return "";
        U = Object.assign({
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ","
        }, U), d(U.arrayFormatSeparator);
        const M = V => U.skipNull && s(I[V]) || U.skipEmptyString && I[V] === "",
            F = f(U),
            D = {};
        for (const V of Object.keys(I)) M(V) || (D[V] = I[V]);
        const q = Object.keys(D);
        return U.sort !== !1 && q.sort(U.sort), q.map(V => {
            const Q = I[V];
            return Q === void 0 ? "" : Q === null ? p(V, U) : Array.isArray(Q) ? Q.length === 0 && U.arrayFormat === "bracket-separator" ? p(V, U) + "[]" : Q.reduce(F(V), []).join("&") : p(V, U) + "=" + p(Q, U)
        }).filter(V => V.length > 0).join("&")
    }, t.parseUrl = (I, U) => {
        U = Object.assign({
            decode: !0
        }, U);
        const [M, F] = n(I, "#");
        return Object.assign({
            url: M.split("?")[0] || "",
            query: k(C(I), U)
        }, U && U.parseFragmentIdentifier && F ? {
            fragmentIdentifier: A(F, U)
        } : {})
    }, t.stringifyUrl = (I, U) => {
        U = Object.assign({
            encode: !0,
            strict: !0,
            [o]: !0
        }, U);
        const M = N(I.url).split("?")[0] || "",
            F = t.extract(I.url),
            D = t.parse(F, {
                sort: !1
            }),
            q = Object.assign(D, I.query);
        let V = t.stringify(q, U);
        V && (V = `?${V}`);
        let Q = P(I.url);
        return I.fragmentIdentifier && (Q = `#${U[o]?p(I.fragmentIdentifier,U):I.fragmentIdentifier}`), `${M}${V}${Q}`
    }, t.pick = (I, U, M) => {
        M = Object.assign({
            parseFragmentIdentifier: !0,
            [o]: !1
        }, M);
        const {
            url: F,
            query: D,
            fragmentIdentifier: q
        } = t.parseUrl(I, M);
        return t.stringifyUrl({
            url: F,
            query: i(D, U),
            fragmentIdentifier: q
        }, M)
    }, t.exclude = (I, U, M) => {
        const F = Array.isArray(U) ? D => !U.includes(D) : (D, q) => !U(D, q);
        return t.pick(I, F, M)
    }
})(L9);

function pv(t, e, r, n, i, s, o) {
    try {
        var f = t[s](o),
            l = f.value
    } catch (d) {
        r(d);
        return
    }
    f.done ? e(l) : Promise.resolve(l).then(n, i)
}

function Wt(t) {
    return function() {
        var e = this,
            r = arguments;
        return new Promise(function(n, i) {
            var s = t.apply(e, r);

            function o(l) {
                pv(s, n, i, o, f, "next", l)
            }

            function f(l) {
                pv(s, n, i, o, f, "throw", l)
            }
            o(void 0)
        })
    }
}

function en() {
    return en = Object.assign || function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }, en.apply(this, arguments)
}

function Id(t, e) {
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Tf(t, e)
}

function Rd(t) {
    return Rd = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r)
    }, Rd(t)
}

function Tf(t, e) {
    return Tf = Object.setPrototypeOf || function(n, i) {
        return n.__proto__ = i, n
    }, Tf(t, e)
}

function j9() {
    if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
    } catch {
        return !1
    }
}

function Wl(t, e, r) {
    return j9() ? Wl = Reflect.construct : Wl = function(i, s, o) {
        var f = [null];
        f.push.apply(f, s);
        var l = Function.bind.apply(i, f),
            d = new l;
        return o && Tf(d, o.prototype), d
    }, Wl.apply(null, arguments)
}

function W9(t) {
    return Function.toString.call(t).indexOf("[native code]") !== -1
}

function kd(t) {
    var e = typeof Map == "function" ? new Map : void 0;
    return kd = function(n) {
        if (n === null || !W9(n)) return n;
        if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof e != "undefined") {
            if (e.has(n)) return e.get(n);
            e.set(n, i)
        }

        function i() {
            return Wl(n, arguments, Rd(this).constructor)
        }
        return i.prototype = Object.create(n.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), Tf(i, n)
    }, kd(t)
}

function V9(t) {
    if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t
}

function K9(t, e) {
    return e = {
        exports: {}
    }, t(e, e.exports), e.exports
}
var Je = K9(function(t) {
        var e = function(r) {
            var n = Object.prototype,
                i = n.hasOwnProperty,
                s, o = typeof Symbol == "function" ? Symbol : {},
                f = o.iterator || "@@iterator",
                l = o.asyncIterator || "@@asyncIterator",
                d = o.toStringTag || "@@toStringTag";

            function p(x, b, y) {
                return Object.defineProperty(x, b, {
                    value: y,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), x[b]
            }
            try {
                p({}, "")
            } catch {
                p = function(b, y, h) {
                    return b[y] = h
                }
            }

            function A(x, b, y, h) {
                var u = b && b.prototype instanceof I ? b : I,
                    _ = Object.create(u.prototype),
                    L = new c(h || []);
                return _._invoke = O(x, y, L), _
            }
            r.wrap = A;

            function T(x, b, y) {
                try {
                    return {
                        type: "normal",
                        arg: x.call(b, y)
                    }
                } catch (h) {
                    return {
                        type: "throw",
                        arg: h
                    }
                }
            }
            var N = "suspendedStart",
                P = "suspendedYield",
                C = "executing",
                S = "completed",
                k = {};

            function I() {}

            function U() {}

            function M() {}
            var F = {};
            p(F, f, function() {
                return this
            });
            var D = Object.getPrototypeOf,
                q = D && D(D(g([])));
            q && q !== n && i.call(q, f) && (F = q);
            var V = M.prototype = I.prototype = Object.create(F);
            U.prototype = M, p(V, "constructor", M), p(M, "constructor", U), U.displayName = p(M, d, "GeneratorFunction");

            function Q(x) {
                ["next", "throw", "return"].forEach(function(b) {
                    p(x, b, function(y) {
                        return this._invoke(b, y)
                    })
                })
            }
            r.isGeneratorFunction = function(x) {
                var b = typeof x == "function" && x.constructor;
                return b ? b === U || (b.displayName || b.name) === "GeneratorFunction" : !1
            }, r.mark = function(x) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(x, M) : (x.__proto__ = M, p(x, d, "GeneratorFunction")), x.prototype = Object.create(V), x
            }, r.awrap = function(x) {
                return {
                    __await: x
                }
            };

            function ce(x, b) {
                function y(_, L, E, R) {
                    var G = T(x[_], x, L);
                    if (G.type === "throw") R(G.arg);
                    else {
                        var z = G.arg,
                            j = z.value;
                        return j && typeof j == "object" && i.call(j, "__await") ? b.resolve(j.__await).then(function(re) {
                            y("next", re, E, R)
                        }, function(re) {
                            y("throw", re, E, R)
                        }) : b.resolve(j).then(function(re) {
                            z.value = re, E(z)
                        }, function(re) {
                            return y("throw", re, E, R)
                        })
                    }
                }
                var h;

                function u(_, L) {
                    function E() {
                        return new b(function(R, G) {
                            y(_, L, R, G)
                        })
                    }
                    return h = h ? h.then(E, E) : E()
                }
                this._invoke = u
            }
            Q(ce.prototype), p(ce.prototype, l, function() {
                return this
            }), r.AsyncIterator = ce, r.async = function(x, b, y, h, u) {
                u === void 0 && (u = Promise);
                var _ = new ce(A(x, b, y, h), u);
                return r.isGeneratorFunction(b) ? _ : _.next().then(function(L) {
                    return L.done ? L.value : _.next()
                })
            };

            function O(x, b, y) {
                var h = N;
                return function(_, L) {
                    if (h === C) throw new Error("Generator is already running");
                    if (h === S) {
                        if (_ === "throw") throw L;
                        return v()
                    }
                    for (y.method = _, y.arg = L;;) {
                        var E = y.delegate;
                        if (E) {
                            var R = w(E, y);
                            if (R) {
                                if (R === k) continue;
                                return R
                            }
                        }
                        if (y.method === "next") y.sent = y._sent = y.arg;
                        else if (y.method === "throw") {
                            if (h === N) throw h = S, y.arg;
                            y.dispatchException(y.arg)
                        } else y.method === "return" && y.abrupt("return", y.arg);
                        h = C;
                        var G = T(x, b, y);
                        if (G.type === "normal") {
                            if (h = y.done ? S : P, G.arg === k) continue;
                            return {
                                value: G.arg,
                                done: y.done
                            }
                        } else G.type === "throw" && (h = S, y.method = "throw", y.arg = G.arg)
                    }
                }
            }

            function w(x, b) {
                var y = x.iterator[b.method];
                if (y === s) {
                    if (b.delegate = null, b.method === "throw") {
                        if (x.iterator.return && (b.method = "return", b.arg = s, w(x, b), b.method === "throw")) return k;
                        b.method = "throw", b.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return k
                }
                var h = T(y, x.iterator, b.arg);
                if (h.type === "throw") return b.method = "throw", b.arg = h.arg, b.delegate = null, k;
                var u = h.arg;
                if (!u) return b.method = "throw", b.arg = new TypeError("iterator result is not an object"), b.delegate = null, k;
                if (u.done) b[x.resultName] = u.value, b.next = x.nextLoc, b.method !== "return" && (b.method = "next", b.arg = s);
                else return u;
                return b.delegate = null, k
            }
            Q(V), p(V, d, "Generator"), p(V, f, function() {
                return this
            }), p(V, "toString", function() {
                return "[object Generator]"
            });

            function m(x) {
                var b = {
                    tryLoc: x[0]
                };
                1 in x && (b.catchLoc = x[1]), 2 in x && (b.finallyLoc = x[2], b.afterLoc = x[3]), this.tryEntries.push(b)
            }

            function a(x) {
                var b = x.completion || {};
                b.type = "normal", delete b.arg, x.completion = b
            }

            function c(x) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], x.forEach(m, this), this.reset(!0)
            }
            r.keys = function(x) {
                var b = [];
                for (var y in x) b.push(y);
                return b.reverse(),
                    function h() {
                        for (; b.length;) {
                            var u = b.pop();
                            if (u in x) return h.value = u, h.done = !1, h
                        }
                        return h.done = !0, h
                    }
            };

            function g(x) {
                if (x) {
                    var b = x[f];
                    if (b) return b.call(x);
                    if (typeof x.next == "function") return x;
                    if (!isNaN(x.length)) {
                        var y = -1,
                            h = function u() {
                                for (; ++y < x.length;)
                                    if (i.call(x, y)) return u.value = x[y], u.done = !1, u;
                                return u.value = s, u.done = !0, u
                            };
                        return h.next = h
                    }
                }
                return {
                    next: v
                }
            }
            r.values = g;

            function v() {
                return {
                    value: s,
                    done: !0
                }
            }
            return c.prototype = {
                constructor: c,
                reset: function(x) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = s, this.done = !1, this.delegate = null, this.method = "next", this.arg = s, this.tryEntries.forEach(a), !x)
                        for (var b in this) b.charAt(0) === "t" && i.call(this, b) && !isNaN(+b.slice(1)) && (this[b] = s)
                },
                stop: function() {
                    this.done = !0;
                    var x = this.tryEntries[0],
                        b = x.completion;
                    if (b.type === "throw") throw b.arg;
                    return this.rval
                },
                dispatchException: function(x) {
                    if (this.done) throw x;
                    var b = this;

                    function y(R, G) {
                        return _.type = "throw", _.arg = x, b.next = R, G && (b.method = "next", b.arg = s), !!G
                    }
                    for (var h = this.tryEntries.length - 1; h >= 0; --h) {
                        var u = this.tryEntries[h],
                            _ = u.completion;
                        if (u.tryLoc === "root") return y("end");
                        if (u.tryLoc <= this.prev) {
                            var L = i.call(u, "catchLoc"),
                                E = i.call(u, "finallyLoc");
                            if (L && E) {
                                if (this.prev < u.catchLoc) return y(u.catchLoc, !0);
                                if (this.prev < u.finallyLoc) return y(u.finallyLoc)
                            } else if (L) {
                                if (this.prev < u.catchLoc) return y(u.catchLoc, !0)
                            } else if (E) {
                                if (this.prev < u.finallyLoc) return y(u.finallyLoc)
                            } else throw new Error("try statement without catch or finally")
                        }
                    }
                },
                abrupt: function(x, b) {
                    for (var y = this.tryEntries.length - 1; y >= 0; --y) {
                        var h = this.tryEntries[y];
                        if (h.tryLoc <= this.prev && i.call(h, "finallyLoc") && this.prev < h.finallyLoc) {
                            var u = h;
                            break
                        }
                    }
                    u && (x === "break" || x === "continue") && u.tryLoc <= b && b <= u.finallyLoc && (u = null);
                    var _ = u ? u.completion : {};
                    return _.type = x, _.arg = b, u ? (this.method = "next", this.next = u.finallyLoc, k) : this.complete(_)
                },
                complete: function(x, b) {
                    if (x.type === "throw") throw x.arg;
                    return x.type === "break" || x.type === "continue" ? this.next = x.arg : x.type === "return" ? (this.rval = this.arg = x.arg, this.method = "return", this.next = "end") : x.type === "normal" && b && (this.next = b), k
                },
                finish: function(x) {
                    for (var b = this.tryEntries.length - 1; b >= 0; --b) {
                        var y = this.tryEntries[b];
                        if (y.finallyLoc === x) return this.complete(y.completion, y.afterLoc), a(y), k
                    }
                },
                catch: function(x) {
                    for (var b = this.tryEntries.length - 1; b >= 0; --b) {
                        var y = this.tryEntries[b];
                        if (y.tryLoc === x) {
                            var h = y.completion;
                            if (h.type === "throw") {
                                var u = h.arg;
                                a(y)
                            }
                            return u
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(x, b, y) {
                    return this.delegate = {
                        iterator: g(x),
                        resultName: b,
                        nextLoc: y
                    }, this.method === "next" && (this.arg = s), k
                }
            }, r
        }(t.exports);
        try {
            regeneratorRuntime = e
        } catch {
            typeof globalThis == "object" ? globalThis.regeneratorRuntime = e : Function("r", "regeneratorRuntime = r")(e)
        }
    }),
    mv = Ce.from(0),
    Od = "0x0000000000000000000000000000000000000000",
    yv = "0x",
    Rr;
(function(t) {
    t.ERC20 = "0xf47261b0", t.ERC721 = "0x02571792", t.MultiAsset = "0x94cfcdd7", t.ERC1155 = "0xa7cb5fb7", t.StaticCall = "0xc339d10a", t.ERC20Bridge = "0xdc1600f3"
})(Rr || (Rr = {}));
var Mf;
(function(t) {
    t[t.Mainnet = 1] = "Mainnet", t[t.Ropsten = 3] = "Ropsten", t[t.Rinkeby = 4] = "Rinkeby", t[t.Kovan = 42] = "Kovan", t[t.Ganache = 1337] = "Ganache", t[t.BSC = 56] = "BSC", t[t.Polygon = 137] = "Polygon", t[t.PolygonMumbai = 80001] = "PolygonMumbai", t[t.Avalanche = 43114] = "Avalanche"
})(Mf || (Mf = {}));
var Vl;
(function(t) {
    t[t.Invalid = 0] = "Invalid", t[t.InvalidMakerAssetAmount = 1] = "InvalidMakerAssetAmount", t[t.InvalidTakerAssetAmount = 2] = "InvalidTakerAssetAmount", t[t.Fillable = 3] = "Fillable", t[t.Expired = 4] = "Expired", t[t.FullyFilled = 5] = "FullyFilled", t[t.Cancelled = 6] = "Cancelled"
})(Vl || (Vl = {}));
var X9 = {
        0: "Invalid",
        1: "InvalidMakerAssetAmount",
        2: "InvalidTakerAssetAmount",
        3: "Fillable",
        4: "Expired",
        5: "FullyFilled",
        6: "Cancelled"
    },
    gv;
(function(t) {
    t.MISSING_CONTRACT_WRAPPERS_ERROR = "MISSING_CONTRACT_WRAPPERS_ERROR"
})(gv || (gv = {}));
var wn;
(function(t) {
    t.ERC20 = "ERC20", t.ERC721 = "ERC721", t.ERC1155 = "ERC1155"
})(wn || (wn = {}));
var Nf = {
        Order: [{
            name: "makerAddress",
            type: "address"
        }, {
            name: "takerAddress",
            type: "address"
        }, {
            name: "feeRecipientAddress",
            type: "address"
        }, {
            name: "senderAddress",
            type: "address"
        }, {
            name: "makerAssetAmount",
            type: "uint256"
        }, {
            name: "takerAssetAmount",
            type: "uint256"
        }, {
            name: "makerFee",
            type: "uint256"
        }, {
            name: "takerFee",
            type: "uint256"
        }, {
            name: "expirationTimeSeconds",
            type: "uint256"
        }, {
            name: "salt",
            type: "uint256"
        }, {
            name: "makerAssetData",
            type: "bytes"
        }, {
            name: "takerAssetData",
            type: "bytes"
        }, {
            name: "makerFeeAssetData",
            type: "bytes"
        }, {
            name: "takerFeeAssetData",
            type: "bytes"
        }]
    },
    xv;
(function(t) {
    t.OrderUnfillable = "ORDER_UNFILLABLE", t.InvalidMaker = "INVALID_MAKER", t.InvalidTaker = "INVALID_TAKER", t.InvalidSender = "INVALID_SENDER", t.InvalidOrderSignature = "INVALID_ORDER_SIGNATURE", t.InvalidTakerAmount = "INVALID_TAKER_AMOUNT", t.DivisionByZero = "DIVISION_BY_ZERO", t.RoundingError = "ROUNDING_ERROR", t.InvalidSignature = "INVALID_SIGNATURE", t.SignatureIllegal = "SIGNATURE_ILLEGAL", t.SignatureInvalid = "SIGNATURE_INVALID", t.SignatureUnsupported = "SIGNATURE_UNSUPPORTED", t.TakerOverpay = "TAKER_OVERPAY", t.OrderOverfill = "ORDER_OVERFILL", t.InvalidFillPrice = "INVALID_FILL_PRICE", t.InvalidNewOrderEpoch = "INVALID_NEW_ORDER_EPOCH", t.CompleteFillFailed = "COMPLETE_FILL_FAILED", t.NegativeSpreadRequired = "NEGATIVE_SPREAD_REQUIRED", t.ReentrancyIllegal = "REENTRANCY_ILLEGAL", t.InvalidTxHash = "INVALID_TX_HASH", t.InvalidTxSignature = "INVALID_TX_SIGNATURE", t.FailedExecution = "FAILED_EXECUTION", t.LengthGreaterThan0Required = "LENGTH_GREATER_THAN_0_REQUIRED", t.LengthGreaterThan3Required = "LENGTH_GREATER_THAN_3_REQUIRED", t.LengthGreaterThan131Required = "LENGTH_GREATER_THAN_131_REQUIRED", t.Length0Required = "LENGTH_0_REQUIRED", t.Length65Required = "LENGTH_65_REQUIRED", t.InvalidAmount = "INVALID_AMOUNT", t.TransferFailed = "TRANSFER_FAILED", t.SenderNotAuthorized = "SENDER_NOT_AUTHORIZED", t.TargetNotAuthorized = "TARGET_NOT_AUTHORIZED", t.TargetAlreadyAuthorized = "TARGET_ALREADY_AUTHORIZED", t.IndexOutOfBounds = "INDEX_OUT_OF_BOUNDS", t.AuthorizedAddressMismatch = "AUTHORIZED_ADDRESS_MISMATCH", t.OnlyContractOwner = "ONLY_CONTRACT_OWNER", t.MakerNotWhitelisted = "MAKER_NOT_WHITELISTED", t.TakerNotWhitelisted = "TAKER_NOT_WHITELISTED", t.AssetProxyDoesNotExist = "ASSET_PROXY_DOES_NOT_EXIST", t.LengthMismatch = "LENGTH_MISMATCH", t.LibBytesGreaterThanZeroLengthRequired = "GREATER_THAN_ZERO_LENGTH_REQUIRED", t.LibBytesGreaterOrEqualTo4LengthRequired = "GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED", t.LibBytesGreaterOrEqualTo20LengthRequired = "GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED", t.LibBytesGreaterOrEqualTo32LengthRequired = "GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED", t.LibBytesGreaterOrEqualToNestedBytesLengthRequired = "GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED", t.LibBytesGreaterOrEqualToSourceBytesLengthRequired = "GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED", t.Erc20InsufficientBalance = "ERC20_INSUFFICIENT_BALANCE", t.Erc20InsufficientAllowance = "ERC20_INSUFFICIENT_ALLOWANCE", t.FeePercentageTooLarge = "FEE_PERCENTAGE_TOO_LARGE", t.ValueGreaterThanZero = "VALUE_GREATER_THAN_ZERO", t.InvalidMsgValue = "INVALID_MSG_VALUE", t.InsufficientEthRemaining = "INSUFFICIENT_ETH_REMAINING", t.Uint256Overflow = "UINT256_OVERFLOW", t.Erc721ZeroToAddress = "ERC721_ZERO_TO_ADDRESS", t.Erc721OwnerMismatch = "ERC721_OWNER_MISMATCH", t.Erc721InvalidSpender = "ERC721_INVALID_SPENDER", t.Erc721ZeroOwner = "ERC721_ZERO_OWNER", t.Erc721InvalidSelector = "ERC721_INVALID_SELECTOR", t.WalletError = "WALLET_ERROR", t.ValidatorError = "VALIDATOR_ERROR", t.InvalidFunctionSelector = "INVALID_FUNCTION_SELECTOR", t.InvalidAssetData = "INVALID_ASSET_DATA", t.InvalidAssetProxy = "INVALID_ASSET_PROXY", t.UnregisteredAssetProxy = "UNREGISTERED_ASSET_PROXY", t.TxFullyConfirmed = "TX_FULLY_CONFIRMED", t.TxNotFullyConfirmed = "TX_NOT_FULLY_CONFIRMED", t.TimeLockIncomplete = "TIME_LOCK_INCOMPLETE", t.InvalidFreeMemoryPtr = "INVALID_FREE_MEMORY_PTR", t.AuctionInvalidAmount = "INVALID_AMOUNT", t.AuctionExpired = "AUCTION_EXPIRED", t.AuctionNotStarted = "AUCTION_NOT_STARTED", t.AuctionInvalidBeginTime = "INVALID_BEGIN_TIME", t.InvalidAssetDataEnd = "INVALID_ASSET_DATA_END", t.InvalidOrBlockedExchangeSelector = "INVALID_OR_BLOCKED_EXCHANGE_SELECTOR", t.BalanceQueryFailed = "BALANCE_QUERY_FAILED", t.AtLeastOneAddressDoesNotMeetBalanceThreshold = "AT_LEAST_ONE_ADDRESS_DOES_NOT_MEET_BALANCE_THRESHOLD", t.FromLessThanToRequired = "FROM_LESS_THAN_TO_REQUIRED", t.ToLessThanLengthRequired = "TO_LESS_THAN_LENGTH_REQUIRED", t.InvalidApprovalSignature = "INVALID_APPROVAL_SIGNATURE", t.ApprovalExpired = "APPROVAL_EXPIRED", t.InvalidOrigin = "INVALID_ORIGIN", t.AmountEqualToOneRequired = "AMOUNT_EQUAL_TO_ONE_REQUIRED", t.BadReceiverReturnValue = "BAD_RECEIVER_RETURN_VALUE", t.CannotTransferToAddressZero = "CANNOT_TRANSFER_TO_ADDRESS_ZERO", t.InsufficientAllowance = "INSUFFICIENT_ALLOWANCE", t.NFTNotOwnedByFromAddress = "NFT_NOT_OWNED_BY_FROM_ADDRESS", t.OwnersAndIdsMustHaveSameLength = "OWNERS_AND_IDS_MUST_HAVE_SAME_LENGTH", t.TokenAndValuesLengthMismatch = "TOKEN_AND_VALUES_LENGTH_MISMATCH", t.TransferRejected = "TRANSFER_REJECTED", t.Uint256Underflow = "UINT256_UNDERFLOW", t.InvalidIdsOffset = "INVALID_IDS_OFFSET", t.InvalidValuesOffset = "INVALID_VALUES_OFFSET", t.InvalidDataOffset = "INVALID_DATA_OFFSET", t.InvalidAssetDataLength = "INVALID_ASSET_DATA_LENGTH", t.InvalidStaticCallDataOffset = "INVALID_STATIC_CALL_DATA_OFFSET", t.TargetNotEven = "TARGET_NOT_EVEN", t.UnexpectedStaticCallResult = "UNEXPECTED_STATIC_CALL_RESULT", t.TransfersSuccessful = "TRANSFERS_SUCCESSFUL", t.InsufficientFunds = "INSUFFICIENT_FUNDS", t.TxAlreadyExecuted = "TX_ALREADY_EXECUTED", t.DefaultTimeLockIncomplete = "DEFAULT_TIME_LOCK_INCOMPLETE", t.CustomTimeLockIncomplete = "CUSTOM_TIME_LOCK_INCOMPLETE", t.EqualLengthsRequired = "EQUAL_LENGTHS_REQUIRED", t.OnlyCallableByWallet = "ONLY_CALLABLE_BY_WALLET"
})(xv || (xv = {}));
var J9 = "0xBCC02a155c374263321155555Ccf41070017649e",
    Z9 = Ce.from(2524604400),
    Sf = function(e, r) {
        return {
            name: "0x Protocol",
            version: "3.0.0",
            chainId: e.toString(10),
            verifyingContract: r
        }
    },
    Kl = function(e) {
        var r;
        return {
            makerAddress: e.makerAddress.toLowerCase(),
            takerAddress: e.takerAddress.toLowerCase(),
            feeRecipientAddress: e.feeRecipientAddress.toLowerCase(),
            senderAddress: e.senderAddress.toLowerCase(),
            makerAssetAmount: e.makerAssetAmount.toString(),
            takerAssetAmount: e.takerAssetAmount.toString(),
            makerFee: e.makerFee.toString(),
            takerFee: e.takerFee.toString(),
            expirationTimeSeconds: e.expirationTimeSeconds.toString(),
            salt: e.salt.toString(),
            makerAssetData: e.makerAssetData.toLowerCase(),
            takerAssetData: e.takerAssetData.toLowerCase(),
            makerFeeAssetData: e.makerFeeAssetData.toLowerCase(),
            takerFeeAssetData: e.takerFeeAssetData.toLowerCase(),
            signature: (r = e.signature) == null ? void 0 : r.toLowerCase()
        }
    },
    Y9 = function(e) {
        var r = e.makerAssetAmount,
            n = e.takerAssetAmount,
            i = e.makerAddress,
            s = e.makerAssetData,
            o = e.takerAssetData,
            f = e.takerAddress,
            l = e.expiration,
            d = e.salt,
            p = e.feeRecipientAddress,
            A = e.makerFeeAssetData,
            T = e.takerFeeAssetData,
            N = e.makerFee,
            P = e.takerFee,
            C = l ? Ce.from(qb(l)) : Z9,
            S = {
                makerAddress: i,
                makerAssetAmount: r.toString(),
                makerAssetData: s,
                takerAddress: f || Od,
                takerAssetAmount: n.toString(),
                takerAssetData: o,
                expirationTimeSeconds: C.toString(),
                senderAddress: Od,
                feeRecipientAddress: p != null ? p : J9,
                salt: d != null ? d : eM(),
                makerFeeAssetData: A != null ? A : yv,
                takerFeeAssetData: T != null ? T : yv,
                makerFee: N != null ? N : mv.toString(),
                takerFee: P != null ? P : mv.toString()
            };
        return S
    },
    Q9 = function() {
        var e = qb(new Date);
        return e.toString(10)
    },
    eM = function(e) {
        return e || Q9()
    },
    bv = function(t) {
        Id(e, t);

        function e(r, n) {
            var i;
            return i = t.call(this, r || "") || this, typeof n == "object" && n !== null && (n.code && (i.code = String(n.code)), n.expected && (i.expected = !0), n.transient && (i.transient = !0), n.cause && (i.cause = n.cause)), Error.captureStackTrace && Error.captureStackTrace(V9(i), i.constructor), i
        }
        return e
    }(kd(Error)),
    Pf = function(t) {
        Id(e, t);

        function e(r) {
            var n, i = "UnexpectedAssetTypeError";
            return n = t.call(this, "Unexpected asset type " + (r != null ? r : "unknown"), {
                expected: !0,
                code: i
            }) || this, n.name = i, n
        }
        return e
    }(bv),
    vv = function(t) {
        Id(e, t);

        function e(r) {
            var n, i = "UnsupportedChainId";
            return n = t.call(this, "Unexpected chainId " + r + ". If you want to use that chain, please provide custom zeroex addresses", {
                expected: !0,
                code: i
            }) || this, n.name = i, n
        }
        return e
    }(bv),
    tM = function(e) {
        return Ce.from(e)
    },
    Cd = function(e) {
        return e.map(tM)
    },
    rM = function(e) {
        return pn([Rr.ERC20, ss.encode(["address"], [e])])
    },
    nM = function(e) {
        hl(e);
        var r = Ir(e, 0, 4),
            n = Ir(e, 4),
            i = ss.decode(["address"], n),
            s = i[0];
        return {
            assetProxyId: r.toLowerCase(),
            tokenAddress: s.toLowerCase()
        }
    },
    iM = function(e, r) {
        return pn([Rr.ERC721, ss.encode(["address", "uint256"], [e, r])])
    },
    sM = function(e) {
        var r = Ir(e, 0, 4),
            n = Ir(e, 4),
            i = ss.decode(["address", "uint256"], n),
            s = i[0],
            o = i[1];
        return {
            assetProxyId: r.toLowerCase(),
            tokenAddress: s.toLowerCase(),
            tokenId: o.toString()
        }
    },
    oM = function(e, r, n, i) {
        return pn([Rr.ERC1155, ss.encode(["address", "uint256[]", "uint256[]", "bytes"], [e, r, n, i])])
    },
    aM = function(e) {
        var r = Ir(e, 0, 4),
            n = Ir(e, 4),
            i = ss.decode(["address", "uint256[]", "uint256[]", "bytes"], n),
            s = i[0],
            o = i[1],
            f = i[2],
            l = i[3];
        return {
            assetProxyId: r.toLowerCase(),
            tokenAddress: s.toLowerCase(),
            tokenIds: o.map(function(d) {
                return d.toString()
            }),
            tokenValues: f.map(function(d) {
                return d.toString()
            }),
            callbackData: l
        }
    },
    wv = function(e, r) {
        return pn([Rr.MultiAsset, ss.encode(["uint256[]", "bytes[]"], [e, r])])
    },
    fM = function(e) {
        var r = Ir(e, 0, 4),
            n = Ir(e, 4),
            i = ss.decode(["uint256[]", "bytes[]"], n),
            s = i[0],
            o = i[1];
        return {
            assetProxyId: r.toLowerCase(),
            amounts: s.map(function(f) {
                return f.toString()
            }),
            nestedAssetData: o.map(function(f) {
                return Jl(f)
            })
        }
    },
    Xl = function(e, r) {
        switch (r === void 0 && (r = !1), e.type) {
            case wn.ERC20:
                var n = rM(e.tokenAddress);
                return n;
            case wn.ERC721:
                var i = iM(e.tokenAddress, Ce.from(e.tokenId));
                return i;
            case wn.ERC1155:
                var s = e.tokens.map(function(l) {
                        return l.tokenId
                    }),
                    o;
                r ? o = e.tokens.map(function(l) {
                    return "1"
                }) : o = e.tokens.map(function(l) {
                    return l.tokenValue
                });
                var f = oM(e.tokenAddress, Cd(s), Cd(o), "0x");
                return f;
            default:
                throw new Error("Unsupported type " + (e == null ? void 0 : e.type))
        }
    },
    Jl = function(e) {
        var r = Ir(e, 0, 4);
        switch (r) {
            case Rr.ERC20:
                var n = nM(e);
                return n;
            case Rr.ERC721:
                var i = sM(e);
                return i;
            case Rr.ERC1155:
                var s = aM(e);
                return s;
            case Rr.MultiAsset:
                var o = fM(e);
                return o;
            default:
                throw new Error("Unsupported AssetProxyId " + (r == null ? void 0 : r.type))
        }
    },
    Zl = function(e) {
        var r, n;
        switch (e.type) {
            case wn.ERC20:
                return e.amount;
            case wn.ERC721:
                return "1";
            case wn.ERC1155:
                return (r = (n = e.tokens[0]) == null ? void 0 : n.tokenValue) != null ? r : "1";
            default:
                throw new Error("Unsupported type " + (e == null ? void 0 : e.type))
        }
    },
    Yl = function(e) {
        var r;
        switch (e.type) {
            case "ERC20":
                return e;
            case "ERC721":
                return e;
            case "ERC1155":
                var n = {
                    tokenAddress: e.tokenAddress,
                    tokens: [{
                        tokenId: e.tokenId,
                        tokenValue: e.amount || "1"
                    }],
                    type: wn.ERC1155
                };
                return n;
            default:
                throw new Pf((r = e == null ? void 0 : e.type) != null ? r : "Unknown")
        }
    },
    Ev = function(e) {
        return e.map(Yl)
    },
    Fd = [{
        inputs: [{
            internalType: "uint256",
            name: "chainId",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "bytes4",
            name: "id",
            type: "bytes4"
        }, {
            indexed: !1,
            internalType: "address",
            name: "assetProxy",
            type: "address"
        }],
        name: "AssetProxyRegistered",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "makerAddress",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "feeRecipientAddress",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "makerAssetData",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "takerAssetData",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "address",
            name: "senderAddress",
            type: "address"
        }, {
            indexed: !0,
            internalType: "bytes32",
            name: "orderHash",
            type: "bytes32"
        }],
        name: "Cancel",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "makerAddress",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "orderSenderAddress",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "orderEpoch",
            type: "uint256"
        }],
        name: "CancelUpTo",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "makerAddress",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "feeRecipientAddress",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "makerAssetData",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "takerAssetData",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "makerFeeAssetData",
            type: "bytes"
        }, {
            indexed: !1,
            internalType: "bytes",
            name: "takerFeeAssetData",
            type: "bytes"
        }, {
            indexed: !0,
            internalType: "bytes32",
            name: "orderHash",
            type: "bytes32"
        }, {
            indexed: !1,
            internalType: "address",
            name: "takerAddress",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "senderAddress",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "makerAssetFilledAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "takerAssetFilledAmount",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "makerFeePaid",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "takerFeePaid",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "protocolFeePaid",
            type: "uint256"
        }],
        name: "Fill",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "address",
            name: "oldProtocolFeeCollector",
            type: "address"
        }, {
            indexed: !1,
            internalType: "address",
            name: "updatedProtocolFeeCollector",
            type: "address"
        }],
        name: "ProtocolFeeCollectorAddress",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !1,
            internalType: "uint256",
            name: "oldProtocolFeeMultiplier",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "updatedProtocolFeeMultiplier",
            type: "uint256"
        }],
        name: "ProtocolFeeMultiplier",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "signerAddress",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "validatorAddress",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "isApproved",
            type: "bool"
        }],
        name: "SignatureValidatorApproval",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "bytes32",
            name: "transactionHash",
            type: "bytes32"
        }],
        name: "TransactionExecution",
        type: "event"
    }, {
        constant: !0,
        inputs: [],
        name: "EIP1271_MAGIC_VALUE",
        outputs: [{
            internalType: "bytes4",
            name: "",
            type: "bytes4"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "EIP712_EXCHANGE_DOMAIN_HASH",
        outputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }, {
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "allowedValidators",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }],
        name: "batchCancelOrders",
        outputs: [],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256"
            }, {
                internalType: "address",
                name: "signerAddress",
                type: "address"
            }, {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            }],
            internalType: "struct LibZeroExTransaction.ZeroExTransaction[]",
            name: "transactions",
            type: "tuple[]"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "batchExecuteTransactions",
        outputs: [{
            internalType: "bytes[]",
            name: "",
            type: "bytes[]"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256[]",
            name: "takerAssetFillAmounts",
            type: "uint256[]"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "batchFillOrKillOrders",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults[]",
            name: "fillResults",
            type: "tuple[]"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256[]",
            name: "takerAssetFillAmounts",
            type: "uint256[]"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "batchFillOrders",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults[]",
            name: "fillResults",
            type: "tuple[]"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256[]",
            name: "takerAssetFillAmounts",
            type: "uint256[]"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "batchFillOrdersNoThrow",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults[]",
            name: "fillResults",
            type: "tuple[]"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "leftOrders",
            type: "tuple[]"
        }, {
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "rightOrders",
            type: "tuple[]"
        }, {
            internalType: "bytes[]",
            name: "leftSignatures",
            type: "bytes[]"
        }, {
            internalType: "bytes[]",
            name: "rightSignatures",
            type: "bytes[]"
        }],
        name: "batchMatchOrders",
        outputs: [{
            components: [{
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults[]",
                name: "left",
                type: "tuple[]"
            }, {
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults[]",
                name: "right",
                type: "tuple[]"
            }, {
                internalType: "uint256",
                name: "profitInLeftMakerAsset",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "profitInRightMakerAsset",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.BatchMatchedFillResults",
            name: "batchMatchedFillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "leftOrders",
            type: "tuple[]"
        }, {
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "rightOrders",
            type: "tuple[]"
        }, {
            internalType: "bytes[]",
            name: "leftSignatures",
            type: "bytes[]"
        }, {
            internalType: "bytes[]",
            name: "rightSignatures",
            type: "bytes[]"
        }],
        name: "batchMatchOrdersWithMaximalFill",
        outputs: [{
            components: [{
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults[]",
                name: "left",
                type: "tuple[]"
            }, {
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults[]",
                name: "right",
                type: "tuple[]"
            }, {
                internalType: "uint256",
                name: "profitInLeftMakerAsset",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "profitInRightMakerAsset",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.BatchMatchedFillResults",
            name: "batchMatchedFillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "order",
            type: "tuple"
        }],
        name: "cancelOrder",
        outputs: [],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "uint256",
            name: "targetOrderEpoch",
            type: "uint256"
        }],
        name: "cancelOrdersUpTo",
        outputs: [],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        name: "cancelled",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "currentContextAddress",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [],
        name: "detachProtocolFeeCollector",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256"
            }, {
                internalType: "address",
                name: "signerAddress",
                type: "address"
            }, {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            }],
            internalType: "struct LibZeroExTransaction.ZeroExTransaction",
            name: "transaction",
            type: "tuple"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "executeTransaction",
        outputs: [{
            internalType: "bytes",
            name: "",
            type: "bytes"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "order",
            type: "tuple"
        }, {
            internalType: "uint256",
            name: "takerAssetFillAmount",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "fillOrKillOrder",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults",
            name: "fillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "order",
            type: "tuple"
        }, {
            internalType: "uint256",
            name: "takerAssetFillAmount",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "fillOrder",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults",
            name: "fillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        name: "filled",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes4",
            name: "assetProxyId",
            type: "bytes4"
        }],
        name: "getAssetProxy",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "order",
            type: "tuple"
        }],
        name: "getOrderInfo",
        outputs: [{
            components: [{
                internalType: "uint8",
                name: "orderStatus",
                type: "uint8"
            }, {
                internalType: "bytes32",
                name: "orderHash",
                type: "bytes32"
            }, {
                internalType: "uint256",
                name: "orderTakerAssetFilledAmount",
                type: "uint256"
            }],
            internalType: "struct LibOrder.OrderInfo",
            name: "orderInfo",
            type: "tuple"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes32",
            name: "hash",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "signerAddress",
            type: "address"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "isValidHashSignature",
        outputs: [{
            internalType: "bool",
            name: "isValid",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "order",
            type: "tuple"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "isValidOrderSignature",
        outputs: [{
            internalType: "bool",
            name: "isValid",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            components: [{
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "gasPrice",
                type: "uint256"
            }, {
                internalType: "address",
                name: "signerAddress",
                type: "address"
            }, {
                internalType: "bytes",
                name: "data",
                type: "bytes"
            }],
            internalType: "struct LibZeroExTransaction.ZeroExTransaction",
            name: "transaction",
            type: "tuple"
        }, {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
        }],
        name: "isValidTransactionSignature",
        outputs: [{
            internalType: "bool",
            name: "isValid",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256",
            name: "makerAssetFillAmount",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "marketBuyOrdersFillOrKill",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults",
            name: "fillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256",
            name: "makerAssetFillAmount",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "marketBuyOrdersNoThrow",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults",
            name: "fillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256",
            name: "takerAssetFillAmount",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "marketSellOrdersFillOrKill",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults",
            name: "fillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256",
            name: "takerAssetFillAmount",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }],
        name: "marketSellOrdersNoThrow",
        outputs: [{
            components: [{
                internalType: "uint256",
                name: "makerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetFilledAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFeePaid",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "protocolFeePaid",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.FillResults",
            name: "fillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "leftOrder",
            type: "tuple"
        }, {
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "rightOrder",
            type: "tuple"
        }, {
            internalType: "bytes",
            name: "leftSignature",
            type: "bytes"
        }, {
            internalType: "bytes",
            name: "rightSignature",
            type: "bytes"
        }],
        name: "matchOrders",
        outputs: [{
            components: [{
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults",
                name: "left",
                type: "tuple"
            }, {
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults",
                name: "right",
                type: "tuple"
            }, {
                internalType: "uint256",
                name: "profitInLeftMakerAsset",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "profitInRightMakerAsset",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.MatchedFillResults",
            name: "matchedFillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "leftOrder",
            type: "tuple"
        }, {
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order",
            name: "rightOrder",
            type: "tuple"
        }, {
            internalType: "bytes",
            name: "leftSignature",
            type: "bytes"
        }, {
            internalType: "bytes",
            name: "rightSignature",
            type: "bytes"
        }],
        name: "matchOrdersWithMaximalFill",
        outputs: [{
            components: [{
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults",
                name: "left",
                type: "tuple"
            }, {
                components: [{
                    internalType: "uint256",
                    name: "makerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerAssetFilledAmount",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "makerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "takerFeePaid",
                    type: "uint256"
                }, {
                    internalType: "uint256",
                    name: "protocolFeePaid",
                    type: "uint256"
                }],
                internalType: "struct LibFillResults.FillResults",
                name: "right",
                type: "tuple"
            }, {
                internalType: "uint256",
                name: "profitInLeftMakerAsset",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "profitInRightMakerAsset",
                type: "uint256"
            }],
            internalType: "struct LibFillResults.MatchedFillResults",
            name: "matchedFillResults",
            type: "tuple"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }, {
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "orderEpoch",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "bytes32",
            name: "hash",
            type: "bytes32"
        }],
        name: "preSign",
        outputs: [],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }, {
            internalType: "address",
            name: "",
            type: "address"
        }],
        name: "preSigned",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "protocolFeeCollector",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "protocolFeeMultiplier",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "assetProxy",
            type: "address"
        }],
        name: "registerAssetProxy",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "updatedProtocolFeeCollector",
            type: "address"
        }],
        name: "setProtocolFeeCollectorAddress",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "uint256",
            name: "updatedProtocolFeeMultiplier",
            type: "uint256"
        }],
        name: "setProtocolFeeMultiplier",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "validatorAddress",
            type: "address"
        }, {
            internalType: "bool",
            name: "approval",
            type: "bool"
        }],
        name: "setSignatureValidatorApproval",
        outputs: [],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "bytes[]",
            name: "assetData",
            type: "bytes[]"
        }, {
            internalType: "address[]",
            name: "fromAddresses",
            type: "address[]"
        }, {
            internalType: "address[]",
            name: "toAddresses",
            type: "address[]"
        }, {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
        }],
        name: "simulateDispatchTransferFromCalls",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes32",
            name: "",
            type: "bytes32"
        }],
        name: "transactionsExecuted",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    Av = function() {
        function t() {}
        return t.createInterface = function() {
            return new Ps(Fd)
        }, t.connect = function(r, n) {
            return new _f(r, Fd, n)
        }, t
    }();
Av.abi = Fd;
var Dd = [{
        inputs: [{
            internalType: "address",
            name: "_exchange",
            type: "address"
        }, {
            internalType: "address",
            name: "_exchangeV2",
            type: "address"
        }, {
            internalType: "address",
            name: "_weth",
            type: "address"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "OwnershipTransferred",
        type: "event"
    }, {
        payable: !0,
        stateMutability: "payable",
        type: "fallback"
    }, {
        constant: !0,
        inputs: [],
        name: "ERC1155_BATCH_RECEIVED",
        outputs: [{
            internalType: "bytes4",
            name: "",
            type: "bytes4"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "ERC1155_RECEIVED",
        outputs: [{
            internalType: "bytes4",
            name: "",
            type: "bytes4"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "EXCHANGE_V2_ORDER_ID",
        outputs: [{
            internalType: "bytes4",
            name: "",
            type: "bytes4"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "bytes",
            name: "assetData",
            type: "bytes"
        }],
        name: "approveMakerAssetProxy",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256",
            name: "makerAssetBuyAmount",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }, {
            internalType: "uint256[]",
            name: "ethFeeAmounts",
            type: "uint256[]"
        }, {
            internalType: "address payable[]",
            name: "feeRecipients",
            type: "address[]"
        }],
        name: "marketBuyOrdersWithEth",
        outputs: [{
            internalType: "uint256",
            name: "wethSpentAmount",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "makerAssetAcquiredAmount",
            type: "uint256"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "uint256",
            name: "ethSellAmount",
            type: "uint256"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }, {
            internalType: "uint256[]",
            name: "ethFeeAmounts",
            type: "uint256[]"
        }, {
            internalType: "address payable[]",
            name: "feeRecipients",
            type: "address[]"
        }],
        name: "marketSellAmountWithEth",
        outputs: [{
            internalType: "uint256",
            name: "wethSpentAmount",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "makerAssetAcquiredAmount",
            type: "uint256"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct LibOrder.Order[]",
            name: "orders",
            type: "tuple[]"
        }, {
            internalType: "bytes[]",
            name: "signatures",
            type: "bytes[]"
        }, {
            internalType: "uint256[]",
            name: "ethFeeAmounts",
            type: "uint256[]"
        }, {
            internalType: "address payable[]",
            name: "feeRecipients",
            type: "address[]"
        }],
        name: "marketSellOrdersWithEth",
        outputs: [{
            internalType: "uint256",
            name: "wethSpentAmount",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "makerAssetAcquiredAmount",
            type: "uint256"
        }],
        payable: !0,
        stateMutability: "payable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "operator",
            type: "address"
        }, {
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
        }, {
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "onERC1155BatchReceived",
        outputs: [{
            internalType: "bytes4",
            name: "",
            type: "bytes4"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "operator",
            type: "address"
        }, {
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "uint256",
            name: "id",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "value",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "data",
            type: "bytes"
        }],
        name: "onERC1155Received",
        outputs: [{
            internalType: "bytes4",
            name: "",
            type: "bytes4"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "newOwner",
            type: "address"
        }],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "bytes",
            name: "assetData",
            type: "bytes"
        }, {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
        }],
        name: "withdrawAsset",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }],
    _v = function() {
        function t() {}
        return t.createInterface = function() {
            return new Ps(Dd)
        }, t.connect = function(r, n) {
            return new _f(r, Dd, n)
        }, t
    }();
_v.abi = Dd;
var Ud = [{
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "_owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "_operator",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "_approved",
            type: "bool"
        }],
        name: "ApprovalForAll",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "_operator",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "_from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "_to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256[]",
            name: "_ids",
            type: "uint256[]"
        }, {
            indexed: !1,
            internalType: "uint256[]",
            name: "_amounts",
            type: "uint256[]"
        }],
        name: "TransferBatch",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "_operator",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "_from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "_to",
            type: "address"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "_id",
            type: "uint256"
        }, {
            indexed: !1,
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
        }],
        name: "TransferSingle",
        type: "event"
    }, {
        inputs: [{
            internalType: "address",
            name: "_owner",
            type: "address"
        }, {
            internalType: "uint256",
            name: "_id",
            type: "uint256"
        }],
        name: "balanceOf",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address[]",
            name: "_owners",
            type: "address[]"
        }, {
            internalType: "uint256[]",
            name: "_ids",
            type: "uint256[]"
        }],
        name: "balanceOfBatch",
        outputs: [{
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_owner",
            type: "address"
        }, {
            internalType: "address",
            name: "_operator",
            type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
            internalType: "bool",
            name: "isOperator",
            type: "bool"
        }],
        stateMutability: "view",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_from",
            type: "address"
        }, {
            internalType: "address",
            name: "_to",
            type: "address"
        }, {
            internalType: "uint256[]",
            name: "_ids",
            type: "uint256[]"
        }, {
            internalType: "uint256[]",
            name: "_amounts",
            type: "uint256[]"
        }, {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
        }],
        name: "safeBatchTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_from",
            type: "address"
        }, {
            internalType: "address",
            name: "_to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "_id",
            type: "uint256"
        }, {
            internalType: "uint256",
            name: "_amount",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
        }],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "address",
            name: "_operator",
            type: "address"
        }, {
            internalType: "bool",
            name: "_approved",
            type: "bool"
        }],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [{
            internalType: "bytes4",
            name: "_interfaceID",
            type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        stateMutability: "pure",
        type: "function"
    }],
    Ql = function() {
        function t() {}
        return t.createInterface = function() {
            return new Ps(Ud)
        }, t.connect = function(r, n) {
            return new _f(r, Ud, n)
        }, t
    }();
Ql.abi = Ud;
var Ld = [{
        constant: !0,
        inputs: [],
        name: "name",
        outputs: [{
            name: "",
            type: "string"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "_spender",
            type: "address"
        }, {
            name: "_value",
            type: "uint256"
        }],
        name: "approve",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "totalSupply",
        outputs: [{
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "_from",
            type: "address"
        }, {
            name: "_to",
            type: "address"
        }, {
            name: "_value",
            type: "uint256"
        }],
        name: "transferFrom",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "decimals",
        outputs: [{
            name: "",
            type: "uint8"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            name: "_owner",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            name: "balance",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [],
        name: "symbol",
        outputs: [{
            name: "",
            type: "string"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            name: "_to",
            type: "address"
        }, {
            name: "_value",
            type: "uint256"
        }],
        name: "transfer",
        outputs: [{
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            name: "_owner",
            type: "address"
        }, {
            name: "_spender",
            type: "address"
        }],
        name: "allowance",
        outputs: [{
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        payable: !0,
        stateMutability: "payable",
        type: "fallback"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            name: "spender",
            type: "address"
        }, {
            indexed: !1,
            name: "value",
            type: "uint256"
        }],
        name: "Approval",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            name: "to",
            type: "address"
        }, {
            indexed: !1,
            name: "value",
            type: "uint256"
        }],
        name: "Transfer",
        type: "event"
    }],
    e0 = function() {
        function t() {}
        return t.createInterface = function() {
            return new Ps(Ld)
        }, t.connect = function(r, n) {
            return new _f(r, Ld, n)
        }, t
    }();
e0.abi = Ld;
var Bd = [{
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "approve",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "mint",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "safeTransferFrom",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }, {
            internalType: "bytes",
            name: "_data",
            type: "bytes"
        }],
        name: "safeTransferFrom",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "bool",
            name: "approved",
            type: "bool"
        }],
        name: "setApprovalForAll",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        constant: !1,
        inputs: [{
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "transferFrom",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
    }, {
        inputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "Transfer",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "approved",
            type: "address"
        }, {
            indexed: !0,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "Approval",
        type: "event"
    }, {
        anonymous: !1,
        inputs: [{
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
        }, {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
        }],
        name: "ApprovalForAll",
        type: "event"
    }, {
        constant: !0,
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }],
        name: "balanceOf",
        outputs: [{
            internalType: "uint256",
            name: "",
            type: "uint256"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "getApproved",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "address",
            name: "owner",
            type: "address"
        }, {
            internalType: "address",
            name: "operator",
            type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
        }],
        name: "ownerOf",
        outputs: [{
            internalType: "address",
            name: "",
            type: "address"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }, {
        constant: !0,
        inputs: [{
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
            internalType: "bool",
            name: "",
            type: "bool"
        }],
        payable: !1,
        stateMutability: "view",
        type: "function"
    }],
    t0 = function() {
        function t() {}
        return t.createInterface = function() {
            return new Ps(Bd)
        }, t.connect = function(r, n) {
            return new _f(r, Bd, n)
        }, t
    }();
t0.abi = Bd;
var uM = function(e) {
        var r = en({}, e.types);
        return delete r.EIP712Domain, Gr.hash(e.domain, r, e.message)
    },
    lM = [{
        inputs: [{
            components: [{
                internalType: "address",
                name: "makerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "takerAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "feeRecipientAddress",
                type: "address"
            }, {
                internalType: "address",
                name: "senderAddress",
                type: "address"
            }, {
                internalType: "uint256",
                name: "makerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerAssetAmount",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "makerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "takerFee",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "expirationTimeSeconds",
                type: "uint256"
            }, {
                internalType: "uint256",
                name: "salt",
                type: "uint256"
            }, {
                internalType: "bytes",
                name: "makerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "makerFeeAssetData",
                type: "bytes"
            }, {
                internalType: "bytes",
                name: "takerFeeAssetData",
                type: "bytes"
            }],
            internalType: "struct IEIP1271Data.Order",
            name: "order",
            type: "tuple"
        }, {
            internalType: "bytes32",
            name: "orderHash",
            type: "bytes32"
        }],
        name: "OrderWithHash",
        outputs: [],
        stateMutability: "pure",
        type: "function"
    }],
    cM = function(e, r) {
        return e.cancelOrder(r)
    },
    hM = function() {
        var t = Wt(Je.mark(function e(r, n) {
            var i;
            return Je.wrap(function(o) {
                for (;;) switch (o.prev = o.next) {
                    case 0:
                        return o.next = 2, r.getOrderInfo(n);
                    case 2:
                        return i = o.sent, o.abrupt("return", i);
                    case 4:
                    case "end":
                        return o.stop()
                }
            }, e)
        }));
        return function(r, n) {
            return t.apply(this, arguments)
        }
    }(),
    dM = function(e, r, n) {
        var i = Sf(r, n);
        return Gr.hash(i, Nf, e)
    },
    pM = function() {
        var t = Wt(Je.mark(function e(r, n, i, s) {
            var o, f, l, d, p, A, T;
            return Je.wrap(function(P) {
                for (;;) switch (P.prev = P.next) {
                    case 0:
                        return o = Sf(i, s), f = Nf, l = r, d = {
                            domain: o,
                            types: f,
                            message: l
                        }, p = uM(d), A = new Ps(lM).encodeFunctionData("OrderWithHash", [r, p]), P.next = 8, n.signMessage(ze(A));
                    case 8:
                        return T = P.sent, P.abrupt("return", T);
                    case 10:
                    case "end":
                        return P.stop()
                }
            }, e)
        }));
        return function(r, n, i, s) {
            return t.apply(this, arguments)
        }
    }(),
    mM = function() {
        var t = Wt(Je.mark(function e(r, n, i, s) {
            var o, f, l, d;
            return Je.wrap(function(A) {
                for (;;) switch (A.prev = A.next) {
                    case 0:
                        return o = Sf(i, s), f = Nf, l = r, A.next = 5, n._signTypedData(o, f, l);
                    case 5:
                        return d = A.sent, A.abrupt("return", d);
                    case 7:
                    case "end":
                        return A.stop()
                }
            }, e)
        }));
        return function(r, n, i, s) {
            return t.apply(this, arguments)
        }
    }(),
    yM = function() {
        var t = Wt(Je.mark(function e(r, n) {
            var i, s, o, f, l, d, p;
            return Je.wrap(function(T) {
                for (;;) switch (T.prev = T.next) {
                    case 0:
                        if (i = !1, !r.getCode) {
                            T.next = 6;
                            break
                        }
                        return T.next = 4, r.getCode(n);
                    case 4:
                        s = T.sent, s && s != "0x" && (i = !0);
                    case 6:
                        return o = !!r._isSequenceProvider, o && (i = !0), f = r.provider, f != null && f.isWalletConnect && (p = ((l = f.connector) == null || (d = l._peerMeta) == null ? void 0 : d.description) === "Sequence", p && (i = !0)), T.abrupt("return", i);
                    case 11:
                    case "end":
                        return T.stop()
                }
            }, e)
        }));
        return function(r, n) {
            return t.apply(this, arguments)
        }
    }(),
    gM = function() {
        var t = Wt(Je.mark(function e(r, n, i, s, o, f, l) {
            var d, p, A, T, N, P;
            return Je.wrap(function(S) {
                for (;;) switch (S.prev = S.next) {
                    case 0:
                        if (S.prev = 0, d = "eoa", (l == null ? void 0 : l.signatureType) !== "eip1271") {
                            S.next = 6;
                            break
                        }
                        d = "eip1271", S.next = 18;
                        break;
                    case 6:
                        if ((l == null ? void 0 : l.signatureType) !== "eoa") {
                            S.next = 10;
                            break
                        }
                        d = "eoa", S.next = 18;
                        break;
                    case 10:
                        if ((l == null ? void 0 : l.autodetectSignatureType) !== !1) {
                            S.next = 14;
                            break
                        }
                        d = "eoa", S.next = 18;
                        break;
                    case 14:
                        return S.next = 16, yM(s, n);
                    case 16:
                        p = S.sent, p ? d = "eip1271" : d = "eoa";
                    case 18:
                        S.t0 = d, S.next = S.t0 === "eoa" ? 21 : S.t0 === "eip1271" ? 26 : 31;
                        break;
                    case 21:
                        return S.next = 23, mM(r, i, o, f);
                    case 23:
                        return T = S.sent, A = xM(T), S.abrupt("break", 32);
                    case 26:
                        return S.next = 28, pM(r, i, o, f);
                    case 28:
                        return N = A = S.sent, A = bM(N), S.abrupt("break", 32);
                    case 31:
                        throw new Error("Unknown signature method chosen: " + d);
                    case 32:
                        return P = en({}, r, {
                            signature: A
                        }), S.abrupt("return", P);
                    case 36:
                        throw S.prev = 36, S.t1 = S.catch(0), console.log("error signing order", S.t1), S.t1;
                    case 40:
                    case "end":
                        return S.stop()
                }
            }, e, null, [
                [0, 36]
            ])
        }));
        return function(r, n, i, s, o, f, l) {
            return t.apply(this, arguments)
        }
    }(),
    xM = function(e) {
        var r = dl(e);
        return pn([nt(r.v), r.r, r.s, "0x02"])
    },
    bM = function(e) {
        return pn([e, "0x07"])
    },
    vM = function(e, r, n, i) {
        var s = Sf(n, i);
        try {
            var o = e.makerAddress.toLowerCase(),
                f = hl(r),
                l = Ir(r, 0, 1),
                d = Ir(r, 1, f - 1),
                p = pn([d, l]),
                A = J_(p),
                T = y7(s, Nf, e, A);
            return o.toLowerCase() === T.toLowerCase()
        } catch (N) {
            return console.log(N), !1
        }
    },
    wM = function(e, r, n) {
        var i, s, o, f, l = e.length === 1;
        if (l) {
            var d = e[0];
            o = Ce.from(Zl(d)), f = Xl(d, !1)
        } else {
            var p = e.map(function(F) {
                    return Zl(F)
                }),
                A = e.map(function(F) {
                    return Xl(F, !0)
                }),
                T = wv(p, A);
            f = T, o = Ce.from(1)
        }
        var N, P, C = r.length === 1;
        if (C) {
            var S = r[0];
            N = Ce.from(Zl(S)), P = Xl(S, !1)
        } else {
            var k = r.map(function(F) {
                    return Zl(F)
                }),
                I = r.map(function(F) {
                    return Xl(F, !0)
                }),
                U = wv(Cd(k), I);
            P = U, N = Ce.from(1)
        }
        var M = Y9(en({
            makerAssetAmount: o,
            makerAssetData: f,
            takerAddress: (i = n.takerAddress) != null ? i : Od,
            takerAssetAmount: N,
            takerAssetData: P,
            exchangeAddress: (s = n.exchangeAddress) != null ? s : ""
        }, n));
        return M
    },
    EM = function() {
        var t = Wt(Je.mark(function e(r, n, i) {
            return Je.wrap(function(o) {
                for (;;) switch (o.prev = o.next) {
                    case 0:
                        return o.abrupt("return", n.fillOrKillOrder(Kl(r), r.takerAssetAmount, r.signature, i));
                    case 1:
                    case "end":
                        return o.stop()
                }
            }, e)
        }));
        return function(r, n, i) {
            return t.apply(this, arguments)
        }
    }(),
    AM = function() {
        var t = Wt(Je.mark(function e(r, n, i, s) {
            var o, f, l, d, p, A, T, N, P, C, S, k, I;
            return Je.wrap(function(M) {
                for (;;) switch (M.prev = M.next) {
                    case 0:
                        M.t0 = i.type, M.next = M.t0 === "ERC20" ? 3 : M.t0 === "ERC721" ? 10 : M.t0 === "ERC1155" ? 20 : 25;
                        break;
                    case 3:
                        return o = e0.connect(i.tokenAddress, s), M.next = 6, o.allowance(r, n);
                    case 6:
                        return f = M.sent, l = Ce.from($d.toString()).sub("100000000000000000"), d = f.gte(l), M.abrupt("return", {
                            contractApproved: d
                        });
                    case 10:
                        return p = t0.connect(i.tokenAddress, s), A = p.isApprovedForAll(r, n), T = p.getApproved(i.tokenId), M.next = 15, Promise.all([A, T]);
                    case 15:
                        return N = M.sent, P = N[0], C = N[1], S = C.toLowerCase() === n.toLowerCase(), M.abrupt("return", {
                            contractApproved: P != null ? P : !1,
                            tokenIdApproved: S
                        });
                    case 20:
                        return k = Ql.connect(i.tokenAddress, s), M.next = 23, k.isApprovedForAll(r, n);
                    case 23:
                        return I = M.sent, M.abrupt("return", {
                            contractApproved: I != null ? I : !1
                        });
                    case 25:
                        throw new Pf(i.type);
                    case 26:
                    case "end":
                        return M.stop()
                }
            }, e)
        }));
        return function(r, n, i, s) {
            return t.apply(this, arguments)
        }
    }(),
    $d = Ce.from(2).pow(118),
    _M = function() {
        var t = Wt(Je.mark(function e(r, n, i, s, o) {
            var f, l, d, p, A, T;
            return Je.wrap(function(P) {
                for (;;) switch (P.prev = P.next) {
                    case 0:
                        s === void 0 && (s = {}), o === void 0 && (o = !0), P.t0 = n.type, P.next = P.t0 === "ERC20" ? 5 : P.t0 === "ERC721" ? 8 : P.t0 === "ERC1155" ? 11 : 16;
                        break;
                    case 5:
                        return f = e0.connect(n.tokenAddress, i), l = f.approve(r, o ? $d.toString() : 0, en({}, s)), P.abrupt("return", l);
                    case 8:
                        return d = t0.connect(n.tokenAddress, i), p = d.setApprovalForAll(r, o, en({}, s)), P.abrupt("return", p);
                    case 11:
                        return A = Ql.connect(n.tokenAddress, i), P.next = 14, A.setApprovalForAll(r, o, en({}, s));
                    case 14:
                        return T = P.sent, P.abrupt("return", T);
                    case 16:
                        throw new Pf(n.type);
                    case 17:
                    case "end":
                        return P.stop()
                }
            }, e)
        }));
        return function(r, n, i, s, o) {
            return t.apply(this, arguments)
        }
    }(),
    TM = function() {
        var t = Wt(Je.mark(function e(r, n, i, s, o) {
            var f, l, d, p, A, T;
            return Je.wrap(function(P) {
                for (;;) switch (P.prev = P.next) {
                    case 0:
                        o === void 0 && (o = !0), P.t0 = n.type, P.next = P.t0 === "ERC20" ? 5 : P.t0 === "ERC721" ? 8 : P.t0 === "ERC1155" ? 11 : 16;
                        break;
                    case 5:
                        return f = e0.connect(n.tokenAddress, i), l = f.estimateGas.approve(r, o ? $d : 0), P.abrupt("return", l);
                    case 8:
                        return d = t0.connect(n.tokenAddress, i), p = d.estimateGas.setApprovalForAll(r, o), P.abrupt("return", p);
                    case 11:
                        return A = Ql.connect(n.tokenAddress, i), P.next = 14, A.estimateGas.setApprovalForAll(r, o);
                    case 14:
                        return T = P.sent, P.abrupt("return", T);
                    case 16:
                        throw new Pf(n.type);
                    case 17:
                    case "end":
                        return P.stop()
                }
            }, e)
        }));
        return function(r, n, i, s, o) {
            return t.apply(this, arguments)
        }
    }(),
    MM = function() {
        var t = Wt(Je.mark(function e(r, n, i) {
            var s;
            return Je.wrap(function(f) {
                for (;;) switch (f.prev = f.next) {
                    case 0:
                        return f.next = 2, n.estimateGas.fillOrder(Kl(r), r.takerAssetAmount, r.signature);
                    case 2:
                        return s = f.sent, f.abrupt("return", s);
                    case 4:
                    case "end":
                        return f.stop()
                }
            }, e)
        }));
        return function(r, n, i) {
            return t.apply(this, arguments)
        }
    }(),
    Tv = function t(e, r) {
        var n, i = e.assetProxyId;
        switch (i) {
            case Rr.ERC20:
                var s = e,
                    o = {
                        type: "ERC20",
                        amount: r,
                        tokenAddress: s.tokenAddress
                    };
                return [o];
            case Rr.ERC721:
                var f = e,
                    l = {
                        type: "ERC721",
                        tokenAddress: f.tokenAddress,
                        tokenId: f.tokenId
                    };
                return [l];
            case Rr.ERC1155:
                var d = e,
                    p = {
                        type: "ERC1155",
                        tokenAddress: d.tokenAddress,
                        tokenId: d.tokenIds[0],
                        amount: (n = d.tokenValues[0]) != null ? n : "1"
                    };
                return [p];
            case Rr.MultiAsset:
                var A = e,
                    T = q_(A.nestedAssetData.map(function(P, C) {
                        return t(P, A.amounts[C])
                    })),
                    N = T.map(function(P, C) {
                        var S = A.amounts[C];
                        return en({}, P, {
                            amount: S
                        })
                    });
                return N;
            default:
                throw new Error("Unsupported AssetProxyId " + (i == null ? void 0 : i.type))
        }
    },
    NM = function(e) {
        var r = Jl(e.makerAssetData),
            n = Jl(e.takerAssetData),
            i = Tv(r, e.makerAssetAmount),
            s = Tv(n, e.takerAssetAmount);
        return {
            makerAssets: i,
            takerAssets: s
        }
    },
    If = {
        "1": {
            exchange: "0x61935cbdd02287b511119ddb11aeb42f1593b7ef",
            erc20Proxy: "0x95e6f48254609a6ee006f7d493c8e5fb97094cef",
            erc721Proxy: "0xefc70a1b18c432bdc64b596838b4d138f6bc6cad",
            erc1155Proxy: "0x7eefbd48fd63d441ec7435d024ec7c5131019add",
            multiAssetProxy: "0xef701d5389ae74503d633396c4d654eabedc9d78",
            forwarder: "0x6958f5e95332d93d21af0d7b9ca85b8212fee0a5",
            wrappedNativeToken: "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2"
        },
        "3": {
            exchange: "0x5d8c9ba74607d2cbc4176882a42d4ace891c1c00",
            erc20Proxy: "0xf1ec7d0ba42f15fb5c9e3adbe86431973e44764c",
            erc721Proxy: "0x070efeb7e5ffa3d1a59d03a219539551ae60ba43",
            erc1155Proxy: "0x7f10d80f2659aaae790ab03da12be11c4e6008c3",
            multiAssetProxy: "0x7b70a148e20b348c320208df84fdd642aab49fd0",
            forwarder: "0x2127a60bedfba1c01857b09b8f24094049c48493",
            wrappedNativeToken: null
        },
        "4": {
            exchange: "0xf8becacec90bfc361c0a2c720839e08405a72f6d",
            erc20Proxy: "0x070efeb7e5ffa3d1a59d03a219539551ae60ba43",
            erc721Proxy: "0x7f10d80f2659aaae790ab03da12be11c4e6008c3",
            erc1155Proxy: "0xaa460127562482faa5df42f2c39a025cd4a1cc0a",
            multiAssetProxy: "0xb344afed348de15eb4a9e180205a2b0739628339",
            forwarder: "0x18571835c95a6d79b2f5c45b676ccd16f5fa34a1",
            wrappedNativeToken: "0xc778417e063141139fce010982780140aa0cd5ab"
        },
        "42": {
            exchange: "0xf1ec7d0ba42f15fb5c9e3adbe86431973e44764c",
            erc20Proxy: "0xaa460127562482faa5df42f2c39a025cd4a1cc0a",
            erc721Proxy: "0x7b70a148e20b348c320208df84fdd642aab49fd0",
            erc1155Proxy: "0xb344afed348de15eb4a9e180205a2b0739628339",
            multiAssetProxy: "0x58a01e826e60731247e7de8b446ed4c8535a099c",
            forwarder: "0x01c0ecf5d1a22de07a2de84c322bfa2b5435990e",
            wrappedNativeToken: "0xd0a1e359811322d97991e03f863a0c30c2cf029c"
        },
        "56": {
            exchange: "0x0000000000000000000000000000000000000000",
            erc20Proxy: "0x0000000000000000000000000000000000000000",
            erc721Proxy: "0x0000000000000000000000000000000000000000",
            erc1155Proxy: "0x0000000000000000000000000000000000000000",
            multiAssetProxy: "0x0000000000000000000000000000000000000000",
            forwarder: "0x0000000000000000000000000000000000000000",
            wrappedNativeToken: null
        },
        "137": {
            exchange: "0x0C58C1170f1DEd633862A1166f52107490a9C594",
            erc20Proxy: "0xb9456408E12f3587Ed59E07CC6916768D1117907",
            erc721Proxy: "0x9F1949A5c3AC012fFcded5e93ffD97A86dBF98cC",
            erc1155Proxy: "0x633d89e0C08D3C482C4E0bEE674692A48cADD680",
            multiAssetProxy: "0x4f9b1eDAE8C75b9e1934ce21De598ff0D9f32aBD",
            forwarder: "0x163978F66E23bE5a64DBCd224dd90B78C2f71B98",
            wrappedNativeToken: "0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270"
        },
        "1337": {
            erc20Proxy: "0x1dc4c1cefef38a777b15aa20260a54e584b16c48",
            erc721Proxy: "0x0000000000000000000000000000000000000000",
            erc1155Proxy: "0x0000000000000000000000000000000000000000",
            exchange: "0x0000000000000000000000000000000000000000",
            multiAssetProxy: "0x0000000000000000000000000000000000000000",
            forwarder: "0x5d3ad3561a1235273cbcb4e82fce63a0073d19be",
            wrappedNativeToken: null
        },
        "43114": {
            exchange: "0x0000000000000000000000000000000000000000",
            erc20Proxy: "0x0000000000000000000000000000000000000000",
            erc721Proxy: "0x0000000000000000000000000000000000000000",
            erc1155Proxy: "0x0000000000000000000000000000000000000000",
            multiAssetProxy: "0x0000000000000000000000000000000000000000",
            forwarder: "0x0000000000000000000000000000000000000000",
            wrappedNativeToken: null
        },
        "80001": {
            exchange: "0x9866c45224667061f8c9e66db38d9316a8d68951",
            erc20Proxy: "0xfcEB29377a6e0A86E9fa648016b459AB8Fbfcf5A",
            erc721Proxy: "0x0C58C1170f1DEd633862A1166f52107490a9C594",
            erc1155Proxy: "0x9F1949A5c3AC012fFcded5e93ffD97A86dBF98cC",
            multiAssetProxy: "0xA01Fae8743bb144D4411292a1e6e0B5bfF84Fc5A",
            forwarder: "0xEE9c5Ed9b1bbf9Bf66575Bcc0Eb37dBeC2C525F1",
            wrappedNativeToken: "0x9c3c9283d3e44854697cd22d3faa240cfb032889"
        }
    },
    Gd = function(e, r) {
        r === void 0 && (r = If);
        var n = e.toString(10),
            i = r[n];
        return i
    },
    Rf = function(e, r, n) {
        n === void 0 && (n = If);
        var i = Gd(r, n);
        if (!i) throw new vv(r);
        switch (e) {
            case "ERC20":
                return i.erc20Proxy;
            case "ERC721":
                return i.erc721Proxy;
            case "ERC1155":
                return i.erc1155Proxy;
            default:
                throw new Pf(e)
        }
    },
    SM = function(e, r) {
        r === void 0 && (r = If);
        var n = Gd(e, r);
        if (!n) throw new vv(e);
        return n.forwarder
    },
    PM = function(e, r) {
        var n;
        r === void 0 && (r = If);
        var i = Gd(e, r);
        return (n = i == null ? void 0 : i.wrappedNativeToken) != null ? n : null
    },
    kf, IM = (kf = {}, kf[Mf.Polygon] = 1.5, kf[Mf.PolygonMumbai] = 1.5, kf[Mf.Kovan] = 1.5, kf),
    zd = function(e) {
        return new Promise(function(r) {
            var n = setTimeout(function() {
                clearTimeout(n), r()
            }, e)
        })
    },
    rP = function() {
        function t(r, n, i, s) {
            var o = this,
                f, l, d, p, A, T, N, P, C;
            this.cancelOrder = function() {
                var I = Wt(Je.mark(function U(M) {
                    return Je.wrap(function(D) {
                        for (;;) switch (D.prev = D.next) {
                            case 0:
                                return D.abrupt("return", cM(o.exchangeContract, M));
                            case 1:
                            case "end":
                                return D.stop()
                        }
                    }, U)
                }));
                return function(U) {
                    return I.apply(this, arguments)
                }
            }(), this.waitUntilOrderFilledOrCancelled = function() {
                var I = Wt(Je.mark(function U(M, F, D, q) {
                    var V, Q, ce, O, w, m, a;
                    return Je.wrap(function(g) {
                        for (;;) switch (g.prev = g.next) {
                            case 0:
                                return F === void 0 && (F = 60 * 1e3), D === void 0 && (D = 1e4), q === void 0 && (q = !1), V = !1, Q = zd(F).then(function(v) {
                                    return null
                                }), ce = function() {
                                    var v = Wt(Je.mark(function x() {
                                        var b, y, h;
                                        return Je.wrap(function(_) {
                                            for (;;) switch (_.prev = _.next) {
                                                case 0:
                                                    if (V) {
                                                        _.next = 19;
                                                        break
                                                    }
                                                    return _.next = 3, o.getOrderInfo(M);
                                                case 3:
                                                    if (b = _.sent, b.orderStatus !== Vl.Fillable) {
                                                        _.next = 10;
                                                        break
                                                    }
                                                    return _.next = 7, zd(D);
                                                case 7:
                                                    return _.abrupt("continue", 0);
                                                case 10:
                                                    if (b.orderStatus !== Vl.FullyFilled) {
                                                        _.next = 14;
                                                        break
                                                    }
                                                    return _.abrupt("return", b);
                                                case 14:
                                                    if (!q) {
                                                        _.next = 16;
                                                        break
                                                    }
                                                    throw new Error((y = (h = X9[b.orderStatus]) != null ? h : b.orderStatus) != null ? y : "Unknown status");
                                                case 16:
                                                    return _.abrupt("return", b);
                                                case 17:
                                                    _.next = 0;
                                                    break;
                                                case 19:
                                                    return _.abrupt("return", null);
                                                case 20:
                                                case "end":
                                                    return _.stop()
                                            }
                                        }, x)
                                    }));
                                    return function() {
                                        return v.apply(this, arguments)
                                    }
                                }(), O = function() {
                                    var v = Wt(Je.mark(function x() {
                                        return Je.wrap(function(y) {
                                            for (;;) switch (y.prev = y.next) {
                                                case 0:
                                                    return y.next = 2, zd(F * 2);
                                                case 2:
                                                    return y.abrupt("return", null);
                                                case 3:
                                                case "end":
                                                    return y.stop()
                                            }
                                        }, x)
                                    }));
                                    return function() {
                                        return v.apply(this, arguments)
                                    }
                                }(), w = ce(), m = O(), g.next = 11, Promise.any([Q, w, m]);
                            case 11:
                                return a = g.sent, V = !0, g.abrupt("return", a);
                            case 14:
                            case "end":
                                return g.stop()
                        }
                    }, U)
                }));
                return function(U, M, F, D) {
                    return I.apply(this, arguments)
                }
            }(), this.getOrderInfo = function() {
                var I = Wt(Je.mark(function U(M) {
                    return Je.wrap(function(D) {
                        for (;;) switch (D.prev = D.next) {
                            case 0:
                                return D.abrupt("return", hM(o.exchangeContract, M));
                            case 1:
                            case "end":
                                return D.stop()
                        }
                    }, U)
                }));
                return function(U) {
                    return I.apply(this, arguments)
                }
            }(), this.getOrderStatus = function() {
                var I = Wt(Je.mark(function U(M) {
                    var F;
                    return Je.wrap(function(q) {
                        for (;;) switch (q.prev = q.next) {
                            case 0:
                                return q.next = 2, o.getOrderInfo(M);
                            case 2:
                                return F = q.sent, q.abrupt("return", F.orderStatus);
                            case 4:
                            case "end":
                                return q.stop()
                        }
                    }, U)
                }));
                return function(U) {
                    return I.apply(this, arguments)
                }
            }(), this.awaitTransactionHash = function() {
                var I = Wt(Je.mark(function U(M) {
                    return Je.wrap(function(D) {
                        for (;;) switch (D.prev = D.next) {
                            case 0:
                                return D.abrupt("return", o.provider.waitForTransaction(M));
                            case 1:
                            case "end":
                                return D.stop()
                        }
                    }, U)
                }));
                return function(U) {
                    return I.apply(this, arguments)
                }
            }(), this.signOrder = function() {
                var I = Wt(Je.mark(function U(M, F, D, q) {
                    var V;
                    return Je.wrap(function(ce) {
                        for (;;) switch (ce.prev = ce.next) {
                            case 0:
                                if (V = D != null ? D : o.signer, V) {
                                    ce.next = 3;
                                    break
                                }
                                throw new Error("signOrder:Signer undefined");
                            case 3:
                                return ce.abrupt("return", gM(M, F, V, o.provider, o.chainId, o.exchangeContract.address, q));
                            case 4:
                            case "end":
                                return ce.stop()
                        }
                    }, U)
                }));
                return function(U, M, F, D) {
                    return I.apply(this, arguments)
                }
            }(), this.buildOrder = function(I, U, M, F) {
                var D = {
                        chainId: o.chainId,
                        makerAddress: M
                    },
                    q = en({}, D, F);
                return wM(Ev(I), Ev(U), q)
            }, this.loadApprovalStatus = function() {
                var I = Wt(Je.mark(function U(M, F) {
                    var D, q;
                    return Je.wrap(function(Q) {
                        for (;;) switch (Q.prev = Q.next) {
                            case 0:
                                return D = Rf(M.type, o.chainId), q = Yl(M), Q.abrupt("return", AM(F, D, q, o.provider));
                            case 3:
                            case "end":
                                return Q.stop()
                        }
                    }, U)
                }));
                return function(U, M) {
                    return I.apply(this, arguments)
                }
            }(), this.getOrderHash = function(I) {
                return dM(I, o.chainId, o.exchangeContract.address)
            }, this.getTypedData = function(I, U, M) {
                var F = Sf(I, U),
                    D = Nf,
                    q = M;
                return {
                    domain: F,
                    types: D,
                    value: q
                }
            }, this.getAssetsFromOrder = function(I) {
                return NM(I)
            }, this.checkIfOrderCanBeFilledWithNativeToken = function(I, U) {
                var M;
                if (U === void 0) {
                    var F;
                    U = (F = o.wrappedNativeTokenContractAddress) != null ? F : void 0
                }
                var D = Jl(I.takerAssetData);
                if (D.assetProxyId.toLowerCase() !== Rr.ERC20.toLowerCase()) return !1;
                var q = D.tokenAddress;
                return q || Bh(!1), q.toLowerCase() === ((M = U) == null ? void 0 : M.toLowerCase())
            }, this.fillSignedOrder = function() {
                var I = Wt(Je.mark(function U(M, F, D) {
                    var q, V, Q, ce, O, w, m, a, c, g;
                    return Je.wrap(function(x) {
                        for (;;) switch (x.prev = x.next) {
                            case 0:
                                if (D === void 0 && (D = {}), V = (q = F == null ? void 0 : F.exchangeContract) != null ? q : o.exchangeContract, Q = void 0, (F == null ? void 0 : F.gasAmountBufferMultiple) === null ? Q = void 0 : Q = (ce = F == null ? void 0 : F.gasAmountBufferMultiple) != null ? ce : o.getGasMultipleForChainId(o.chainId), !Q) {
                                    x.next = 9;
                                    break
                                }
                                return x.next = 7, MM(M, V);
                            case 7:
                                w = x.sent, O = Math.floor(w.toNumber() * Q);
                            case 9:
                                if (m = en({
                                        gasLimit: O
                                    }, D), !(F != null && F.fillOrderWithNativeTokenInsteadOfWrappedToken)) {
                                    x.next = 17;
                                    break
                                }
                                return o.checkIfOrderCanBeFilledWithNativeToken(M), o.forwarderContractAddress || Bh(!1), c = _v.connect(o.forwarderContractAddress, (a = o.signer) != null ? a : o.provider), g = M.takerAssetAmount, x.abrupt("return", c.marketBuyOrdersWithEth([M], M.makerAssetAmount, [M.signature], [], [], en({
                                    value: g
                                }, m)));
                            case 17:
                                return x.abrupt("return", EM(M, V, m));
                            case 18:
                            case "end":
                                return x.stop()
                        }
                    }, U)
                }));
                return function(U, M, F) {
                    return I.apply(this, arguments)
                }
            }(), this.getGasMultipleForChainId = function(I) {
                if (o.gasBufferMultiples) return o.gasBufferMultiples[o.chainId]
            }, this.normalizeOrder = function(I) {
                var U = Kl(I);
                return U
            }, this.normalizeSignedOrder = function(I) {
                var U = Kl(I);
                return U
            }, this.verifyOrderSignature = function(I, U, M, F) {
                return vM(I, U, M, F)
            }, this.provider = r, this.signer = n, this.chainId = i != null ? i : this.provider._network.chainId;
            var S = If[this.chainId],
                k = (f = s == null ? void 0 : s.exchangeContractAddress) != null ? f : S == null ? void 0 : S.exchange;
            this.exchangeContractAddress = k, this.erc20ProxyContractAddress = (l = s == null ? void 0 : s.erc20ProxyContractAddress) != null ? l : Rf(wn.ERC20, this.chainId), this.erc721ProxyContractAddress = (d = s == null ? void 0 : s.erc721ProxyContractAddress) != null ? d : Rf(wn.ERC721, this.chainId), this.erc1155ProxyContractAddress = (p = s == null ? void 0 : s.erc1155ProxyContractAddress) != null ? p : Rf(wn.ERC1155, this.chainId), this.forwarderContractAddress = (A = (T = s == null ? void 0 : s.forwarderContractAddress) != null ? T : SM(this.chainId)) != null ? A : null, this.wrappedNativeTokenContractAddress = (N = (P = s == null ? void 0 : s.wrappedNativeTokenContractAddress) != null ? P : PM(this.chainId)) != null ? N : null, this.exchangeContractAddress || Bh(!1), this.exchangeContract = Av.connect(k, n != null ? n : r), this.gasBufferMultiples = (C = s == null ? void 0 : s.gasBufferMultiples) != null ? C : IM
        }
        var e = t.prototype;
        return e.approveTokenOrNftByAsset = function() {
            var r = Wt(Je.mark(function i(s, o, f, l) {
                var d, p, A, T, N, P, C, S, k, I;
                return Je.wrap(function(M) {
                    for (;;) switch (M.prev = M.next) {
                        case 0:
                            if (T = (d = l == null ? void 0 : l.exchangeProxyContractAddressForAsset) != null ? d : Rf(s.type, this.chainId), N = (p = l == null ? void 0 : l.signer) != null ? p : this.signer, N) {
                                M.next = 4;
                                break
                            }
                            throw new Error("approveTokenOrNftByAsset:Signer null");
                        case 4:
                            if (P = void 0, (l == null ? void 0 : l.gasAmountBufferMultiple) === null ? P = void 0 : P = (C = l == null ? void 0 : l.gasAmountBufferMultiple) != null ? C : this.getGasMultipleForChainId(this.chainId), !P) {
                                M.next = 12;
                                break
                            }
                            return M.next = 10, TM(T, Yl(s), N, f != null ? f : {}, (k = l == null ? void 0 : l.approve) != null ? k : !0);
                        case 10:
                            I = M.sent, S = Math.floor(I.toNumber() * P);
                        case 12:
                            return M.abrupt("return", _M(T, Yl(s), N, en({
                                gasLimit: S
                            }, f), (A = l == null ? void 0 : l.approve) != null ? A : !0));
                        case 13:
                        case "end":
                            return M.stop()
                    }
                }, i, this)
            }));

            function n(i, s, o, f) {
                return r.apply(this, arguments)
            }
            return n
        }(), t
    }(),
    r0, n0;
(function(t) {
    t[t.SellNFT = 0] = "SellNFT", t[t.BuyNFT = 1] = "BuyNFT"
})(n0 || (n0 = {}));
var Mv;
(function(t) {
    t[t.Invalid = 0] = "Invalid", t[t.Fillable = 1] = "Fillable", t[t.Unfillable = 2] = "Unfillable", t[t.Expired = 3] = "Expired"
})(Mv || (Mv = {}));
r0 = {}, r0[n0.BuyNFT] = "buy", r0[n0.SellNFT] = "sell";
var uo;
(function(t) {
    t[t.Mainnet = 1] = "Mainnet", t[t.Ropsten = 3] = "Ropsten", t[t.Goerli = 5] = "Goerli", t[t.Ubiq = 8] = "Ubiq", t[t.Ganache = 1337] = "Ganache", t[t.Polygon = 137] = "Polygon", t[t.PolygonMumbai = 80001] = "PolygonMumbai", t[t.BSC = 56] = "BSC", t[t.Optimism = 10] = "Optimism", t[t.Fantom = 250] = "Fantom", t[t.Celo = 42220] = "Celo", t[t.Avalance = 43114] = "Avalance"
})(uo || (uo = {}));
uo.Polygon, uo.PolygonMumbai, uo.Mainnet, uo.Optimism, uo.Goerli;
/*!
 * vue-tippy v6.0.0-alpha.65
 * (c) 2022 
 * @license MIT
 */
var zr = "top",
    En = "bottom",
    An = "right",
    Hr = "left",
    Hd = "auto",
    Of = [zr, En, An, Hr],
    pa = "start",
    Cf = "end",
    RM = "clippingParents",
    Nv = "viewport",
    Ff = "popper",
    kM = "reference",
    Sv = Of.reduce(function(t, e) {
        return t.concat([e + "-" + pa, e + "-" + Cf])
    }, []),
    Pv = [].concat(Of, [Hd]).reduce(function(t, e) {
        return t.concat([e, e + "-" + pa, e + "-" + Cf])
    }, []),
    OM = "beforeRead",
    CM = "read",
    FM = "afterRead",
    DM = "beforeMain",
    UM = "main",
    LM = "afterMain",
    BM = "beforeWrite",
    $M = "write",
    GM = "afterWrite",
    zM = [OM, CM, FM, DM, UM, LM, BM, $M, GM];

function Ui(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function si(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function ma(t) {
    var e = si(t).Element;
    return t instanceof e || t instanceof Element
}

function _n(t) {
    var e = si(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}

function Iv(t) {
    if (typeof ShadowRoot == "undefined") return !1;
    var e = si(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}

function HM(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(r) {
        var n = e.styles[r] || {},
            i = e.attributes[r] || {},
            s = e.elements[r];
        !_n(s) || !Ui(s) || (Object.assign(s.style, n), Object.keys(i).forEach(function(o) {
            var f = i[o];
            f === !1 ? s.removeAttribute(o) : s.setAttribute(o, f === !0 ? "" : f)
        }))
    })
}

function qM(t) {
    var e = t.state,
        r = {
            popper: {
                position: e.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(e.elements.popper.style, r.popper), e.styles = r, e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow),
        function() {
            Object.keys(e.elements).forEach(function(n) {
                var i = e.elements[n],
                    s = e.attributes[n] || {},
                    o = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]),
                    f = o.reduce(function(l, d) {
                        return l[d] = "", l
                    }, {});
                !_n(i) || !Ui(i) || (Object.assign(i.style, f), Object.keys(s).forEach(function(l) {
                    i.removeAttribute(l)
                }))
            })
        }
}
var Rv = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: HM,
    effect: qM,
    requires: ["computeStyles"]
};

function Li(t) {
    return t.split("-")[0]
}
var lo = Math.max,
    i0 = Math.min,
    ya = Math.round;

function ga(t, e) {
    e === void 0 && (e = !1);
    var r = t.getBoundingClientRect(),
        n = 1,
        i = 1;
    if (_n(t) && e) {
        var s = t.offsetHeight,
            o = t.offsetWidth;
        o > 0 && (n = ya(r.width) / o || 1), s > 0 && (i = ya(r.height) / s || 1)
    }
    return {
        width: r.width / n,
        height: r.height / i,
        top: r.top / i,
        right: r.right / n,
        bottom: r.bottom / i,
        left: r.left / n,
        x: r.left / n,
        y: r.top / i
    }
}

function qd(t) {
    var e = ga(t),
        r = t.offsetWidth,
        n = t.offsetHeight;
    return Math.abs(e.width - r) <= 1 && (r = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: r,
        height: n
    }
}

function kv(t, e) {
    var r = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (r && Iv(r)) {
        var n = e;
        do {
            if (n && t.isSameNode(n)) return !0;
            n = n.parentNode || n.host
        } while (n)
    }
    return !1
}

function Bi(t) {
    return si(t).getComputedStyle(t)
}

function jM(t) {
    return ["table", "td", "th"].indexOf(Ui(t)) >= 0
}

function Is(t) {
    return ((ma(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function s0(t) {
    return Ui(t) === "html" ? t : t.assignedSlot || t.parentNode || (Iv(t) ? t.host : null) || Is(t)
}

function Ov(t) {
    return !_n(t) || Bi(t).position === "fixed" ? null : t.offsetParent
}

function WM(t) {
    var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1,
        r = navigator.userAgent.indexOf("Trident") !== -1;
    if (r && _n(t)) {
        var n = Bi(t);
        if (n.position === "fixed") return null
    }
    for (var i = s0(t); _n(i) && ["html", "body"].indexOf(Ui(i)) < 0;) {
        var s = Bi(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none") return i;
        i = i.parentNode
    }
    return null
}

function Df(t) {
    for (var e = si(t), r = Ov(t); r && jM(r) && Bi(r).position === "static";) r = Ov(r);
    return r && (Ui(r) === "html" || Ui(r) === "body" && Bi(r).position === "static") ? e : r || WM(t) || e
}

function jd(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function Uf(t, e, r) {
    return lo(t, i0(e, r))
}

function VM(t, e, r) {
    var n = Uf(t, e, r);
    return n > r ? r : n
}

function Cv() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}

function Fv(t) {
    return Object.assign({}, Cv(), t)
}

function Dv(t, e) {
    return e.reduce(function(r, n) {
        return r[n] = t, r
    }, {})
}
var KM = function(e, r) {
    return e = typeof e == "function" ? e(Object.assign({}, r.rects, {
        placement: r.placement
    })) : e, Fv(typeof e != "number" ? e : Dv(e, Of))
};

function XM(t) {
    var e, r = t.state,
        n = t.name,
        i = t.options,
        s = r.elements.arrow,
        o = r.modifiersData.popperOffsets,
        f = Li(r.placement),
        l = jd(f),
        d = [Hr, An].indexOf(f) >= 0,
        p = d ? "height" : "width";
    if (!(!s || !o)) {
        var A = KM(i.padding, r),
            T = qd(s),
            N = l === "y" ? zr : Hr,
            P = l === "y" ? En : An,
            C = r.rects.reference[p] + r.rects.reference[l] - o[l] - r.rects.popper[p],
            S = o[l] - r.rects.reference[l],
            k = Df(s),
            I = k ? l === "y" ? k.clientHeight || 0 : k.clientWidth || 0 : 0,
            U = C / 2 - S / 2,
            M = A[N],
            F = I - T[p] - A[P],
            D = I / 2 - T[p] / 2 + U,
            q = Uf(M, D, F),
            V = l;
        r.modifiersData[n] = (e = {}, e[V] = q, e.centerOffset = q - D, e)
    }
}

function JM(t) {
    var e = t.state,
        r = t.options,
        n = r.element,
        i = n === void 0 ? "[data-popper-arrow]" : n;
    i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || !kv(e.elements.popper, i) || (e.elements.arrow = i))
}
var ZM = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: XM,
    effect: JM,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};

function xa(t) {
    return t.split("-")[1]
}
var YM = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};

function QM(t) {
    var e = t.x,
        r = t.y,
        n = window,
        i = n.devicePixelRatio || 1;
    return {
        x: ya(e * i) / i || 0,
        y: ya(r * i) / i || 0
    }
}

function Uv(t) {
    var e, r = t.popper,
        n = t.popperRect,
        i = t.placement,
        s = t.variation,
        o = t.offsets,
        f = t.position,
        l = t.gpuAcceleration,
        d = t.adaptive,
        p = t.roundOffsets,
        A = t.isFixed,
        T = p === !0 ? QM(o) : typeof p == "function" ? p(o) : o,
        N = T.x,
        P = N === void 0 ? 0 : N,
        C = T.y,
        S = C === void 0 ? 0 : C,
        k = o.hasOwnProperty("x"),
        I = o.hasOwnProperty("y"),
        U = Hr,
        M = zr,
        F = window;
    if (d) {
        var D = Df(r),
            q = "clientHeight",
            V = "clientWidth";
        if (D === si(r) && (D = Is(r), Bi(D).position !== "static" && f === "absolute" && (q = "scrollHeight", V = "scrollWidth")), D = D, i === zr || (i === Hr || i === An) && s === Cf) {
            M = En;
            var Q = A && F.visualViewport ? F.visualViewport.height : D[q];
            S -= Q - n.height, S *= l ? 1 : -1
        }
        if (i === Hr || (i === zr || i === En) && s === Cf) {
            U = An;
            var ce = A && F.visualViewport ? F.visualViewport.width : D[V];
            P -= ce - n.width, P *= l ? 1 : -1
        }
    }
    var O = Object.assign({
        position: f
    }, d && YM);
    if (l) {
        var w;
        return Object.assign({}, O, (w = {}, w[M] = I ? "0" : "", w[U] = k ? "0" : "", w.transform = (F.devicePixelRatio || 1) <= 1 ? "translate(" + P + "px, " + S + "px)" : "translate3d(" + P + "px, " + S + "px, 0)", w))
    }
    return Object.assign({}, O, (e = {}, e[M] = I ? S + "px" : "", e[U] = k ? P + "px" : "", e.transform = "", e))
}

function eN(t) {
    var e = t.state,
        r = t.options,
        n = r.gpuAcceleration,
        i = n === void 0 ? !0 : n,
        s = r.adaptive,
        o = s === void 0 ? !0 : s,
        f = r.roundOffsets,
        l = f === void 0 ? !0 : f,
        d = {
            placement: Li(e.placement),
            variation: xa(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: i,
            isFixed: e.options.strategy === "fixed"
        };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, Uv(Object.assign({}, d, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, Uv(Object.assign({}, d, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
    })
}
var tN = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: eN,
        data: {}
    },
    o0 = {
        passive: !0
    };

function rN(t) {
    var e = t.state,
        r = t.instance,
        n = t.options,
        i = n.scroll,
        s = i === void 0 ? !0 : i,
        o = n.resize,
        f = o === void 0 ? !0 : o,
        l = si(e.elements.popper),
        d = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && d.forEach(function(p) {
            p.addEventListener("scroll", r.update, o0)
        }), f && l.addEventListener("resize", r.update, o0),
        function() {
            s && d.forEach(function(p) {
                p.removeEventListener("scroll", r.update, o0)
            }), f && l.removeEventListener("resize", r.update, o0)
        }
}
var nN = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function() {},
        effect: rN,
        data: {}
    },
    iN = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };

function a0(t) {
    return t.replace(/left|right|bottom|top/g, function(e) {
        return iN[e]
    })
}
var sN = {
    start: "end",
    end: "start"
};

function Lv(t) {
    return t.replace(/start|end/g, function(e) {
        return sN[e]
    })
}

function Wd(t) {
    var e = si(t),
        r = e.pageXOffset,
        n = e.pageYOffset;
    return {
        scrollLeft: r,
        scrollTop: n
    }
}

function Vd(t) {
    return ga(Is(t)).left + Wd(t).scrollLeft
}

function oN(t) {
    var e = si(t),
        r = Is(t),
        n = e.visualViewport,
        i = r.clientWidth,
        s = r.clientHeight,
        o = 0,
        f = 0;
    return n && (i = n.width, s = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = n.offsetLeft, f = n.offsetTop)), {
        width: i,
        height: s,
        x: o + Vd(t),
        y: f
    }
}

function aN(t) {
    var e, r = Is(t),
        n = Wd(t),
        i = (e = t.ownerDocument) == null ? void 0 : e.body,
        s = lo(r.scrollWidth, r.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = lo(r.scrollHeight, r.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        f = -n.scrollLeft + Vd(t),
        l = -n.scrollTop;
    return Bi(i || r).direction === "rtl" && (f += lo(r.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: o,
        x: f,
        y: l
    }
}

function Kd(t) {
    var e = Bi(t),
        r = e.overflow,
        n = e.overflowX,
        i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(r + i + n)
}

function Bv(t) {
    return ["html", "body", "#document"].indexOf(Ui(t)) >= 0 ? t.ownerDocument.body : _n(t) && Kd(t) ? t : Bv(s0(t))
}

function Lf(t, e) {
    var r;
    e === void 0 && (e = []);
    var n = Bv(t),
        i = n === ((r = t.ownerDocument) == null ? void 0 : r.body),
        s = si(n),
        o = i ? [s].concat(s.visualViewport || [], Kd(n) ? n : []) : n,
        f = e.concat(o);
    return i ? f : f.concat(Lf(s0(o)))
}

function Xd(t) {
    return Object.assign({}, t, {
        left: t.x,
        top: t.y,
        right: t.x + t.width,
        bottom: t.y + t.height
    })
}

function fN(t) {
    var e = ga(t);
    return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e
}

function $v(t, e) {
    return e === Nv ? Xd(oN(t)) : ma(e) ? fN(e) : Xd(aN(Is(t)))
}

function uN(t) {
    var e = Lf(s0(t)),
        r = ["absolute", "fixed"].indexOf(Bi(t).position) >= 0,
        n = r && _n(t) ? Df(t) : t;
    return ma(n) ? e.filter(function(i) {
        return ma(i) && kv(i, n) && Ui(i) !== "body" && (r ? Bi(i).position !== "static" : !0)
    }) : []
}

function lN(t, e, r) {
    var n = e === "clippingParents" ? uN(t) : [].concat(e),
        i = [].concat(n, [r]),
        s = i[0],
        o = i.reduce(function(f, l) {
            var d = $v(t, l);
            return f.top = lo(d.top, f.top), f.right = i0(d.right, f.right), f.bottom = i0(d.bottom, f.bottom), f.left = lo(d.left, f.left), f
        }, $v(t, s));
    return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o
}

function Gv(t) {
    var e = t.reference,
        r = t.element,
        n = t.placement,
        i = n ? Li(n) : null,
        s = n ? xa(n) : null,
        o = e.x + e.width / 2 - r.width / 2,
        f = e.y + e.height / 2 - r.height / 2,
        l;
    switch (i) {
        case zr:
            l = {
                x: o,
                y: e.y - r.height
            };
            break;
        case En:
            l = {
                x: o,
                y: e.y + e.height
            };
            break;
        case An:
            l = {
                x: e.x + e.width,
                y: f
            };
            break;
        case Hr:
            l = {
                x: e.x - r.width,
                y: f
            };
            break;
        default:
            l = {
                x: e.x,
                y: e.y
            }
    }
    var d = i ? jd(i) : null;
    if (d != null) {
        var p = d === "y" ? "height" : "width";
        switch (s) {
            case pa:
                l[d] = l[d] - (e[p] / 2 - r[p] / 2);
                break;
            case Cf:
                l[d] = l[d] + (e[p] / 2 - r[p] / 2);
                break
        }
    }
    return l
}

function Bf(t, e) {
    e === void 0 && (e = {});
    var r = e,
        n = r.placement,
        i = n === void 0 ? t.placement : n,
        s = r.boundary,
        o = s === void 0 ? RM : s,
        f = r.rootBoundary,
        l = f === void 0 ? Nv : f,
        d = r.elementContext,
        p = d === void 0 ? Ff : d,
        A = r.altBoundary,
        T = A === void 0 ? !1 : A,
        N = r.padding,
        P = N === void 0 ? 0 : N,
        C = Fv(typeof P != "number" ? P : Dv(P, Of)),
        S = p === Ff ? kM : Ff,
        k = t.rects.popper,
        I = t.elements[T ? S : p],
        U = lN(ma(I) ? I : I.contextElement || Is(t.elements.popper), o, l),
        M = ga(t.elements.reference),
        F = Gv({
            reference: M,
            element: k,
            strategy: "absolute",
            placement: i
        }),
        D = Xd(Object.assign({}, k, F)),
        q = p === Ff ? D : M,
        V = {
            top: U.top - q.top + C.top,
            bottom: q.bottom - U.bottom + C.bottom,
            left: U.left - q.left + C.left,
            right: q.right - U.right + C.right
        },
        Q = t.modifiersData.offset;
    if (p === Ff && Q) {
        var ce = Q[i];
        Object.keys(V).forEach(function(O) {
            var w = [An, En].indexOf(O) >= 0 ? 1 : -1,
                m = [zr, En].indexOf(O) >= 0 ? "y" : "x";
            V[O] += ce[m] * w
        })
    }
    return V
}

function cN(t, e) {
    e === void 0 && (e = {});
    var r = e,
        n = r.placement,
        i = r.boundary,
        s = r.rootBoundary,
        o = r.padding,
        f = r.flipVariations,
        l = r.allowedAutoPlacements,
        d = l === void 0 ? Pv : l,
        p = xa(n),
        A = p ? f ? Sv : Sv.filter(function(P) {
            return xa(P) === p
        }) : Of,
        T = A.filter(function(P) {
            return d.indexOf(P) >= 0
        });
    T.length === 0 && (T = A);
    var N = T.reduce(function(P, C) {
        return P[C] = Bf(t, {
            placement: C,
            boundary: i,
            rootBoundary: s,
            padding: o
        })[Li(C)], P
    }, {});
    return Object.keys(N).sort(function(P, C) {
        return N[P] - N[C]
    })
}

function hN(t) {
    if (Li(t) === Hd) return [];
    var e = a0(t);
    return [Lv(t), e, Lv(e)]
}

function dN(t) {
    var e = t.state,
        r = t.options,
        n = t.name;
    if (!e.modifiersData[n]._skip) {
        for (var i = r.mainAxis, s = i === void 0 ? !0 : i, o = r.altAxis, f = o === void 0 ? !0 : o, l = r.fallbackPlacements, d = r.padding, p = r.boundary, A = r.rootBoundary, T = r.altBoundary, N = r.flipVariations, P = N === void 0 ? !0 : N, C = r.allowedAutoPlacements, S = e.options.placement, k = Li(S), I = k === S, U = l || (I || !P ? [a0(S)] : hN(S)), M = [S].concat(U).reduce(function(L, E) {
                return L.concat(Li(E) === Hd ? cN(e, {
                    placement: E,
                    boundary: p,
                    rootBoundary: A,
                    padding: d,
                    flipVariations: P,
                    allowedAutoPlacements: C
                }) : E)
            }, []), F = e.rects.reference, D = e.rects.popper, q = new Map, V = !0, Q = M[0], ce = 0; ce < M.length; ce++) {
            var O = M[ce],
                w = Li(O),
                m = xa(O) === pa,
                a = [zr, En].indexOf(w) >= 0,
                c = a ? "width" : "height",
                g = Bf(e, {
                    placement: O,
                    boundary: p,
                    rootBoundary: A,
                    altBoundary: T,
                    padding: d
                }),
                v = a ? m ? An : Hr : m ? En : zr;
            F[c] > D[c] && (v = a0(v));
            var x = a0(v),
                b = [];
            if (s && b.push(g[w] <= 0), f && b.push(g[v] <= 0, g[x] <= 0), b.every(function(L) {
                    return L
                })) {
                Q = O, V = !1;
                break
            }
            q.set(O, b)
        }
        if (V)
            for (var y = P ? 3 : 1, h = function(E) {
                    var R = M.find(function(G) {
                        var z = q.get(G);
                        if (z) return z.slice(0, E).every(function(j) {
                            return j
                        })
                    });
                    if (R) return Q = R, "break"
                }, u = y; u > 0; u--) {
                var _ = h(u);
                if (_ === "break") break
            }
        e.placement !== Q && (e.modifiersData[n]._skip = !0, e.placement = Q, e.reset = !0)
    }
}
var pN = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: dN,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};

function zv(t, e, r) {
    return r === void 0 && (r = {
        x: 0,
        y: 0
    }), {
        top: t.top - e.height - r.y,
        right: t.right - e.width + r.x,
        bottom: t.bottom - e.height + r.y,
        left: t.left - e.width - r.x
    }
}

function Hv(t) {
    return [zr, An, En, Hr].some(function(e) {
        return t[e] >= 0
    })
}

function mN(t) {
    var e = t.state,
        r = t.name,
        n = e.rects.reference,
        i = e.rects.popper,
        s = e.modifiersData.preventOverflow,
        o = Bf(e, {
            elementContext: "reference"
        }),
        f = Bf(e, {
            altBoundary: !0
        }),
        l = zv(o, n),
        d = zv(f, i, s),
        p = Hv(l),
        A = Hv(d);
    e.modifiersData[r] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: d,
        isReferenceHidden: p,
        hasPopperEscaped: A
    }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": p,
        "data-popper-escaped": A
    })
}
var yN = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: mN
};

function gN(t, e, r) {
    var n = Li(t),
        i = [Hr, zr].indexOf(n) >= 0 ? -1 : 1,
        s = typeof r == "function" ? r(Object.assign({}, e, {
            placement: t
        })) : r,
        o = s[0],
        f = s[1];
    return o = o || 0, f = (f || 0) * i, [Hr, An].indexOf(n) >= 0 ? {
        x: f,
        y: o
    } : {
        x: o,
        y: f
    }
}

function xN(t) {
    var e = t.state,
        r = t.options,
        n = t.name,
        i = r.offset,
        s = i === void 0 ? [0, 0] : i,
        o = Pv.reduce(function(p, A) {
            return p[A] = gN(A, e.rects, s), p
        }, {}),
        f = o[e.placement],
        l = f.x,
        d = f.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += d), e.modifiersData[n] = o
}
var bN = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: xN
};

function vN(t) {
    var e = t.state,
        r = t.name;
    e.modifiersData[r] = Gv({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
var wN = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: vN,
    data: {}
};

function EN(t) {
    return t === "x" ? "y" : "x"
}

function AN(t) {
    var e = t.state,
        r = t.options,
        n = t.name,
        i = r.mainAxis,
        s = i === void 0 ? !0 : i,
        o = r.altAxis,
        f = o === void 0 ? !1 : o,
        l = r.boundary,
        d = r.rootBoundary,
        p = r.altBoundary,
        A = r.padding,
        T = r.tether,
        N = T === void 0 ? !0 : T,
        P = r.tetherOffset,
        C = P === void 0 ? 0 : P,
        S = Bf(e, {
            boundary: l,
            rootBoundary: d,
            padding: A,
            altBoundary: p
        }),
        k = Li(e.placement),
        I = xa(e.placement),
        U = !I,
        M = jd(k),
        F = EN(M),
        D = e.modifiersData.popperOffsets,
        q = e.rects.reference,
        V = e.rects.popper,
        Q = typeof C == "function" ? C(Object.assign({}, e.rects, {
            placement: e.placement
        })) : C,
        ce = typeof Q == "number" ? {
            mainAxis: Q,
            altAxis: Q
        } : Object.assign({
            mainAxis: 0,
            altAxis: 0
        }, Q),
        O = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
        w = {
            x: 0,
            y: 0
        };
    if (!!D) {
        if (s) {
            var m, a = M === "y" ? zr : Hr,
                c = M === "y" ? En : An,
                g = M === "y" ? "height" : "width",
                v = D[M],
                x = v + S[a],
                b = v - S[c],
                y = N ? -V[g] / 2 : 0,
                h = I === pa ? q[g] : V[g],
                u = I === pa ? -V[g] : -q[g],
                _ = e.elements.arrow,
                L = N && _ ? qd(_) : {
                    width: 0,
                    height: 0
                },
                E = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Cv(),
                R = E[a],
                G = E[c],
                z = Uf(0, q[g], L[g]),
                j = U ? q[g] / 2 - y - z - R - ce.mainAxis : h - z - R - ce.mainAxis,
                re = U ? -q[g] / 2 + y + z + G + ce.mainAxis : u + z + G + ce.mainAxis,
                ee = e.elements.arrow && Df(e.elements.arrow),
                K = ee ? M === "y" ? ee.clientTop || 0 : ee.clientLeft || 0 : 0,
                B = (m = O == null ? void 0 : O[M]) != null ? m : 0,
                $ = v + j - B - K,
                H = v + re - B,
                ne = Uf(N ? i0(x, $) : x, v, N ? lo(b, H) : b);
            D[M] = ne, w[M] = ne - v
        }
        if (f) {
            var J, Y = M === "x" ? zr : Hr,
                ue = M === "x" ? En : An,
                te = D[F],
                Z = F === "y" ? "height" : "width",
                se = te + S[Y],
                fe = te - S[ue],
                ie = [zr, Hr].indexOf(k) !== -1,
                me = (J = O == null ? void 0 : O[F]) != null ? J : 0,
                he = ie ? se : te - q[Z] - V[Z] - me + ce.altAxis,
                le = ie ? te + q[Z] + V[Z] - me - ce.altAxis : fe,
                Pe = N && ie ? VM(he, te, le) : Uf(N ? he : se, te, N ? le : fe);
            D[F] = Pe, w[F] = Pe - te
        }
        e.modifiersData[n] = w
    }
}
var _N = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: AN,
    requiresIfExists: ["offset"]
};

function TN(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}

function MN(t) {
    return t === si(t) || !_n(t) ? Wd(t) : TN(t)
}

function NN(t) {
    var e = t.getBoundingClientRect(),
        r = ya(e.width) / t.offsetWidth || 1,
        n = ya(e.height) / t.offsetHeight || 1;
    return r !== 1 || n !== 1
}

function SN(t, e, r) {
    r === void 0 && (r = !1);
    var n = _n(e),
        i = _n(e) && NN(e),
        s = Is(e),
        o = ga(t, i),
        f = {
            scrollLeft: 0,
            scrollTop: 0
        },
        l = {
            x: 0,
            y: 0
        };
    return (n || !n && !r) && ((Ui(e) !== "body" || Kd(s)) && (f = MN(e)), _n(e) ? (l = ga(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = Vd(s))), {
        x: o.left + f.scrollLeft - l.x,
        y: o.top + f.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}

function PN(t) {
    var e = new Map,
        r = new Set,
        n = [];
    t.forEach(function(s) {
        e.set(s.name, s)
    });

    function i(s) {
        r.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function(f) {
            if (!r.has(f)) {
                var l = e.get(f);
                l && i(l)
            }
        }), n.push(s)
    }
    return t.forEach(function(s) {
        r.has(s.name) || i(s)
    }), n
}

function IN(t) {
    var e = PN(t);
    return zM.reduce(function(r, n) {
        return r.concat(e.filter(function(i) {
            return i.phase === n
        }))
    }, [])
}

function RN(t) {
    var e;
    return function() {
        return e || (e = new Promise(function(r) {
            Promise.resolve().then(function() {
                e = void 0, r(t())
            })
        })), e
    }
}

function kN(t) {
    var e = t.reduce(function(r, n) {
        var i = r[n.name];
        return r[n.name] = i ? Object.assign({}, i, n, {
            options: Object.assign({}, i.options, n.options),
            data: Object.assign({}, i.data, n.data)
        }) : n, r
    }, {});
    return Object.keys(e).map(function(r) {
        return e[r]
    })
}
var qv = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};

function jv() {
    for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
    return !e.some(function(n) {
        return !(n && typeof n.getBoundingClientRect == "function")
    })
}

function ON(t) {
    t === void 0 && (t = {});
    var e = t,
        r = e.defaultModifiers,
        n = r === void 0 ? [] : r,
        i = e.defaultOptions,
        s = i === void 0 ? qv : i;
    return function(f, l, d) {
        d === void 0 && (d = s);
        var p = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, qv, s),
                modifiersData: {},
                elements: {
                    reference: f,
                    popper: l
                },
                attributes: {},
                styles: {}
            },
            A = [],
            T = !1,
            N = {
                state: p,
                setOptions: function(k) {
                    var I = typeof k == "function" ? k(p.options) : k;
                    C(), p.options = Object.assign({}, s, p.options, I), p.scrollParents = {
                        reference: ma(f) ? Lf(f) : f.contextElement ? Lf(f.contextElement) : [],
                        popper: Lf(l)
                    };
                    var U = IN(kN([].concat(n, p.options.modifiers)));
                    return p.orderedModifiers = U.filter(function(M) {
                        return M.enabled
                    }), P(), N.update()
                },
                forceUpdate: function() {
                    if (!T) {
                        var k = p.elements,
                            I = k.reference,
                            U = k.popper;
                        if (!!jv(I, U)) {
                            p.rects = {
                                reference: SN(I, Df(U), p.options.strategy === "fixed"),
                                popper: qd(U)
                            }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function(ce) {
                                return p.modifiersData[ce.name] = Object.assign({}, ce.data)
                            });
                            for (var M = 0; M < p.orderedModifiers.length; M++) {
                                if (p.reset === !0) {
                                    p.reset = !1, M = -1;
                                    continue
                                }
                                var F = p.orderedModifiers[M],
                                    D = F.fn,
                                    q = F.options,
                                    V = q === void 0 ? {} : q,
                                    Q = F.name;
                                typeof D == "function" && (p = D({
                                    state: p,
                                    options: V,
                                    name: Q,
                                    instance: N
                                }) || p)
                            }
                        }
                    }
                },
                update: RN(function() {
                    return new Promise(function(S) {
                        N.forceUpdate(), S(p)
                    })
                }),
                destroy: function() {
                    C(), T = !0
                }
            };
        if (!jv(f, l)) return N;
        N.setOptions(d).then(function(S) {
            !T && d.onFirstUpdate && d.onFirstUpdate(S)
        });

        function P() {
            p.orderedModifiers.forEach(function(S) {
                var k = S.name,
                    I = S.options,
                    U = I === void 0 ? {} : I,
                    M = S.effect;
                if (typeof M == "function") {
                    var F = M({
                            state: p,
                            name: k,
                            instance: N,
                            options: U
                        }),
                        D = function() {};
                    A.push(F || D)
                }
            })
        }

        function C() {
            A.forEach(function(S) {
                return S()
            }), A = []
        }
        return N
    }
}
var CN = [nN, wN, tN, Rv, bN, pN, _N, ZM, yN],
    FN = ON({
        defaultModifiers: CN
    }),
    DN = "tippy-box",
    Wv = "tippy-content",
    Vv = "tippy-backdrop",
    Kv = "tippy-arrow",
    Xv = "tippy-svg-arrow",
    co = {
        passive: !0,
        capture: !0
    },
    Jv = function() {
        return document.body
    };

function Jd(t, e, r) {
    if (Array.isArray(t)) {
        var n = t[e];
        return n == null ? Array.isArray(r) ? r[e] : r : n
    }
    return t
}

function Zd(t, e) {
    var r = {}.toString.call(t);
    return r.indexOf("[object") === 0 && r.indexOf(e + "]") > -1
}

function Zv(t, e) {
    return typeof t == "function" ? t.apply(void 0, e) : t
}

function Yv(t, e) {
    if (e === 0) return t;
    var r;
    return function(n) {
        clearTimeout(r), r = setTimeout(function() {
            t(n)
        }, e)
    }
}

function UN(t, e) {
    var r = Object.assign({}, t);
    return e.forEach(function(n) {
        delete r[n]
    }), r
}

function LN(t) {
    return t.split(/\s+/).filter(Boolean)
}

function ho(t) {
    return [].concat(t)
}

function Qv(t, e) {
    t.indexOf(e) === -1 && t.push(e)
}

function BN(t) {
    return t.filter(function(e, r) {
        return t.indexOf(e) === r
    })
}

function e2(t) {
    return t.split("-")[0]
}

function ba(t) {
    return [].slice.call(t)
}

function t2(t) {
    return Object.keys(t).reduce(function(e, r) {
        return t[r] !== void 0 && (e[r] = t[r]), e
    }, {})
}

function po() {
    return document.createElement("div")
}

function f0(t) {
    return ["Element", "Fragment"].some(function(e) {
        return Zd(t, e)
    })
}

function $N(t) {
    return Zd(t, "NodeList")
}

function Yd(t) {
    return Zd(t, "MouseEvent")
}

function GN(t) {
    return !!(t && t._tippy && t._tippy.reference === t)
}

function zN(t) {
    return f0(t) ? [t] : $N(t) ? ba(t) : Array.isArray(t) ? t : ba(document.querySelectorAll(t))
}

function Qd(t, e) {
    t.forEach(function(r) {
        r && (r.style.transitionDuration = e + "ms")
    })
}

function $f(t, e) {
    t.forEach(function(r) {
        r && r.setAttribute("data-state", e)
    })
}

function r2(t) {
    var e, r = ho(t),
        n = r[0];
    return n != null && (e = n.ownerDocument) != null && e.body ? n.ownerDocument : document
}

function HN(t, e) {
    var r = e.clientX,
        n = e.clientY;
    return t.every(function(i) {
        var s = i.popperRect,
            o = i.popperState,
            f = i.props,
            l = f.interactiveBorder,
            d = e2(o.placement),
            p = o.modifiersData.offset;
        if (!p) return !0;
        var A = d === "bottom" ? p.top.y : 0,
            T = d === "top" ? p.bottom.y : 0,
            N = d === "right" ? p.left.x : 0,
            P = d === "left" ? p.right.x : 0,
            C = s.top - n + A > l,
            S = n - s.bottom - T > l,
            k = s.left - r + N > l,
            I = r - s.right - P > l;
        return C || S || k || I
    })
}

function ep(t, e, r) {
    var n = e + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(i) {
        t[n](i, r)
    })
}

function n2(t, e) {
    for (var r = e; r;) {
        var n;
        if (t.contains(r)) return !0;
        r = r.getRootNode == null || (n = r.getRootNode()) == null ? void 0 : n.host
    }
    return !1
}
var $i = {
        isTouch: !1
    },
    i2 = 0;

function qN() {
    $i.isTouch || ($i.isTouch = !0, window.performance && document.addEventListener("mousemove", s2))
}

function s2() {
    var t = performance.now();
    t - i2 < 20 && ($i.isTouch = !1, document.removeEventListener("mousemove", s2)), i2 = t
}

function jN() {
    var t = document.activeElement;
    if (GN(t)) {
        var e = t._tippy;
        t.blur && !e.state.isVisible && t.blur()
    }
}

function WN() {
    document.addEventListener("touchstart", qN, co), window.addEventListener("blur", jN)
}
var VN = typeof window != "undefined" && typeof document != "undefined",
    KN = VN ? !!window.msCrypto : !1,
    XN = {
        animateFill: !1,
        followCursor: !1,
        inlinePositioning: !1,
        sticky: !1
    },
    JN = {
        allowHTML: !1,
        animation: "fade",
        arrow: !0,
        content: "",
        inertia: !1,
        maxWidth: 350,
        role: "tooltip",
        theme: "",
        zIndex: 9999
    },
    oi = Object.assign({
        appendTo: Jv,
        aria: {
            content: "auto",
            expanded: "auto"
        },
        delay: 0,
        duration: [300, 250],
        getReferenceClientRect: null,
        hideOnClick: !0,
        ignoreAttributes: !1,
        interactive: !1,
        interactiveBorder: 2,
        interactiveDebounce: 0,
        moveTransition: "",
        offset: [0, 10],
        onAfterUpdate: function() {},
        onBeforeUpdate: function() {},
        onCreate: function() {},
        onDestroy: function() {},
        onHidden: function() {},
        onHide: function() {},
        onMount: function() {},
        onShow: function() {},
        onShown: function() {},
        onTrigger: function() {},
        onUntrigger: function() {},
        onClickOutside: function() {},
        placement: "top",
        plugins: [],
        popperOptions: {},
        render: null,
        showOnCreate: !1,
        touch: !0,
        trigger: "mouseenter focus",
        triggerTarget: null
    }, XN, JN),
    ZN = Object.keys(oi),
    YN = function(e) {
        var r = Object.keys(e);
        r.forEach(function(n) {
            oi[n] = e[n]
        })
    };

function o2(t) {
    var e = t.plugins || [],
        r = e.reduce(function(n, i) {
            var s = i.name,
                o = i.defaultValue;
            if (s) {
                var f;
                n[s] = t[s] !== void 0 ? t[s] : (f = oi[s]) != null ? f : o
            }
            return n
        }, {});
    return Object.assign({}, t, r)
}

function QN(t, e) {
    var r = e ? Object.keys(o2(Object.assign({}, oi, {
            plugins: e
        }))) : ZN,
        n = r.reduce(function(i, s) {
            var o = (t.getAttribute("data-tippy-" + s) || "").trim();
            if (!o) return i;
            if (s === "content") i[s] = o;
            else try {
                i[s] = JSON.parse(o)
            } catch {
                i[s] = o
            }
            return i
        }, {});
    return n
}

function a2(t, e) {
    var r = Object.assign({}, e, {
        content: Zv(e.content, [t])
    }, e.ignoreAttributes ? {} : QN(t, e.plugins));
    return r.aria = Object.assign({}, oi.aria, r.aria), r.aria = {
        expanded: r.aria.expanded === "auto" ? e.interactive : r.aria.expanded,
        content: r.aria.content === "auto" ? e.interactive ? null : "describedby" : r.aria.content
    }, r
}
var eS = function() {
    return "innerHTML"
};

function tp(t, e) {
    t[eS()] = e
}

function f2(t) {
    var e = po();
    return t === !0 ? e.className = Kv : (e.className = Xv, f0(t) ? e.appendChild(t) : tp(e, t)), e
}

function u2(t, e) {
    f0(e.content) ? (tp(t, ""), t.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? tp(t, e.content) : t.textContent = e.content)
}

function u0(t) {
    var e = t.firstElementChild,
        r = ba(e.children);
    return {
        box: e,
        content: r.find(function(n) {
            return n.classList.contains(Wv)
        }),
        arrow: r.find(function(n) {
            return n.classList.contains(Kv) || n.classList.contains(Xv)
        }),
        backdrop: r.find(function(n) {
            return n.classList.contains(Vv)
        })
    }
}

function l2(t) {
    var e = po(),
        r = po();
    r.className = DN, r.setAttribute("data-state", "hidden"), r.setAttribute("tabindex", "-1");
    var n = po();
    n.className = Wv, n.setAttribute("data-state", "hidden"), u2(n, t.props), e.appendChild(r), r.appendChild(n), i(t.props, t.props);

    function i(s, o) {
        var f = u0(e),
            l = f.box,
            d = f.content,
            p = f.arrow;
        o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (s.content !== o.content || s.allowHTML !== o.allowHTML) && u2(d, t.props), o.arrow ? p ? s.arrow !== o.arrow && (l.removeChild(p), l.appendChild(f2(o.arrow))) : l.appendChild(f2(o.arrow)) : p && l.removeChild(p)
    }
    return {
        popper: e,
        onUpdate: i
    }
}
l2.$$tippy = !0;
var tS = 1,
    l0 = [],
    rp = [];

function rS(t, e) {
    var r = a2(t, Object.assign({}, oi, o2(t2(e)))),
        n, i, s, o = !1,
        f = !1,
        l = !1,
        d = !1,
        p, A, T, N = [],
        P = Yv($, r.interactiveDebounce),
        C, S = tS++,
        k = null,
        I = BN(r.plugins),
        U = {
            isEnabled: !0,
            isVisible: !1,
            isDestroyed: !1,
            isMounted: !1,
            isShown: !1
        },
        M = {
            id: S,
            reference: t,
            popper: po(),
            popperInstance: k,
            props: r,
            state: U,
            plugins: I,
            clearDelayTimeouts: he,
            setProps: le,
            setContent: Pe,
            show: xe,
            hide: de,
            hideWithInteractivity: je,
            enable: ie,
            disable: me,
            unmount: Ie,
            destroy: be
        };
    if (!r.render) return M;
    var F = r.render(M),
        D = F.popper,
        q = F.onUpdate;
    D.setAttribute("data-tippy-root", ""), D.id = "tippy-" + M.id, M.popper = D, t._tippy = M, D._tippy = M;
    var V = I.map(function(X) {
            return X.fn(M)
        }),
        Q = t.hasAttribute("aria-expanded");
    return ee(), y(), v(), x("onCreate", [M]), r.showOnCreate && se(), D.addEventListener("mouseenter", function() {
        M.props.interactive && M.state.isVisible && M.clearDelayTimeouts()
    }), D.addEventListener("mouseleave", function() {
        M.props.interactive && M.props.trigger.indexOf("mouseenter") >= 0 && a().addEventListener("mousemove", P)
    }), M;

    function ce() {
        var X = M.props.touch;
        return Array.isArray(X) ? X : [X, 0]
    }

    function O() {
        return ce()[0] === "hold"
    }

    function w() {
        var X;
        return !!((X = M.props.render) != null && X.$$tippy)
    }

    function m() {
        return C || t
    }

    function a() {
        var X = m().parentNode;
        return X ? r2(X) : document
    }

    function c() {
        return u0(D)
    }

    function g(X) {
        return M.state.isMounted && !M.state.isVisible || $i.isTouch || p && p.type === "focus" ? 0 : Jd(M.props.delay, X ? 0 : 1, oi.delay)
    }

    function v(X) {
        X === void 0 && (X = !1), D.style.pointerEvents = M.props.interactive && !X ? "" : "none", D.style.zIndex = "" + M.props.zIndex
    }

    function x(X, ae, oe) {
        if (oe === void 0 && (oe = !0), V.forEach(function(ye) {
                ye[X] && ye[X].apply(ye, ae)
            }), oe) {
            var ve;
            (ve = M.props)[X].apply(ve, ae)
        }
    }

    function b() {
        var X = M.props.aria;
        if (!!X.content) {
            var ae = "aria-" + X.content,
                oe = D.id,
                ve = ho(M.props.triggerTarget || t);
            ve.forEach(function(ye) {
                var ge = ye.getAttribute(ae);
                if (M.state.isVisible) ye.setAttribute(ae, ge ? ge + " " + oe : oe);
                else {
                    var Ve = ge && ge.replace(oe, "").trim();
                    Ve ? ye.setAttribute(ae, Ve) : ye.removeAttribute(ae)
                }
            })
        }
    }

    function y() {
        if (!(Q || !M.props.aria.expanded)) {
            var X = ho(M.props.triggerTarget || t);
            X.forEach(function(ae) {
                M.props.interactive ? ae.setAttribute("aria-expanded", M.state.isVisible && ae === m() ? "true" : "false") : ae.removeAttribute("aria-expanded")
            })
        }
    }

    function h() {
        a().removeEventListener("mousemove", P), l0 = l0.filter(function(X) {
            return X !== P
        })
    }

    function u(X) {
        if (!($i.isTouch && (l || X.type === "mousedown"))) {
            var ae = X.composedPath && X.composedPath()[0] || X.target;
            if (!(M.props.interactive && n2(D, ae))) {
                if (ho(M.props.triggerTarget || t).some(function(oe) {
                        return n2(oe, ae)
                    })) {
                    if ($i.isTouch || M.state.isVisible && M.props.trigger.indexOf("click") >= 0) return
                } else x("onClickOutside", [M, X]);
                M.props.hideOnClick === !0 && (M.clearDelayTimeouts(), M.hide(), f = !0, setTimeout(function() {
                    f = !1
                }), M.state.isMounted || R())
            }
        }
    }

    function _() {
        l = !0
    }

    function L() {
        l = !1
    }

    function E() {
        var X = a();
        X.addEventListener("mousedown", u, !0), X.addEventListener("touchend", u, co), X.addEventListener("touchstart", L, co), X.addEventListener("touchmove", _, co)
    }

    function R() {
        var X = a();
        X.removeEventListener("mousedown", u, !0), X.removeEventListener("touchend", u, co), X.removeEventListener("touchstart", L, co), X.removeEventListener("touchmove", _, co)
    }

    function G(X, ae) {
        j(X, function() {
            !M.state.isVisible && D.parentNode && D.parentNode.contains(D) && ae()
        })
    }

    function z(X, ae) {
        j(X, ae)
    }

    function j(X, ae) {
        var oe = c().box;

        function ve(ye) {
            ye.target === oe && (ep(oe, "remove", ve), ae())
        }
        if (X === 0) return ae();
        ep(oe, "remove", A), ep(oe, "add", ve), A = ve
    }

    function re(X, ae, oe) {
        oe === void 0 && (oe = !1);
        var ve = ho(M.props.triggerTarget || t);
        ve.forEach(function(ye) {
            ye.addEventListener(X, ae, oe), N.push({
                node: ye,
                eventType: X,
                handler: ae,
                options: oe
            })
        })
    }

    function ee() {
        O() && (re("touchstart", B, {
            passive: !0
        }), re("touchend", H, {
            passive: !0
        })), LN(M.props.trigger).forEach(function(X) {
            if (X !== "manual") switch (re(X, B), X) {
                case "mouseenter":
                    re("mouseleave", H);
                    break;
                case "focus":
                    re(KN ? "focusout" : "blur", ne);
                    break;
                case "focusin":
                    re("focusout", ne);
                    break
            }
        })
    }

    function K() {
        N.forEach(function(X) {
            var ae = X.node,
                oe = X.eventType,
                ve = X.handler,
                ye = X.options;
            ae.removeEventListener(oe, ve, ye)
        }), N = []
    }

    function B(X) {
        var ae, oe = !1;
        if (!(!M.state.isEnabled || J(X) || f)) {
            var ve = ((ae = p) == null ? void 0 : ae.type) === "focus";
            p = X, C = X.currentTarget, y(), !M.state.isVisible && Yd(X) && l0.forEach(function(ye) {
                return ye(X)
            }), X.type === "click" && (M.props.trigger.indexOf("mouseenter") < 0 || o) && M.props.hideOnClick !== !1 && M.state.isVisible ? oe = !0 : se(X), X.type === "click" && (o = !oe), oe && !ve && fe(X)
        }
    }

    function $(X) {
        var ae = X.target,
            oe = m().contains(ae) || D.contains(ae);
        if (!(X.type === "mousemove" && oe)) {
            var ve = Z().concat(D).map(function(ye) {
                var ge, Ve = ye._tippy,
                    ke = (ge = Ve.popperInstance) == null ? void 0 : ge.state;
                return ke ? {
                    popperRect: ye.getBoundingClientRect(),
                    popperState: ke,
                    props: r
                } : null
            }).filter(Boolean);
            HN(ve, X) && (h(), fe(X))
        }
    }

    function H(X) {
        var ae = J(X) || M.props.trigger.indexOf("click") >= 0 && o;
        if (!ae) {
            if (M.props.interactive) {
                M.hideWithInteractivity(X);
                return
            }
            fe(X)
        }
    }

    function ne(X) {
        M.props.trigger.indexOf("focusin") < 0 && X.target !== m() || M.props.interactive && X.relatedTarget && D.contains(X.relatedTarget) || fe(X)
    }

    function J(X) {
        return $i.isTouch ? O() !== X.type.indexOf("touch") >= 0 : !1
    }

    function Y() {
        ue();
        var X = M.props,
            ae = X.popperOptions,
            oe = X.placement,
            ve = X.offset,
            ye = X.getReferenceClientRect,
            ge = X.moveTransition,
            Ve = w() ? u0(D).arrow : null,
            ke = ye ? {
                getBoundingClientRect: ye,
                contextElement: ye.contextElement || m()
            } : t,
            Ae = {
                name: "$$tippy",
                enabled: !0,
                phase: "beforeWrite",
                requires: ["computeStyles"],
                fn: function(we) {
                    var rt = we.state;
                    if (w()) {
                        var Fe = c(),
                            Ee = Fe.box;
                        ["placement", "reference-hidden", "escaped"].forEach(function(it) {
                            it === "placement" ? Ee.setAttribute("data-placement", rt.placement) : rt.attributes.popper["data-popper-" + it] ? Ee.setAttribute("data-" + it, "") : Ee.removeAttribute("data-" + it)
                        }), rt.attributes.popper = {}
                    }
                }
            },
            et = [{
                name: "offset",
                options: {
                    offset: ve
                }
            }, {
                name: "preventOverflow",
                options: {
                    padding: {
                        top: 2,
                        bottom: 2,
                        left: 5,
                        right: 5
                    }
                }
            }, {
                name: "flip",
                options: {
                    padding: 5
                }
            }, {
                name: "computeStyles",
                options: {
                    adaptive: !ge
                }
            }, Ae];
        w() && Ve && et.push({
            name: "arrow",
            options: {
                element: Ve,
                padding: 3
            }
        }), et.push.apply(et, (ae == null ? void 0 : ae.modifiers) || []), M.popperInstance = FN(ke, D, Object.assign({}, ae, {
            placement: oe,
            onFirstUpdate: T,
            modifiers: et
        }))
    }

    function ue() {
        M.popperInstance && (M.popperInstance.destroy(), M.popperInstance = null)
    }

    function te() {
        var X = M.props.appendTo,
            ae, oe = m();
        M.props.interactive && X === Jv || X === "parent" ? ae = oe.parentNode : ae = Zv(X, [oe]), ae.contains(D) || ae.appendChild(D), M.state.isMounted = !0, Y()
    }

    function Z() {
        return ba(D.querySelectorAll("[data-tippy-root]"))
    }

    function se(X) {
        M.clearDelayTimeouts(), X && x("onTrigger", [M, X]), E();
        var ae = g(!0),
            oe = ce(),
            ve = oe[0],
            ye = oe[1];
        $i.isTouch && ve === "hold" && ye && (ae = ye), ae ? n = setTimeout(function() {
            M.show()
        }, ae) : M.show()
    }

    function fe(X) {
        if (M.clearDelayTimeouts(), x("onUntrigger", [M, X]), !M.state.isVisible) {
            R();
            return
        }
        if (!(M.props.trigger.indexOf("mouseenter") >= 0 && M.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(X.type) >= 0 && o)) {
            var ae = g(!1);
            ae ? i = setTimeout(function() {
                M.state.isVisible && M.hide()
            }, ae) : s = requestAnimationFrame(function() {
                M.hide()
            })
        }
    }

    function ie() {
        M.state.isEnabled = !0
    }

    function me() {
        M.hide(), M.state.isEnabled = !1
    }

    function he() {
        clearTimeout(n), clearTimeout(i), cancelAnimationFrame(s)
    }

    function le(X) {
        if (!M.state.isDestroyed) {
            x("onBeforeUpdate", [M, X]), K();
            var ae = M.props,
                oe = a2(t, Object.assign({}, ae, t2(X), {
                    ignoreAttributes: !0
                }));
            M.props = oe, ee(), ae.interactiveDebounce !== oe.interactiveDebounce && (h(), P = Yv($, oe.interactiveDebounce)), ae.triggerTarget && !oe.triggerTarget ? ho(ae.triggerTarget).forEach(function(ve) {
                ve.removeAttribute("aria-expanded")
            }) : oe.triggerTarget && t.removeAttribute("aria-expanded"), y(), v(), q && q(ae, oe), M.popperInstance && (Y(), Z().forEach(function(ve) {
                requestAnimationFrame(ve._tippy.popperInstance.forceUpdate)
            })), x("onAfterUpdate", [M, X])
        }
    }

    function Pe(X) {
        M.setProps({
            content: X
        })
    }

    function xe() {
        var X = M.state.isVisible,
            ae = M.state.isDestroyed,
            oe = !M.state.isEnabled,
            ve = $i.isTouch && !M.props.touch,
            ye = Jd(M.props.duration, 0, oi.duration);
        if (!(X || ae || oe || ve) && !m().hasAttribute("disabled") && (x("onShow", [M], !1), M.props.onShow(M) !== !1)) {
            if (M.state.isVisible = !0, w() && (D.style.visibility = "visible"), v(), E(), M.state.isMounted || (D.style.transition = "none"), w()) {
                var ge = c(),
                    Ve = ge.box,
                    ke = ge.content;
                Qd([Ve, ke], 0)
            }
            T = function() {
                var et;
                if (!(!M.state.isVisible || d)) {
                    if (d = !0, D.offsetHeight, D.style.transition = M.props.moveTransition, w() && M.props.animation) {
                        var Oe = c(),
                            we = Oe.box,
                            rt = Oe.content;
                        Qd([we, rt], ye), $f([we, rt], "visible")
                    }
                    b(), y(), Qv(rp, M), (et = M.popperInstance) == null || et.forceUpdate(), x("onMount", [M]), M.props.animation && w() && z(ye, function() {
                        M.state.isShown = !0, x("onShown", [M])
                    })
                }
            }, te()
        }
    }

    function de() {
        var X = !M.state.isVisible,
            ae = M.state.isDestroyed,
            oe = !M.state.isEnabled,
            ve = Jd(M.props.duration, 1, oi.duration);
        if (!(X || ae || oe) && (x("onHide", [M], !1), M.props.onHide(M) !== !1)) {
            if (M.state.isVisible = !1, M.state.isShown = !1, d = !1, o = !1, w() && (D.style.visibility = "hidden"), h(), R(), v(!0), w()) {
                var ye = c(),
                    ge = ye.box,
                    Ve = ye.content;
                M.props.animation && (Qd([ge, Ve], ve), $f([ge, Ve], "hidden"))
            }
            b(), y(), M.props.animation ? w() && G(ve, M.unmount) : M.unmount()
        }
    }

    function je(X) {
        a().addEventListener("mousemove", P), Qv(l0, P), P(X)
    }

    function Ie() {
        M.state.isVisible && M.hide(), !!M.state.isMounted && (ue(), Z().forEach(function(X) {
            X._tippy.unmount()
        }), D.parentNode && D.parentNode.removeChild(D), rp = rp.filter(function(X) {
            return X !== M
        }), M.state.isMounted = !1, x("onHidden", [M]))
    }

    function be() {
        M.state.isDestroyed || (M.clearDelayTimeouts(), M.unmount(), K(), delete t._tippy, M.state.isDestroyed = !0, x("onDestroy", [M]))
    }
}

function Re(t, e) {
    e === void 0 && (e = {});
    var r = oi.plugins.concat(e.plugins || []);
    WN();
    var n = Object.assign({}, e, {
            plugins: r
        }),
        i = zN(t),
        s = i.reduce(function(o, f) {
            var l = f && rS(f, n);
            return l && o.push(l), o
        }, []);
    return f0(t) ? s[0] : s
}
Re.defaultProps = oi;
Re.setDefaultProps = YN;
Re.currentInput = $i;
var nS = Object.assign({}, Rv, {
        effect: function(e) {
            var r = e.state,
                n = {
                    popper: {
                        position: r.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            Object.assign(r.elements.popper.style, n.popper), r.styles = n, r.elements.arrow && Object.assign(r.elements.arrow.style, n.arrow)
        }
    }),
    iS = function(e, r) {
        var n;
        r === void 0 && (r = {});
        var i = e,
            s = [],
            o = [],
            f, l = r.overrides,
            d = [],
            p = !1;

        function A() {
            o = i.map(function(M) {
                return ho(M.props.triggerTarget || M.reference)
            }).reduce(function(M, F) {
                return M.concat(F)
            }, [])
        }

        function T() {
            s = i.map(function(M) {
                return M.reference
            })
        }

        function N(M) {
            i.forEach(function(F) {
                M ? F.enable() : F.disable()
            })
        }

        function P(M) {
            return i.map(function(F) {
                var D = F.setProps;
                return F.setProps = function(q) {
                        D(q), F.reference === f && M.setProps(q)
                    },
                    function() {
                        F.setProps = D
                    }
            })
        }

        function C(M, F) {
            var D = o.indexOf(F);
            if (F !== f) {
                f = F;
                var q = (l || []).concat("content").reduce(function(V, Q) {
                    return V[Q] = i[D].props[Q], V
                }, {});
                M.setProps(Object.assign({}, q, {
                    getReferenceClientRect: typeof q.getReferenceClientRect == "function" ? q.getReferenceClientRect : function() {
                        var V;
                        return (V = s[D]) == null ? void 0 : V.getBoundingClientRect()
                    }
                }))
            }
        }
        N(!1), T(), A();
        var S = {
                fn: function() {
                    return {
                        onDestroy: function() {
                            N(!0)
                        },
                        onHidden: function() {
                            f = null
                        },
                        onClickOutside: function(D) {
                            D.props.showOnCreate && !p && (p = !0, f = null)
                        },
                        onShow: function(D) {
                            D.props.showOnCreate && !p && (p = !0, C(D, s[0]))
                        },
                        onTrigger: function(D, q) {
                            C(D, q.currentTarget)
                        }
                    }
                }
            },
            k = Re(po(), Object.assign({}, UN(r, ["overrides"]), {
                plugins: [S].concat(r.plugins || []),
                triggerTarget: o,
                popperOptions: Object.assign({}, r.popperOptions, {
                    modifiers: [].concat(((n = r.popperOptions) == null ? void 0 : n.modifiers) || [], [nS])
                })
            })),
            I = k.show;
        k.show = function(M) {
            if (I(), !f && M == null) return C(k, s[0]);
            if (!(f && M == null)) {
                if (typeof M == "number") return s[M] && C(k, s[M]);
                if (i.indexOf(M) >= 0) {
                    var F = M.reference;
                    return C(k, F)
                }
                if (s.indexOf(M) >= 0) return C(k, M)
            }
        }, k.showNext = function() {
            var M = s[0];
            if (!f) return k.show(0);
            var F = s.indexOf(f);
            k.show(s[F + 1] || M)
        }, k.showPrevious = function() {
            var M = s[s.length - 1];
            if (!f) return k.show(M);
            var F = s.indexOf(f),
                D = s[F - 1] || M;
            k.show(D)
        };
        var U = k.setProps;
        return k.setProps = function(M) {
            l = M.overrides || l, U(M)
        }, k.setInstances = function(M) {
            N(!0), d.forEach(function(F) {
                return F()
            }), i = M, N(!1), T(), A(), d = P(k), k.setProps({
                triggerTarget: o
            })
        }, d = P(k), k
    },
    sS = {
        name: "animateFill",
        defaultValue: !1,
        fn: function(e) {
            var r;
            if (!((r = e.props.render) != null && r.$$tippy)) return {};
            var n = u0(e.popper),
                i = n.box,
                s = n.content,
                o = e.props.animateFill ? oS() : null;
            return {
                onCreate: function() {
                    o && (i.insertBefore(o, i.firstElementChild), i.setAttribute("data-animatefill", ""), i.style.overflow = "hidden", e.setProps({
                        arrow: !1,
                        animation: "shift-away"
                    }))
                },
                onMount: function() {
                    if (o) {
                        var l = i.style.transitionDuration,
                            d = Number(l.replace("ms", ""));
                        s.style.transitionDelay = Math.round(d / 10) + "ms", o.style.transitionDuration = l, $f([o], "visible")
                    }
                },
                onShow: function() {
                    o && (o.style.transitionDuration = "0ms")
                },
                onHide: function() {
                    o && $f([o], "hidden")
                }
            }
        }
    };

function oS() {
    var t = po();
    return t.className = Vv, $f([t], "hidden"), t
}
var np = {
        clientX: 0,
        clientY: 0
    },
    c0 = [];

function c2(t) {
    var e = t.clientX,
        r = t.clientY;
    np = {
        clientX: e,
        clientY: r
    }
}

function aS(t) {
    t.addEventListener("mousemove", c2)
}

function fS(t) {
    t.removeEventListener("mousemove", c2)
}
var uS = {
    name: "followCursor",
    defaultValue: !1,
    fn: function(e) {
        var r = e.reference,
            n = r2(e.props.triggerTarget || r),
            i = !1,
            s = !1,
            o = !0,
            f = e.props;

        function l() {
            return e.props.followCursor === "initial" && e.state.isVisible
        }

        function d() {
            n.addEventListener("mousemove", T)
        }

        function p() {
            n.removeEventListener("mousemove", T)
        }

        function A() {
            i = !0, e.setProps({
                getReferenceClientRect: null
            }), i = !1
        }

        function T(C) {
            var S = C.target ? r.contains(C.target) : !0,
                k = e.props.followCursor,
                I = C.clientX,
                U = C.clientY,
                M = r.getBoundingClientRect(),
                F = I - M.left,
                D = U - M.top;
            (S || !e.props.interactive) && e.setProps({
                getReferenceClientRect: function() {
                    var V = r.getBoundingClientRect(),
                        Q = I,
                        ce = U;
                    k === "initial" && (Q = V.left + F, ce = V.top + D);
                    var O = k === "horizontal" ? V.top : ce,
                        w = k === "vertical" ? V.right : Q,
                        m = k === "horizontal" ? V.bottom : ce,
                        a = k === "vertical" ? V.left : Q;
                    return {
                        width: w - a,
                        height: m - O,
                        top: O,
                        right: w,
                        bottom: m,
                        left: a
                    }
                }
            })
        }

        function N() {
            e.props.followCursor && (c0.push({
                instance: e,
                doc: n
            }), aS(n))
        }

        function P() {
            c0 = c0.filter(function(C) {
                return C.instance !== e
            }), c0.filter(function(C) {
                return C.doc === n
            }).length === 0 && fS(n)
        }
        return {
            onCreate: N,
            onDestroy: P,
            onBeforeUpdate: function() {
                f = e.props
            },
            onAfterUpdate: function(S, k) {
                var I = k.followCursor;
                i || I !== void 0 && f.followCursor !== I && (P(), I ? (N(), e.state.isMounted && !s && !l() && d()) : (p(), A()))
            },
            onMount: function() {
                e.props.followCursor && !s && (o && (T(np), o = !1), l() || d())
            },
            onTrigger: function(S, k) {
                Yd(k) && (np = {
                    clientX: k.clientX,
                    clientY: k.clientY
                }), s = k.type === "focus"
            },
            onHidden: function() {
                e.props.followCursor && (A(), p(), o = !0)
            }
        }
    }
};

function lS(t, e) {
    var r;
    return {
        popperOptions: Object.assign({}, t.popperOptions, {
            modifiers: [].concat((((r = t.popperOptions) == null ? void 0 : r.modifiers) || []).filter(function(n) {
                var i = n.name;
                return i !== e.name
            }), [e])
        })
    }
}
var cS = {
    name: "inlinePositioning",
    defaultValue: !1,
    fn: function(e) {
        var r = e.reference;

        function n() {
            return !!e.props.inlinePositioning
        }
        var i, s = -1,
            o = !1,
            f = [],
            l = {
                name: "tippyInlinePositioning",
                enabled: !0,
                phase: "afterWrite",
                fn: function(N) {
                    var P = N.state;
                    n() && (f.indexOf(P.placement) !== -1 && (f = []), i !== P.placement && f.indexOf(P.placement) === -1 && (f.push(P.placement), e.setProps({
                        getReferenceClientRect: function() {
                            return d(P.placement)
                        }
                    })), i = P.placement)
                }
            };

        function d(T) {
            return hS(e2(T), r.getBoundingClientRect(), ba(r.getClientRects()), s)
        }

        function p(T) {
            o = !0, e.setProps(T), o = !1
        }

        function A() {
            o || p(lS(e.props, l))
        }
        return {
            onCreate: A,
            onAfterUpdate: A,
            onTrigger: function(N, P) {
                if (Yd(P)) {
                    var C = ba(e.reference.getClientRects()),
                        S = C.find(function(I) {
                            return I.left - 2 <= P.clientX && I.right + 2 >= P.clientX && I.top - 2 <= P.clientY && I.bottom + 2 >= P.clientY
                        }),
                        k = C.indexOf(S);
                    s = k > -1 ? k : s
                }
            },
            onHidden: function() {
                s = -1
            }
        }
    }
};

function hS(t, e, r, n) {
    if (r.length < 2 || t === null) return e;
    if (r.length === 2 && n >= 0 && r[0].left > r[1].right) return r[n] || e;
    switch (t) {
        case "top":
        case "bottom":
            {
                var i = r[0],
                    s = r[r.length - 1],
                    o = t === "top",
                    f = i.top,
                    l = s.bottom,
                    d = o ? i.left : s.left,
                    p = o ? i.right : s.right,
                    A = p - d,
                    T = l - f;
                return {
                    top: f,
                    bottom: l,
                    left: d,
                    right: p,
                    width: A,
                    height: T
                }
            }
        case "left":
        case "right":
            {
                var N = Math.min.apply(Math, r.map(function(D) {
                        return D.left
                    })),
                    P = Math.max.apply(Math, r.map(function(D) {
                        return D.right
                    })),
                    C = r.filter(function(D) {
                        return t === "left" ? D.left === N : D.right === P
                    }),
                    S = C[0].top,
                    k = C[C.length - 1].bottom,
                    I = N,
                    U = P,
                    M = U - I,
                    F = k - S;
                return {
                    top: S,
                    bottom: k,
                    left: I,
                    right: U,
                    width: M,
                    height: F
                }
            }
        default:
            return e
    }
}
var dS = {
    name: "sticky",
    defaultValue: !1,
    fn: function(e) {
        var r = e.reference,
            n = e.popper;

        function i() {
            return e.popperInstance ? e.popperInstance.state.elements.reference : r
        }

        function s(d) {
            return e.props.sticky === !0 || e.props.sticky === d
        }
        var o = null,
            f = null;

        function l() {
            var d = s("reference") ? i().getBoundingClientRect() : null,
                p = s("popper") ? n.getBoundingClientRect() : null;
            (d && h2(o, d) || p && h2(f, p)) && e.popperInstance && e.popperInstance.update(), o = d, f = p, e.state.isMounted && requestAnimationFrame(l)
        }
        return {
            onMount: function() {
                e.props.sticky && l()
            }
        }
    }
};

function h2(t, e) {
    return t && e ? t.top !== e.top || t.right !== e.right || t.bottom !== e.bottom || t.left !== e.left : !0
}
Re.setDefaultProps({
    render: l2
});
Re.setDefaultProps({
    onShow: t => {
        if (!t.props.content) return !1
    }
});

function d2(t, e = {}, r = {
    mount: !0
}) {
    const n = gm(),
        i = Zt(),
        s = Zt({
            isEnabled: !1,
            isVisible: !1,
            isDestroyed: !1,
            isMounted: !1,
            isShown: !1
        });
    let o = null;
    const f = () => o || (o = document.createDocumentFragment(), o),
        l = D => {
            let q, V = Ut(D) ? D.value : D;
            if (Ta(V)) n && (V.appContext = n.appContext), yu(V, f()), q = () => f();
            else if (typeof V == "object") {
                let Q = Ws(V);
                n && (Q.appContext = n.appContext), yu(Q, f()), q = () => f()
            } else q = V;
            return q
        },
        d = D => {
            let q = {};
            return Ut(D) ? q = D.value || {} : fs(D) ? q = mo({}, D) : q = mo({}, D), q.content && (q.content = l(q.content)), q.triggerTarget && (q.triggerTarget = Ut(q.triggerTarget) ? q.triggerTarget.value : q.triggerTarget), (!q.plugins || !Array.isArray(q.plugins)) && (q.plugins = []), q.plugins = q.plugins.filter(V => V.name !== "vueTippyReactiveState"), q.plugins.push({
                name: "vueTippyReactiveState",
                fn: () => ({
                    onCreate() {
                        s.value.isEnabled = !0
                    },
                    onMount() {
                        s.value.isMounted = !0
                    },
                    onShow() {
                        s.value.isMounted = !0, s.value.isVisible = !0
                    },
                    onShown() {
                        s.value.isShown = !0
                    },
                    onHide() {
                        s.value.isMounted = !1, s.value.isVisible = !1
                    },
                    onHidden() {
                        s.value.isShown = !1
                    },
                    onUnmounted() {
                        s.value.isMounted = !1
                    },
                    onDestroy() {
                        s.value.isDestroyed = !0
                    }
                })
            }), q
        },
        p = () => {
            !i.value || i.value.setProps(d(e))
        },
        A = () => {
            !i.value || !e.content || i.value.setContent(l(e.content))
        },
        T = D => {
            var q;
            (q = i.value) === null || q === void 0 || q.setContent(l(D))
        },
        N = D => {
            var q;
            (q = i.value) === null || q === void 0 || q.setProps(d(D))
        },
        P = () => {
            i.value && (i.value.destroy(), i.value = void 0), o = null
        },
        C = () => {
            var D;
            (D = i.value) === null || D === void 0 || D.show()
        },
        S = () => {
            var D;
            (D = i.value) === null || D === void 0 || D.hide()
        },
        k = () => {
            var D;
            (D = i.value) === null || D === void 0 || D.disable(), s.value.isEnabled = !1
        },
        I = () => {
            var D;
            (D = i.value) === null || D === void 0 || D.enable(), s.value.isEnabled = !0
        },
        U = () => {
            var D;
            (D = i.value) === null || D === void 0 || D.unmount()
        },
        M = () => {
            if (!t) return;
            let D = Ut(t) ? t.value : t;
            typeof D == "function" && (D = D()), D && (i.value = Re(D, d(e)), D.$tippy = F)
        },
        F = {
            tippy: i,
            refresh: p,
            refreshContent: A,
            setContent: T,
            setProps: N,
            destroy: P,
            hide: S,
            show: C,
            disable: k,
            enable: I,
            unmount: U,
            mount: M,
            state: s
        };
    return r.mount && (n ? (n.isMounted ? M() : us(M), Ao(() => {
        P()
    })) : M()), Ut(e) || fs(e) ? ds(e, p, {
        immediate: !1
    }) : Ut(e.content) && ds(e.content, A, {
        immediate: !1
    }), F
}

function pS(t, e) {
    const r = Zt();
    return us(() => {
        const i = (Array.isArray(t) ? t.map(s => s.value) : typeof t == "function" ? t() : t.value).map(s => s instanceof Element ? s._tippy : s).filter(Boolean);
        r.value = iS(i, e ? mo({
            allowHTML: !0
        }, e) : {
            allowHTML: !0
        })
    }), {
        singleton: r
    }
}
const mS = Eo({
        props: {
            to: {
                type: [String, Function]
            },
            tag: {
                type: String,
                default: "span"
            },
            contentTag: {
                type: String,
                default: "span"
            },
            contentClass: {
                type: String,
                default: null
            },
            appendTo: {
                default: () => Re.defaultProps.appendTo
            },
            aria: {
                default: () => Re.defaultProps.aria
            },
            delay: {
                default: () => Re.defaultProps.delay
            },
            duration: {
                default: () => Re.defaultProps.duration
            },
            getReferenceClientRect: {
                default: () => Re.defaultProps.getReferenceClientRect
            },
            hideOnClick: {
                type: [Boolean, String],
                default: () => Re.defaultProps.hideOnClick
            },
            ignoreAttributes: {
                type: Boolean,
                default: () => Re.defaultProps.ignoreAttributes
            },
            interactive: {
                type: Boolean,
                default: () => Re.defaultProps.interactive
            },
            interactiveBorder: {
                default: () => Re.defaultProps.interactiveBorder
            },
            interactiveDebounce: {
                default: () => Re.defaultProps.interactiveDebounce
            },
            moveTransition: {
                default: () => Re.defaultProps.moveTransition
            },
            offset: {
                default: () => Re.defaultProps.offset
            },
            onAfterUpdate: {
                default: () => Re.defaultProps.onAfterUpdate
            },
            onBeforeUpdate: {
                default: () => Re.defaultProps.onBeforeUpdate
            },
            onCreate: {
                default: () => Re.defaultProps.onCreate
            },
            onDestroy: {
                default: () => Re.defaultProps.onDestroy
            },
            onHidden: {
                default: () => Re.defaultProps.onHidden
            },
            onHide: {
                default: () => Re.defaultProps.onHide
            },
            onMount: {
                default: () => Re.defaultProps.onMount
            },
            onShow: {
                default: () => Re.defaultProps.onShow
            },
            onShown: {
                default: () => Re.defaultProps.onShown
            },
            onTrigger: {
                default: () => Re.defaultProps.onTrigger
            },
            onUntrigger: {
                default: () => Re.defaultProps.onUntrigger
            },
            onClickOutside: {
                default: () => Re.defaultProps.onClickOutside
            },
            placement: {
                default: () => Re.defaultProps.placement
            },
            plugins: {
                default: () => Re.defaultProps.plugins
            },
            popperOptions: {
                default: () => Re.defaultProps.popperOptions
            },
            render: {
                default: () => Re.defaultProps.render
            },
            showOnCreate: {
                type: Boolean,
                default: () => Re.defaultProps.showOnCreate
            },
            touch: {
                type: [Boolean, String, Array],
                default: () => Re.defaultProps.touch
            },
            trigger: {
                default: () => Re.defaultProps.trigger
            },
            triggerTarget: {
                default: () => Re.defaultProps.triggerTarget
            },
            animateFill: {
                type: Boolean,
                default: () => Re.defaultProps.animateFill
            },
            followCursor: {
                type: [Boolean, String],
                default: () => Re.defaultProps.followCursor
            },
            inlinePositioning: {
                type: Boolean,
                default: () => Re.defaultProps.inlinePositioning
            },
            sticky: {
                type: [Boolean, String],
                default: () => Re.defaultProps.sticky
            },
            allowHTML: {
                type: Boolean,
                default: () => Re.defaultProps.allowHTML
            },
            animation: {
                default: () => Re.defaultProps.animation
            },
            arrow: {
                default: () => Re.defaultProps.arrow
            },
            content: {
                default: () => Re.defaultProps.content
            },
            inertia: {
                default: () => Re.defaultProps.inertia
            },
            maxWidth: {
                default: () => Re.defaultProps.maxWidth
            },
            role: {
                default: () => Re.defaultProps.role
            },
            theme: {
                default: () => Re.defaultProps.theme
            },
            zIndex: {
                default: () => Re.defaultProps.zIndex
            }
        },
        emits: ["state"],
        setup(t, {
            slots: e,
            emit: r,
            expose: n
        }) {
            const i = Zt(),
                s = Zt(),
                o = Zt(!1),
                f = () => {
                    let A = mo({}, t);
                    for (const T of ["to", "tag", "contentTag", "contentClass"]) A.hasOwnProperty(T) && delete A[T];
                    return A
                };
            let l = i;
            t.to && (typeof Element != "undefined" && t.to instanceof Element ? l = () => t.to : (typeof t.to == "string" || t.to instanceof String) && (l = () => document.querySelector(t.to)));
            const d = d2(l, f());
            us(() => {
                o.value = !0, Z0(() => {
                    e.content && d.setContent(() => s.value)
                })
            }), ds(d.state, () => {
                r("state", Us(d.state))
            }, {
                immediate: !0,
                deep: !0
            }), ds(() => t, () => {
                d.setProps(f()), e.content && d.setContent(() => s.value)
            }, {
                deep: !0
            });
            let p = wo(mo({
                elem: i,
                contentElem: s,
                mounted: o
            }, d));
            return n(p), () => {
                const A = e.default ? e.default(p) : [];
                return Ws(t.tag, {
                    ref: i,
                    "data-v-tippy": ""
                }, e.content ? [A, Ws(t.contentTag, {
                    ref: s,
                    style: {
                        display: o.value ? "inherit" : "none"
                    },
                    class: t.contentClass
                }, e.content(p))] : A)
            }
        }
    }),
    yS = ["a11y", "allowHTML", "arrow", "flip", "flipOnUpdate", "hideOnClick", "ignoreAttributes", "inertia", "interactive", "lazy", "multiple", "showOnInit", "touch", "touchHold"];
let ip = {};
Object.keys(Re.defaultProps).forEach(t => {
    yS.includes(t) ? ip[t] = {
        type: Boolean,
        default: function() {
            return Re.defaultProps[t]
        }
    } : ip[t] = {
        default: function() {
            return Re.defaultProps[t]
        }
    }
});
const gS = Eo({
        props: ip,
        setup(t) {
            const e = Zt([]),
                {
                    singleton: r
                } = pS(e, t);
            return {
                instances: e,
                singleton: r
            }
        },
        mounted() {
            var t;
            const r = this.$el.parentElement.querySelectorAll("[data-v-tippy]");
            this.instances = Array.from(r).map(n => n._tippy).filter(Boolean), (t = this.singleton) === null || t === void 0 || t.setInstances(this.instances)
        },
        render() {
            let t = this.$slots.default ? this.$slots.default() : [];
            return Ws(() => t)
        }
    }),
    xS = {
        mounted(t, e, r) {
            const n = typeof e.value == "string" ? {
                    content: e.value
                } : e.value || {},
                i = Object.keys(e.modifiers || {}),
                s = i.find(f => f !== "arrow"),
                o = i.findIndex(f => f === "arrow") !== -1;
            s && (n.placement = n.placement || s), o && (n.arrow = n.arrow !== void 0 ? n.arrow : !0), r.props && r.props.onTippyShow && (n.onShow = function(...f) {
                var l;
                return (l = r.props) === null || l === void 0 ? void 0 : l.onTippyShow(...f)
            }), r.props && r.props.onTippyShown && (n.onShown = function(...f) {
                var l;
                return (l = r.props) === null || l === void 0 ? void 0 : l.onTippyShown(...f)
            }), r.props && r.props.onTippyHidden && (n.onHidden = function(...f) {
                var l;
                return (l = r.props) === null || l === void 0 ? void 0 : l.onTippyHidden(...f)
            }), r.props && r.props.onTippyHide && (n.onHide = function(...f) {
                var l;
                return (l = r.props) === null || l === void 0 ? void 0 : l.onTippyHide(...f)
            }), r.props && r.props.onTippyMount && (n.onMount = function(...f) {
                var l;
                return (l = r.props) === null || l === void 0 ? void 0 : l.onTippyMount(...f)
            }), t.getAttribute("title") && !n.content && (n.content = t.getAttribute("title"), t.removeAttribute("title")), t.getAttribute("content") && !n.content && (n.content = t.getAttribute("content")), d2(t, n)
        },
        unmounted(t) {
            t.$tippy ? t.$tippy.destroy() : t._tippy && t._tippy.destroy()
        },
        updated(t, e) {
            const r = typeof e.value == "string" ? {
                content: e.value
            } : e.value || {};
            t.getAttribute("title") && !r.content && (r.content = t.getAttribute("title"), t.removeAttribute("title")), t.getAttribute("content") && !r.content && (r.content = t.getAttribute("content")), t.$tippy ? t.$tippy.setProps(r || {}) : t._tippy && t._tippy.setProps(r || {})
        }
    },
    bS = {
        install(t, e = {}) {
            Re.setDefaultProps(e.defaultProps || {}), t.directive(e.directive || "tippy", xS), t.component(e.component || "tippy", mS), t.component(e.componentSingleton || "tippy-singleton", gS)
        }
    },
    vS = Re.setDefaultProps;
vS({
    ignoreAttributes: !0,
    plugins: [dS, cS, uS, sS]
});
var nP = bS;
export {
    wo as A, OS as B, B4 as C, _S as D, CS as E, rn as F, Ut as G, FS as H, kS as I, RS as J, IS as K, rP as N, LS as S, nc as T, nP as V, n1 as W, Zt as a, us as b, TS as c, br as d, Ao as e, Ww as f, wr as g, $p as h, mm as i, Hs as j, _t as k, Zw as l, Op as m, p0 as n, vr as o, MS as p, NS as q, Qw as r, AS as s, fp as t, Us as u, SS as v, ds as w, ES as x, PS as y, BS as z
};